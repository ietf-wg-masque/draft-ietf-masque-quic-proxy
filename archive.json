{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-02-27T00:36:27.552613+00:00",
  "repo": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
  "labels": [
    {
      "name": "Ready for Text",
      "description": "",
      "color": "006b75"
    },
    {
      "name": "Discuss",
      "description": "",
      "color": "b60205"
    },
    {
      "name": "Design team",
      "description": "",
      "color": "5903A3"
    },
    {
      "name": "Future work",
      "description": "",
      "color": "DDB4F5"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWU2NTAyNTM5NjQ=",
      "title": "Consider packet replay/injection attacks",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/1",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly",
        "chris-wood"
      ],
      "labels": [],
      "body": "When forwarding for a given CID, the proxy can very simply process a packet without doing any decryption. However, this means the packet may not be valid (it could be a replay, or a packet injected by someone spoofing the IP addresses and CID).\r\n\r\nSince the proxy is acting effectively as a router, this *might* be acceptable. However:\r\n- When the target/origin receives bogus or duplicate QUIC packets, it may be forced to rate-limit traffic from the proxy that forwarded the bad traffic\r\n- The proxy is being made to do work of forwarding packets. If that is more expensive than something that could be done simply to validate the packet (signed hash of the packet, say), then it may be preferable to do some validation.",
      "createdAt": "2020-07-02T23:30:43Z",
      "updatedAt": "2025-02-06T02:25:46Z",
      "closedAt": "2025-02-06T02:25:44Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Now that we have scramble, etc, our discussion of possible attacks is much more robust. We don't prevent active attacks, but the implications are explained in detail.",
          "createdAt": "2025-02-06T02:25:44Z",
          "updatedAt": "2025-02-06T02:25:44Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU2NjIxODU0Nzg=",
      "title": "Include details about proxy connection ID mappings",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/3",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From @DavidSchinazi \r\n\r\nThe issue about connection ID lengths should be addressed: since the end-server decides its own connection IDs, the client and proxy have no control over Server-Connection-Id. If the client sends non-tunneled short header packets, the server won't be able to figure out the connection ID length. The server could try all possible values, but either way I think this should be mentioned in the draft. In particular, the end of the Load Balancer seems to ignore this problem - the proxy's load balancer won't be collaborating with the end-server so I think this is broken\r\n\r\nBeyond this, we can talk about how the proxy can try to re-use a socket between itself and the target, but that it needs to detect cases when a Connection ID cannot be distinguished (due to overlap in part, or insufficient length), and either create a new socket, or fail the request.",
      "createdAt": "2020-07-20T19:35:42Z",
      "updatedAt": "2020-10-14T18:25:36Z",
      "closedAt": "2020-10-14T18:25:35Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure I follow how using a new socket helps here. If the end-server decides to use a 1-byte server connection ID, and the client is using the non-tunneled mode, then the client will send a short header with that 1-byte CID to the main proxy address/port (probably port 443), it won't send to the proxy's ephemeral socket.",
          "createdAt": "2020-07-20T19:39:42Z",
          "updatedAt": "2020-07-20T19:39:42Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Also should cover:\r\n\"the Connection ID MUST be unique across all other clients\" - I think what you meant is: \"Client connection ID mappings have to be unique to allow deterministic forwarding, and therefore servers MUST reject CONNECT-QUIC requests that contain a Client-Connection ID that is already in use\" or something like that. That said, thinking about it more, I'm not sure what I just wrote is correct. Why do we need client connection IDs to be unique?",
          "createdAt": "2020-07-20T19:40:18Z",
          "updatedAt": "2020-07-20T19:40:18Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that we can close this issue in favor of #21 and #22. I tried to explain my thoughts there better than I had in the email that led to opening this issue...",
          "createdAt": "2020-10-14T03:12:30Z",
          "updatedAt": "2020-10-14T03:12:30Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good to me!",
          "createdAt": "2020-10-14T18:25:35Z",
          "updatedAt": "2020-10-14T18:25:35Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU2NjIxODY1MDM=",
      "title": "Discuss cases when QUIC is blocked",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/4",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-20T19:36:50Z",
      "updatedAt": "2020-10-16T18:57:29Z",
      "closedAt": "2020-10-16T18:57:29Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is no longer an issue now that we're an extension of CONNECT-UDP, and define that we just don't echo the headers if we're not over H3",
          "createdAt": "2020-10-16T18:57:29Z",
          "updatedAt": "2020-10-16T18:57:29Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU3MTIyOTA5MDc=",
      "title": "Non HTTP/3 proxies handling of the method",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/5",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Ready for Text"
      ],
      "body": "The spec says:\r\n\r\n> The CONNECT-QUIC method as defined in this document can only be supported by an HTTP/3 proxy. Use of CONNECT-QUIC with older HTTP versions is undefined and MUST be rejected.\r\n\r\nBut RFC7231 says: \r\n   > When a request method is received\r\n   that is unrecognized or not implemented by an origin server, the\r\n   origin server SHOULD respond with the 501 (Not Implemented) status\r\n   code.\r\n\r\nJust checking the two statements are compatible.",
      "createdAt": "2020-09-30T21:24:09Z",
      "updatedAt": "2020-10-09T16:57:51Z",
      "closedAt": "2020-10-09T16:57:51Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, we should just have the 501 behavior",
          "createdAt": "2020-10-08T16:05:00Z",
          "updatedAt": "2020-10-08T16:05:00Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWU3MTIyOTYwMDA=",
      "title": "Message bodies",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/6",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Ready for Text"
      ],
      "body": "The spec says:\r\n\r\n> Body payloads within CONNECT-QUIC requests are undefined, and SHOULD be treated as malformed.\r\n\r\nbut https://tools.ietf.org/html/draft-ietf-httpbis-semantics-11#section-8.4.2 says\r\n\r\n>    Since message parsing (Section 6 of [Messaging]) needs to be\r\n   independent of method semantics (aside from responses to HEAD),\r\n   definitions of new methods cannot change the parsing algorithm or\r\n   prohibit the presence of a message body on either the request or the\r\n   response message.  Definitions of new methods can specify that only a\r\n   zero-length message body is allowed by requiring a Content-Length\r\n   header field with a value of \"0\".\r\n\r\nYou might get a question from the HTTP police.",
      "createdAt": "2020-09-30T21:33:46Z",
      "updatedAt": "2020-10-09T16:57:51Z",
      "closedAt": "2020-10-09T16:57:51Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, we should require Content-Length 0.",
          "createdAt": "2020-10-08T16:06:39Z",
          "updatedAt": "2020-10-08T16:06:39Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWU3MTIzMDM1NDI=",
      "title": "What does a proxy do with short packets unrelated to a ID?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/7",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Ready for Text"
      ],
      "body": "The Spec says\r\n\r\n> Packets forwarded by sending directly to the proxy's IP address and port MUST wait for a successful response to the CONNECT-QUIC request. This ensures that the proxy knows how to forward a given packet.\r\n\r\n> Clients sending QUIC Long Header packets MUST tunnel them within DATAGRAM frames to avoid exposing unnecessary connection metadata. QUIC Short Header packets, on the other hand, can send directly to the proxy (without any tunnelling or encapsulation) once the proxy has sent a successful response for the Server Connection ID.\r\n\r\nThis all makes sense but it's a little light on information about what the proxy should do with packets that are sent to it before the CONNECT-QUIC response. There's two scenarios I picture:\r\n\r\n1) completely unknown short packets. Probably just drop them on the floor?\r\n2) short packets for known IDs (request received) but before the server has sent the response. Probably just drop them on the floor?",
      "createdAt": "2020-09-30T21:48:43Z",
      "updatedAt": "2020-10-09T16:57:51Z",
      "closedAt": "2020-10-09T16:57:51Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the proxy should drop any packets that it hasn't sent a response for. The client can also do DATAGRAM tunneling until it gets the response.",
          "createdAt": "2020-10-08T21:37:26Z",
          "updatedAt": "2020-10-08T21:37:26Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWU3MTIzMDYzNzc=",
      "title": "Handling multiple headers of the same type per request?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/8",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There's some clear requirements on minimum headers\r\n\r\n> Validating that the request include one of either the Client-Connection-Id and the Server-Connection-Id header, along with a Datagram-Flow-Id header. Requests absent any connection ID header MUST be rejected.\r\n\r\nWhat about a proxy that receives multiple headers of the same type, e.g something like\r\n\r\n```\r\nHEADERS\r\n:method = CONNECT-QUIC\r\n:authority = target.example.com:443\r\nclient-connection-id = :MTIzNA==:, :MTIzNB==: \r\ndatagram-flow-id = 1\r\n```\r\n",
      "createdAt": "2020-09-30T21:54:36Z",
      "updatedAt": "2020-10-09T16:57:51Z",
      "closedAt": "2020-10-09T16:57:51Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "My confusion may in part be related to how the headers are presented. In connect-udp they say\r\n\r\n```\r\n   \"Datagram-Flow-Id\" is a Item Structured Header [STRUCT-HDR].  Its\r\n   value MUST be an Integer.\r\n```",
          "createdAt": "2020-09-30T22:20:36Z",
          "updatedAt": "2020-09-30T22:20:36Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Isn't that covered by this?\r\n\r\n```\r\nThe \"Datagram-Flow-ID\" header is an Integer Structured Field {{!I-D.ietf-httpbis-header-structure}}\r\ncontaining the QUIC datagram flow ID to use for tunnelling packets {{!I-D.schinazi-quic-h3-datagram}}\r\n{{!I-D.ietf-quic-datagram}}. The ABNF is:\r\n\r\n~~~\r\n  Datagram-Flow-Id = sf-integer\r\n~~~\r\n```",
          "createdAt": "2020-10-08T21:41:59Z",
          "updatedAt": "2020-10-08T21:41:59Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah I think we just need to state that the headers defined here are `Item` Structured Fields that must be integer.",
          "createdAt": "2020-10-08T22:10:02Z",
          "updatedAt": "2020-10-08T22:10:02Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWU3MTIzMTAxNTI=",
      "title": "Mapping lifetime and stream states",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/10",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Ready for Text"
      ],
      "body": "The spec says:\r\n\r\n> A client that no longer wants a given Connection ID to be forwarded by the proxy, for either direction, MUST reset the stream.\r\n\r\nWhile https://tools.ietf.org/html/draft-ietf-quic-transport-31#section-2.4 says:\r\n\r\n```\r\nOn the sending part of a stream, an application protocol can:\r\n\r\n   *  write data, understanding when stream flow control credit\r\n      (Section 4.1) has successfully been reserved to send the written\r\n      data;\r\n\r\n   *  end the stream (clean termination), resulting in a STREAM frame\r\n      (Section 19.8) with the FIN bit set; and\r\n\r\n   *  reset the stream (abrupt termination), resulting in a RESET_STREAM\r\n      frame (Section 19.4) if the stream was not already in a terminal\r\n      state.\r\n\r\n   On the receiving part of a stream, an application protocol can:\r\n\r\n   *  read data; and\r\n\r\n   *  abort reading of the stream and request closure, possibly\r\n      resulting in a STOP_SENDING frame (Section 19.5).\r\n```\r\n\r\nHTTP/3 approaches this by saying\r\n\r\n```\r\n   Implementations SHOULD cancel requests by abruptly terminating any\r\n   directions of a stream that are still open.  This means resetting the\r\n   sending parts of streams and aborting reading on receiving parts of\r\n   streams; see Section 2.4 of [QUIC-TRANSPORT].\r\n```\r\n\r\nWould it be clearer to lean on HTTP/3 for the CONNECT-UDP client behavior, or is something specific intended with the current text?",
      "createdAt": "2020-09-30T22:02:00Z",
      "updatedAt": "2020-10-09T16:57:52Z",
      "closedAt": "2020-10-09T16:57:52Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, let's just say it cancels the HTTP/3 request.",
          "createdAt": "2020-10-08T21:50:09Z",
          "updatedAt": "2020-10-08T21:50:09Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "MDU6SXNzdWU3MTIzMTEyODk=",
      "title": "Flow ID example values are wrong?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/11",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Ready for Text"
      ],
      "body": "The spec uses `datagram-flow-id = 1`. \r\n\r\nBut https://tools.ietf.org/html/draft-schinazi-quic-h3-datagram-04#section-3 says\r\n\r\n> Even flow identifiers are client-initiated, while odd flow\r\n   identifiers are server-initiated.",
      "createdAt": "2020-09-30T22:04:16Z",
      "updatedAt": "2020-10-09T16:57:52Z",
      "closedAt": "2020-10-09T16:57:52Z",
      "comments": []
    },
    {
      "number": 12,
      "id": "MDU6SXNzdWU3MTIzMTQxMjg=",
      "title": "Is it an error to tunnel short packets?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/12",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Ready for Text"
      ],
      "body": "I can guess at the answer, but is it an error to send short packets in DATAGRAMS using a valid flow ID?",
      "createdAt": "2020-09-30T22:10:18Z",
      "updatedAt": "2020-10-09T16:57:52Z",
      "closedAt": "2020-10-09T16:57:52Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "It's not an error, no. If an endpoint wants to do that, it can. I'll add text to clarify this.",
          "createdAt": "2020-10-08T16:10:46Z",
          "updatedAt": "2020-10-08T16:10:46Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "MDU6SXNzdWU3MTIzMTU4Mjc=",
      "title": "Is proxy handling of un-tunneled Long packets an unenforceable MUST?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/13",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Discuss"
      ],
      "body": "The client requirement is clear but is this enforcable at the proxy? Could you explicitly mark Initials intended for CONNECT-UDP, so that a proxy can spot them and enforce?",
      "createdAt": "2020-09-30T22:13:51Z",
      "updatedAt": "2020-10-09T16:57:52Z",
      "closedAt": "2020-10-09T16:57:52Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "I assume that the proxy could, if it wanted to enforce this, ensure that it never forwarded packets with the long header bit set. Does that work?",
          "createdAt": "2020-10-08T21:33:16Z",
          "updatedAt": "2020-10-08T21:33:16Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWU3MTI5NjkxODA=",
      "title": "Does the proxy echo IDs in the response",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/14",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I might have missed this. In h3 datagram, datagram-flow-id is echoed in the response. In connect-quic, should the IDs be echoed?",
      "createdAt": "2020-10-01T15:50:37Z",
      "updatedAt": "2020-10-08T21:36:06Z",
      "closedAt": "2020-10-08T21:36:06Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "```\r\nThis response MUST also echo any Client-Connection-Id, Server-Connection-Id, and\r\nDatagram-Flow-Id headers included in the request.\r\n```\r\nSeems to be there already =)",
          "createdAt": "2020-10-08T21:36:06Z",
          "updatedAt": "2020-10-08T21:36:06Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWU3MTYwMjU5MDM=",
      "title": "Idle timeouts and forwarded packets",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/15",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Ready for Text"
      ],
      "body": "How do forwarded packets play with the proxy<->client QUIC connection idle timeout behaviour https://tools.ietf.org/html/draft-ietf-quic-transport-31#section-10.1? Does a client need to keepalive the QUIC connection (e.g. PING) in addition to sending packets to be forwarded. It would seem easier for those packets to somehow reset the timer. If that's the intention the spec should say something.",
      "createdAt": "2020-10-06T21:13:17Z",
      "updatedAt": "2020-10-09T16:57:52Z",
      "closedAt": "2020-10-09T16:57:52Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that the forwarded packets should indeed reset the timer. I view it similarly to the idle state that the kernel keeps for IPsec SAs to let an IKE engine know if it should tear down.\r\n\r\nAny issue with saying we should have the timer be kept alive by forwarded packets?",
          "createdAt": "2020-10-08T19:05:49Z",
          "updatedAt": "2020-10-08T19:05:49Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "No issue with it resetting a timer. But I've not thought through all the edge cases. Does it apply in both directions or do we want to reset only on client->proxy packets?",
          "createdAt": "2020-10-08T19:08:41Z",
          "updatedAt": "2020-10-08T19:08:41Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "the reason I ask is because if the client goes away, a large response could keep the connection alive indefinitely. Reseting on client->proxy would naturally reflect the client Acks (and this active relationship) to the origin.",
          "createdAt": "2020-10-08T19:12:34Z",
          "updatedAt": "2020-10-08T19:12:34Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, having this be kept alive based on client -> proxy sounds right.",
          "createdAt": "2020-10-08T21:16:14Z",
          "updatedAt": "2020-10-08T21:16:14Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "MDU6SXNzdWU3MTgwOTEzODQ=",
      "title": "Proxy handling of Connection ID resuse",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/17",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "So the spec says:\r\n\r\n> For any non-zero-length Client Connection ID, the Connection ID MUST be unique\r\nacross all other clients.\r\n\r\nWhat does a proxy do if it detects this is not the case? The logical thing seems to be to fail fast, reject the 2nd CONNECT-QUIC that attempts to reuse an ID already taken. Not sure of a status code - 409 maybe?\r\n\r\n",
      "createdAt": "2020-10-09T12:04:22Z",
      "updatedAt": "2020-10-16T18:56:50Z",
      "closedAt": "2020-10-16T18:56:49Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I was thinking it would reject any reused ID.",
          "createdAt": "2020-10-09T23:37:45Z",
          "updatedAt": "2020-10-09T23:37:45Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed by #24",
          "createdAt": "2020-10-16T18:56:49Z",
          "updatedAt": "2020-10-16T18:56:49Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "MDU6SXNzdWU3MTgwOTMzNTU=",
      "title": "Proxy behaviour when both ends use 0-length Connection IDs",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/18",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is one of \"what if\" curveball questions, sorry.\r\n\r\nBut what if both sides want to use 0-length? When forwarding Short packets, the proxy has to resort to IP:port based forwarding in both directions? ",
      "createdAt": "2020-10-09T12:07:55Z",
      "updatedAt": "2020-10-16T18:55:23Z",
      "closedAt": "2020-10-16T18:55:23Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, if both sides use 0-length, the forwarding must reduce to IP-port mappings. We should add a nice table of how to handle these cases =)",
          "createdAt": "2020-10-09T23:36:35Z",
          "updatedAt": "2020-10-09T23:36:35Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Should be addressed by #24 ",
          "createdAt": "2020-10-16T18:55:23Z",
          "updatedAt": "2020-10-16T18:55:23Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWU3MjEwODE5MzE=",
      "title": "Reusing DATAGRAM Flow IDs",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/20",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the Example section, the spec reuses the same Flow ID for two separate CONNECT-QUIC requests. That seems like a reasonable choice to me, but the spec should explicitly call out that this is allowed, and that the proxy should validate that upon receiving a new CONNECT-UDP request that reuses a flow ID, the authority must match the authority of the first CONNECT-QUIC request that used the same flow ID.",
      "createdAt": "2020-10-14T02:25:22Z",
      "updatedAt": "2020-10-16T18:56:02Z",
      "closedAt": "2020-10-16T18:56:02Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed, good to clarify.",
          "createdAt": "2020-10-14T18:26:13Z",
          "updatedAt": "2020-10-14T18:26:13Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed by #24",
          "createdAt": "2020-10-16T18:56:02Z",
          "updatedAt": "2020-10-16T18:56:02Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "MDU6SXNzdWU3MjEwODUxMTY=",
      "title": "Mapping details don't seem right",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/21",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The only details about how mappings work seem to be this part of the \"Proxy Response Behavior\" section:\r\n> Creating a mapping entry for the QUIC Connection ID in the given direction (client or target server) associated with the client's IP address and UDP port. For any non-zero-length Client Connection ID, the Connection ID MUST be unique across all other clients.\r\n\r\nThat's not right. You need at least the following mappings:\r\n- from flow ID to target IP/port (for tunneling)\r\n- from Server Connection ID to target IP/port (for forwarding)\r\n- from target IP/port to (QUIC connection, flow ID) (for tunneling)\r\n- from target IP/port to client IP/port (for forwarding)",
      "createdAt": "2020-10-14T02:34:11Z",
      "updatedAt": "2020-10-16T18:55:43Z",
      "closedAt": "2020-10-16T18:55:42Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed by #24",
          "createdAt": "2020-10-16T18:55:42Z",
          "updatedAt": "2020-10-16T18:55:42Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "MDU6SXNzdWU3MjEwODc4MDA=",
      "title": "Is the concept of a \"Client Connection ID\" needed?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/22",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The document mentions the concept of a \"Client Connection ID\", but I'm not sure they serve any purpose.\r\n\r\nFor example:\r\n> Clients SHOULD establish mappings for any Client Connection ID values it provides to the destination target. Failure to do so will prevent the target from initiating connection migration probes along new paths.\r\n\r\nWhat is the Client Connection ID mapped *to*? (see #21 about clarifying that)\r\n\r\nIf you create one UDP socket per CONNECT-QUIC request, then you don't need the concept of a Client Connection ID. The server knows how to route packets simply based on the UDP socket they came in on.\r\n\r\nThe draft mentions validating that a Client Connection ID has been properly registered before allowing its use, but I don't see what benefit that provides.\r\n\r\nI feel like this concept might have been inherited from [the original MASQUE QUIC Proxying](https://tools.ietf.org/html/draft-schinazi-masque-protocol-01#section-3.3) but there it was needed to allow the MASQUE server to only use one UDP port, which isn't a requirement here. Am I missing something?",
      "createdAt": "2020-10-14T02:41:57Z",
      "updatedAt": "2020-10-16T18:56:23Z",
      "closedAt": "2020-10-16T18:56:23Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed by #24",
          "createdAt": "2020-10-16T18:56:23Z",
          "updatedAt": "2020-10-16T18:56:23Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "MDU6SXNzdWU3MjEwOTU2MzI=",
      "title": "Forwarding mode cannot work reliably as currently defined",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/23",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Forwarding mode works by having the proxy demultiplex incoming packets by looking at the Destination Connection ID field in short headers: if it's a registered \"Server Connection ID\", it gets forwarded to the target; otherwise, it gets processed as a QUIC packet intended for the proxy itself.\r\n\r\nUnfortunately, Server Connection IDs are not under the control of the proxy, they're under the control of the target(s). So that means that there can easily be conflicts. The fact that short header packets do not carry the connection ID length complicates this further: any connection being a prefix of another one also constitutes a conflict. In the worse case scenario, a single target using zero-length connection IDs would conflict with all other Server Connection IDs.\r\n\r\nIn #17 and #18, a proposed solution is to reject CONNECT-QUIC requests whose Server Connection IDs conflict with existing mappings. This would mean that this protocol would be completely unable to handle a set of targets, which would be unfortunate.\r\n\r\nHowever, we could solve this issue by making the forwarding mode negotiable. Here's a straw man: the client adds a `Forwarding-Mode: 0/1` header to its request to tell the proxy whether it wants forwarding mode for this request or not, and the proxy replies with the same header to indicate whether forwarding mode is allowed for this request. That way, if the server detects a conflict, it gracefully falls back to tunneled mode and everything still works. (Bonus 1: this also allows us to support proxies behind load balancers, they just need to disable forwarding) (Bonus 2: this also allows us to support the [MASQUE Obfuscation](https://tools.ietf.org/html/draft-schinazi-masque-obfuscation-03) use-case by letting the client disable forwarding)",
      "createdAt": "2020-10-14T03:04:19Z",
      "updatedAt": "2020-10-16T18:55:52Z",
      "closedAt": "2020-10-16T18:55:51Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I was expecting that a forwarding mapping failing would mean we'd have to fall back to tunneled mode anyhow. I'll specify this more clearly, as it is the intent.",
          "createdAt": "2020-10-14T18:33:25Z",
          "updatedAt": "2020-10-14T18:33:25Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed by #24",
          "createdAt": "2020-10-16T18:55:51Z",
          "updatedAt": "2020-10-16T18:55:51Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWU3MjMzOTgzNzc=",
      "title": "Improve stream lifecycle description",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/26",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "WRT the Removing Mapping State section\r\n\r\n>This section reads a little weird. I'll make a spin off issueo work on improvements for talking about request stream lifecycle; it should also cover the similar stuff described in H3's CONNECT section like what frames are valid.\r\n\r\n_Originally posted by @LPardue in https://github.com/tfpauly/quic-proxy/pull/24#r505857928_ ",
      "createdAt": "2020-10-16T17:20:33Z",
      "updatedAt": "2020-10-16T21:14:07Z",
      "closedAt": "2020-10-16T21:14:07Z",
      "comments": []
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWU3MjM0MTA2MzU=",
      "title": "Mention something about versions",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/27",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I was surprised to see nothing mentioned about versions. Do you picture an HTTP/3 MASQUE server (so QUIC v1) being able to forward packets for other versions of QUIC?",
      "createdAt": "2020-10-16T17:37:12Z",
      "updatedAt": "2020-10-16T21:14:07Z",
      "closedAt": "2020-10-16T21:14:07Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that, when looking at proxied connections and packets, the proxy only ever uses the concept of Connection ID, and it only looks at QUIC header fields that are part of the invariants. So everything should just work with all versions of QUIC. But at the same time, we have requirements on client behavior (when to send NEW_CONNECTION_ID) that are specific to QUICv1. So we may want to add a paragraph that explains that this should work with all versions but the requirements are described in terms of QUICv1",
          "createdAt": "2020-10-16T18:07:57Z",
          "updatedAt": "2020-10-16T18:07:57Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "A short statement about invariants would work for me.",
          "createdAt": "2020-10-16T18:10:42Z",
          "updatedAt": "2020-10-16T18:10:42Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "MDU6SXNzdWU3NDIwMDU0MzY=",
      "title": "Provide advice about initial MSS of QUIC connections to proxies",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/33",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Ready for Text"
      ],
      "body": "Rather that just using 1200 bytes, QUIC connections to proxies should add extra bytes to account for proxied QUIC connections that will themselves send initial packets of 1200 bytes that will need to fit in DATAGRAM frames.",
      "createdAt": "2020-11-12T23:33:07Z",
      "updatedAt": "2021-04-13T18:54:48Z",
      "closedAt": "2021-04-13T18:54:48Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Can you elaborate please? Where would extra bytes be added?",
          "createdAt": "2020-11-12T23:49:03Z",
          "updatedAt": "2020-11-12T23:49:03Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Say you know you want to proxy QUIC over QUIC. You know that your proxied QUIC connection will need to send a QUIC initial of 1200 bytes. This means you need to be able to send at least 1200-byte DATAGRAM frames.\r\n\r\nIf the QUIC connection to the proxy starts with an MSS of 1200 bytes, you either need to ramp up your effective MSS enough to handle larger frames (such as via path MTU discovery, or just bumping it up optimistically), or you choose a slightly larger initial packet size. Choosing a larger packet size also has the nice benefit of ensuring that the path can actually handle your traffic without risking finding out later it won't work.\r\n\r\nI'm saying we should have text around this topic, and it seems simple to recommend that clients choose a slightly larger initial packet size to the proxy.",
          "createdAt": "2020-11-12T23:52:26Z",
          "updatedAt": "2020-11-12T23:52:26Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, I understand. Our implementation uses a MSS of 1350 and falls back to TCP if that doesn't go through. Adding text to suggest that or PMTUD sounds good to me.",
          "createdAt": "2020-11-13T00:39:29Z",
          "updatedAt": "2020-11-13T00:39:29Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "MDU6SXNzdWU3NDY2NjUyOTk=",
      "title": "Detecting Connection mapping conflicts",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/34",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Ready for Text"
      ],
      "body": "Section 2.4 \r\n\r\n\"The proxy treats two mappings as being in conflict when a conflict is detected for all elements on the left side of the mapping diagrams above.\"\r\n\r\nI think diagrams makes it uncertain what is referred to here. I assume it is the mapping statements in Section 2.1-2.3. \r\n\r\nI think this statement is missing to detect conflicts for the case related to proxy reuse request that are not QUIC flows. Thus two rules are missing. A server-socket that doesn't have any connection-IDs bound to it can't be reused as this is in non-QUIC mode. Secondly, any attempt to reuse a server-socket that has one or more connection-IDs bound to it must not be reused by a connection-ID less request. \r\n\r\nI think maybe a table in this section would be clearer for which values to check to ensure that mapping is okay. \r\n\r\n\r\n\r\n",
      "createdAt": "2020-11-19T15:06:11Z",
      "updatedAt": "2021-04-13T18:52:19Z",
      "closedAt": "2021-04-13T18:52:19Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure, I think the \"no-connection-ID\" case can fold into an empty connection ID, but we can describe that. That would make the rules work as is.",
          "createdAt": "2020-11-19T20:36:31Z",
          "updatedAt": "2020-11-19T20:36:31Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "@tfpauly that can probably be made to work but the case do need consideration as a CONNECT-UDP request without client-connection-ID need to behave as it gotten client-connection-ID=0. I don't think you can \"upgrade\" a existing connection to forwarding mode, if the first CONNECT-UDP request didn't include a client-connection-id. ",
          "createdAt": "2020-11-20T05:26:40Z",
          "updatedAt": "2020-11-20T05:26:40Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, I think we should specify that no connection ID is equivalent to setting 0 as the connection ID\u2014it means no socket reuse and prohibits forwarding later.",
          "createdAt": "2020-11-20T07:00:00Z",
          "updatedAt": "2020-11-20T07:00:00Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWU3NDY2ODYwNTU=",
      "title": "Poor guidance on rejecting short CIDs ",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/35",
      "state": "OPEN",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Detecting Conflict section (2.4) states:\r\n\r\n\"Since very short Connection IDs are more likely to lead to conflicts, particularly zero-length Connection IDs, a proxy MAY choose to reject all requests for very short Connection IDs as conflicts, in anticipation of future conflicts.\"\r\n\r\nSo I think there need to be a framing question for the below. Is the goal here to have multiple different clients with connection-ID to reuse a common server-socket. So that all clients behind a particular MASQUE server wanting to reach popular-service UDP-port=443 will use the same server socket? \r\n\r\nIf that is the case then I can partially understand the MAY to avoid causing clients with long CIDs getting its different CID using different 5-tuples towards the target.\r\n\r\nHow much analysis have you done for what consequences that will result. Having multiple non-coordinated traffic flows share the same 5-tuple will make it very much like a tunnel flow, however this one will most likely be directed to a server. Will that have any strange affect on load-balancing, denial of service mitigation. I see that a bot behind a particular MASQUE service could attempting to share 5-tuple with other clients and use that to DoS those other flows by triggering DoS mitigations for this flow. \r\n\r\nAlso, are you really meaning reject, or simply detect the collision and give the client a new server-socket?\r\n\r\nIf multiple MASQUE client's are not sharing the server-socket then I think this is an unnecessary recommendation that causes issues without any benefit. \r\n\r\nSo the client that attempt to map multiple QUIC CIDs, that might even be the same QUIC connection, to a particular server-socket will likely do this by being aware of this. Thus it will coordinate so that it doesn't conflict. Even if they are uncoordinated there are no point of rejecting a working mapping because it might result in failure later. If the mapping fails, then the proxy simply creates a new server-socket and give it to the client. Rejecting the mapping prior to a conflict occurring and thus using more resource unnecessarily. \r\n\r\nIn the case of totally uncoordinated QUIC connection where one use short CIDs and the other long ones, then I think if there are any considerations to avoid issues for this, that should fall on the client rather than the server to not attempt to map these two connections to the same server-side socket. This collision algorithm is simple and can be run by the client also for those resource it requests.  \r\n",
      "createdAt": "2020-11-19T15:30:45Z",
      "updatedAt": "2020-11-19T20:39:20Z",
      "closedAt": null,
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "An addition here is that maybe there is a need to tease this apart for what occurs on the client-proxy 5-tuple and what happens on the proxy-target 5-tuple. I was very much only thinking of  the later when I wrote the above. \r\n\r\nFor the client-proxy I think we should discuss if there are need for additional client-proxy 5-tuples (different client side UDP ports) to deal with the conflicts from completely uncoordinated CID usage to enable forwarding of these packets? That would require the ports to established and likely some path probing to be done, so possibly a conflict would require additional QUIC connection establishment to the proxy? ",
          "createdAt": "2020-11-19T15:53:17Z",
          "updatedAt": "2020-11-19T15:53:17Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Connection ID awareness doesn't force a server to reuse a UDP socket, but it allows it.\r\n\r\nDepending on the proxy configuration, if it knows it needs to always optimize for forwarding mode, the proxy MAY choose to reject clients that are requesting zero-length CIDs, because it shows that they might be misconfigured and will interfere with the forwarding operation.\r\n\r\nI think the key point here is that the clients are always aware they are proxying, and thus are able to choose good CID lengths; this isn't entirely uncoordinated.",
          "createdAt": "2020-11-19T20:39:20Z",
          "updatedAt": "2020-11-19T20:39:20Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "MDU6SXNzdWU3NDY3MDc1NjE=",
      "title": "Proxy Response Behavior use of server",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/36",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This section needs a clean up in terminology. It uses \"server-facing socket\" which propably should be changed to \"target-facing socket\". \r\n\r\n",
      "createdAt": "2020-11-19T15:56:48Z",
      "updatedAt": "2025-02-06T02:27:08Z",
      "closedAt": "2025-02-06T02:27:07Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "It could be \"target-facing\", yes, but the end-to-end QUIC connection is thought of in terms of Client and Server, too. ",
          "createdAt": "2020-11-19T20:40:18Z",
          "updatedAt": "2020-11-19T20:40:18Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by: https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/53",
          "createdAt": "2025-02-06T02:27:07Z",
          "updatedAt": "2025-02-06T02:27:07Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWU3NDY3MTkyMDg=",
      "title": "Example unclear about long headers",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/37",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The example states:\r\n\r\n\r\n   When the proxy receives a response from target.example.com:443 that\r\n   has 0x31323334 as the Destination Connection ID, the proxy will\r\n   forward that packet to the client on DATAGRAM flow ID 2.\r\n\r\nAnd the later:\r\n\r\n   Upon receiving the response, the client starts sending Short Header\r\n   packets with a Destination Connection ID of 0x61626364 directly to\r\n   the proxy (not tunnelled), and these are forwarded directly to the\r\n   target by the proxy.  Similarly, Short Header packets from the target\r\n   with a Destination Connection ID of 0x31323334 are forwarded directly\r\n   to the client.\r\n\r\nSo the first paragraph I think it is correct as far as long header packets are received. However, will not short header packets from the target arriving at the proxy be forwarded to the client, even if the second request never happened. Thus, the implied connection to the response in the last sentence of the second paragraph is misleading.\r\n",
      "createdAt": "2020-11-19T16:10:16Z",
      "updatedAt": "2025-02-06T02:28:31Z",
      "closedAt": "2025-02-06T02:28:30Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Forwarding mode does rely on the second request being accepted, to allow the server to choose whether or not to forward. This doesn't support only forwarding in one direction, which we deemed to not be a useful feature.",
          "createdAt": "2020-11-19T20:41:50Z",
          "updatedAt": "2020-11-19T20:41:50Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "We believe this comment no longer applies to the design based on capsules. Please let us know if there's any remaining issue!",
          "createdAt": "2025-02-06T02:28:30Z",
          "updatedAt": "2025-02-06T02:28:30Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "MDU6SXNzdWU3NDY3MjU2NjE=",
      "title": "Security Consideration and shared server-sockets between clients",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/38",
      "state": "OPEN",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Lets pull out one issue from #35 that likely need separate treatment.\r\n\r\nSo the security consideration says: \r\n\r\n   Since proxies that forward QUIC packets do not perform any\r\n   cryptographic integrity check, it is possible that these packets are\r\n   either malformed, replays, or otherwise malicious.  This may result\r\n   in proxy targets rate limiting or decreasing the reputation of a\r\n   given proxy.\r\n\r\nSo this is indicating that you agree that forwarded traffic may misbehave and cause reactions in the network. Based on this I think any reuse of 5-tuples between the proxy and the target between multiple clients results in that one MASQUE client and its users could affect the flow of another MASQUE client through its traffic beyond traffic volume. I think that should most definitely be discussed, and I think this is to dangerous and should be recommended against. \r\n\r\nI further think client's need to have some control over re-use of target facing proxy-socket. This as a MASQUE client that represent multiple different users, for example some type of gateway from a network may not have trust in that all its users are good behaving citizens and thus one users traffic should not have fatesharing with another. ",
      "createdAt": "2020-11-19T16:18:04Z",
      "updatedAt": "2025-02-06T02:28:58Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "While I see the concerns, I think we should describe them rather than prohibit anything. If the target is well-known, such as another proxy if we are doing multiple proxy hops, then the concerns about reuse may not apply.",
          "createdAt": "2020-11-19T20:44:05Z",
          "updatedAt": "2025-02-06T02:28:58Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "MDU6SXNzdWU3NDY3MzIyMjc=",
      "title": "Signalling for rate-limits for a client?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/39",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The draft do discuss the aspect that the proxy may rate limit a client. Should there actually be explicit signalling of these rates to the client. \r\n\r\nI also assume these parameters are on client level and thus apply across the different UDP flows. ",
      "createdAt": "2020-11-19T16:25:42Z",
      "updatedAt": "2025-02-06T02:30:36Z",
      "closedAt": "2025-02-06T02:30:36Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "The rate-limiting here is referring to the number of CONNECT or CONNECT-UDP requests the proxy allows for a given client. This would translate into delayed or rejected requests, as a normal HTTP proxy behavior.",
          "createdAt": "2020-11-19T20:45:42Z",
          "updatedAt": "2020-11-19T20:45:42Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah. I think there is nothing special to do here, implementations or deployments can leverage HTTP layer mechanisms if they care. (A big advantage of MASQUE!)",
          "createdAt": "2020-11-19T22:36:17Z",
          "updatedAt": "2020-11-19T22:37:00Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "No, I meant any limits in bits or number of packets. ",
          "createdAt": "2020-11-20T05:10:40Z",
          "updatedAt": "2020-11-20T05:10:40Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Unless something like this already exists for CONNECT in HTTP/1.1 or HTTP/2 I don't know that we need to do anything. ",
          "createdAt": "2020-11-20T05:23:41Z",
          "updatedAt": "2020-11-20T05:23:41Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "@gloinul I think having strict limits on the number of packets or bytes that go through a proxy connection could be enforced by a proxy closing a given CONNECT request stream if it violates a policy. If you want explicit signaling about expected rates or datagram flow control, that'd need to be another separate extension.",
          "createdAt": "2020-11-20T06:58:53Z",
          "updatedAt": "2020-11-20T06:58:53Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe that there isn't anything to do here \u2014 I agree with Lucas's points. Please re-open if you disagree!",
          "createdAt": "2025-02-06T02:30:36Z",
          "updatedAt": "2025-02-06T02:30:36Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "MDU6SXNzdWU3ODYzNDI1Njk=",
      "title": "Clarify that a server-facing socket used for QUIC CIDs should not be shared with non-QUIC flows",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/40",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "If a server-facing socket on a CONNECT-UDP proxy is being shared for multiple proxied QUIC connections, and demuxing by CID, it cannot easily/safely share the socket with other CONNECT-UDP connections that do not indicate a QUIC CID. This is implicit in the text, but not stated directly.\r\n\r\nA corollary of this is that any packet received on a shared socket that doesn't match a known CID must be dropped.",
      "createdAt": "2021-01-14T21:09:49Z",
      "updatedAt": "2021-04-13T18:52:35Z",
      "closedAt": "2021-04-13T18:52:35Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed.",
          "createdAt": "2021-01-14T21:13:23Z",
          "updatedAt": "2021-01-14T21:13:23Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "MDU6SXNzdWU4MjMyNzc4MzA=",
      "title": "Discuss connection migration",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/41",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Connection migration events on a proxy should make it control the pacing of packets being forwarded on a new path until the path is validated. This is necessary to avoid having the target blast a huge amount of data onto a new path that may have different congestion characteristics, or may not have a real client there at all.",
      "createdAt": "2021-03-05T17:23:01Z",
      "updatedAt": "2021-04-13T18:52:09Z",
      "closedAt": "2021-04-13T18:52:09Z",
      "comments": []
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWU4MjkzMjM2OTc=",
      "title": "Discuss loop attack prevention",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/42",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "If a proxy does not enforce the uniqueness of mappings from client-to-proxy connections and server CIDs to server-facing sockets, it is possible for a client to induce packet loops through the proxies. We should discuss this and explain in security considerations why this is critical to avoid.\r\n\r\nI think this also means we should make the mapping requirement in Section 2.2 more stringent to be unique not only for the client-facing socket, but also the client QUIC connection.",
      "createdAt": "2021-03-11T16:40:36Z",
      "updatedAt": "2024-07-18T22:14:13Z",
      "closedAt": "2024-07-18T22:14:13Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "We should also add text to ensure that proxies MUST validate the source IP address of incoming packets when checking the CID mapping - that way a node can't cause a loop without being in the loop itself (which defeats the amplification purpose of creating a loop).",
          "createdAt": "2021-03-11T17:07:57Z",
          "updatedAt": "2021-03-11T17:07:57Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Great point!",
          "createdAt": "2021-03-11T19:21:00Z",
          "updatedAt": "2021-03-11T19:21:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's probably worth clarifying -- beyond what's already there -- that sockets mean 5 tuples here, and maybe even removing the word socket altogether. That seems like an implementation detail. And I can definitely imagine implementations binding to * as their socket and determining the 5 tuple only upon reading a packet.",
          "createdAt": "2021-03-17T01:25:59Z",
          "updatedAt": "2021-03-17T01:25:59Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Agree with Chris, perhaps the term \"socket\" in the draft is more confusing than just using \"5-tuple\"? Many people think of a socket as a non-connected socket.",
          "createdAt": "2021-03-17T02:27:33Z",
          "updatedAt": "2021-03-17T02:27:33Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, we can call it a 5-tuple, or just a tuple. My main concern is how easy to understand the terms \"client-facing 5-tuple\" and \"server-facing 5-tuple\" are.",
          "createdAt": "2021-03-17T15:44:52Z",
          "updatedAt": "2021-03-17T15:44:52Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe loops are handled now by https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/104",
          "createdAt": "2024-07-18T22:14:04Z",
          "updatedAt": "2024-07-18T22:14:04Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "MDU6SXNzdWU4NDY3NjY3MDg=",
      "title": "DNS resolution and reuse",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/43",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "When the client makes an initial CONNECT-UDP request to speak to an origin, if it specifies a DNS hostname, the proxy will do a DNS lookup.  Because of DNS load balancing, we know that the results might be a subset of all possible addresses for that host.  If there are multiple possible IPs in the response, the proxy will pick one.  All well and good.\r\n\r\nOn subsequent CONNECT-UDPs to establish additional forwarding rules, the client/proxy together need to ensure that the same destination IP address is used.  Seems like there are two possible directions for that:\r\n\r\n- Client needs to learn, in the response to the first CONNECT-UDP, which IP address the server selected and do all future CONNECT-UDP requests intended for that host with an explicit IP address.\r\n- Server needs to remember what IP address it selected for a given client/hostname pairing as part of the connection state so long as any forwarding rules are active.\r\n\r\nThe first seems more flexible but requires machinery that doesn't currently exist in this draft.  It also has the advantage that the client could change proxies simply by asking a different proxy to contact that IP address.\r\n\r\nRegardless, there should be discussion in this draft about this potential issue.",
      "createdAt": "2021-03-31T14:24:23Z",
      "updatedAt": "2023-03-07T23:17:48Z",
      "closedAt": "2023-03-07T23:17:48Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "> On subsequent CONNECT-UDPs to establish additional forwarding rules, the client/proxy together need to ensure that the same destination IP address is used.\r\n\r\nWhy is that? Let's assume you have a client that wants to open multiple QUIC connections to a given host and UDP port. Even when CONNECT-UDP isn't in use, there is no guarantee that those two connections will use the same IP. Why would CONNECT-UDP need this requirement?",
          "createdAt": "2021-03-31T15:03:36Z",
          "updatedAt": "2021-03-31T15:03:36Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "Because the multiple CONNECT-UDP streams in this document (QUIC forwarding) represent a single QUIC connection, not multiple.  I agree that vanilla CONNECT-UDP in the adopted draft does not imply this requirement.",
          "createdAt": "2021-03-31T15:40:02Z",
          "updatedAt": "2021-03-31T15:40:02Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh my bad, I thought this issue was on the CONNECT-UDP draft. I agree that the QUIC-aware extension to CONNECT-UDP needs to handle this.",
          "createdAt": "2021-03-31T16:59:27Z",
          "updatedAt": "2021-03-31T16:59:27Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Now that we use capsules, we have a single CONNECT request stream to the proxy.",
          "createdAt": "2023-03-07T23:17:48Z",
          "updatedAt": "2023-03-07T23:17:48Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "MDU6SXNzdWU5NDIyNTQ5OTU=",
      "title": "Stateless Reset handling",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/48",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The draft doesn't currently discuss Stateless Resets at all.\r\n\r\nWhen using vanilla CONNECT-UDP, each client has a dedicated origin-facing port.  If the origin sends a Stateless Reset, it will be forwarded naively, parsed by the client, and the client will close the stream as it is no longer needed.  (Or the client could start a new connection using the same tunnel; doesn't matter to the proxy.)\r\n\r\nWhen using forwarding mode, the proxy will reject Stateless Reset packets as they do not match any open request's registered CIDs.  The client doesn't learn that the connection has failed and will continue to send packets, which the origin will continue to reject, until the connection eventually times out.\r\n\r\nShould we consider having the client provide Stateless Reset tokens to the server alongside the CIDs?  In that case, the proxy could either correctly relay Stateless Reset packets or convert them to stream error(s) for the affected CID.",
      "createdAt": "2021-07-12T16:57:18Z",
      "updatedAt": "2023-03-07T23:16:15Z",
      "closedAt": "2023-03-07T23:16:15Z",
      "comments": []
    },
    {
      "number": 53,
      "id": "I_kwDOEHrEP8484khM",
      "title": "terminology: change \"server\" to \"target\"",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/53",
      "state": "CLOSED",
      "author": "ehaydenr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Under terminology we have \"Client\", \"Proxy\", and \"Target\" defined, but for sockets and connection IDs, \"server\" is used instead of \"target\". The term \"server\" can be ambiguous - it's not immediately obvious whether it's referring to the proxy or the target.\r\n\r\nConsider making it more specific:\r\nServer-facing socket -> Target-facing socket\r\nServer Connection ID -> Target Connection ID\r\nREGISTER_SERVER_CID -> REGISTER_TARGET_CID\r\nACK_SERVER_CID -> ACK_TARGET_CID\r\nCLOSE_SERVER_CID -> CLOSE_TARGET_CID",
      "createdAt": "2021-10-08T21:07:17Z",
      "updatedAt": "2021-10-11T18:08:35Z",
      "closedAt": "2021-10-11T18:08:35Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "@DavidSchinazi what do you think for this bikeshed?",
          "createdAt": "2021-10-08T21:29:03Z",
          "updatedAt": "2021-10-08T21:29:03Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think renaming from server to target would makes this clearer. The notion of a \"target CID\" does sound weird, but I think internal consistency is more important so going with target sounds best",
          "createdAt": "2021-10-11T17:26:21Z",
          "updatedAt": "2021-10-11T17:26:21Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "This might sound like a troll but I mean it sincerely\r\n\r\nREGISTER_SERVER_CID -> REGISTER_TARGET_SERVER_CID\r\n...\r\n\r\nno one will ever get confused by that, and the name length doesn't affect the wire format",
          "createdAt": "2021-10-11T17:37:28Z",
          "updatedAt": "2021-10-11T17:37:28Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I like REGISTER_TARGET_SERVER_CID, whether or not it's a troll",
          "createdAt": "2021-10-11T17:46:16Z",
          "updatedAt": "2021-10-11T17:46:16Z"
        }
      ]
    },
    {
      "number": 54,
      "id": "I_kwDOEHrEP8485-1V",
      "title": "QUIC-LB and proxies",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/54",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Thanks for considering the implications of QUIC-LB in this draft.\r\n\r\nYour recommendation might be too draconian. Note that QUIC-LB only adds value in case of address migration. I see a few different solutions depending on use case if the proxies have to be load balanced:\r\n\r\n1. If proxy and server can coordinate, multiple tier LBs are already addressed in the quic-lb draft; clear sailing here, as you've written\r\n\r\n2. The proxy can simply send disable-migration and then use 4-tuple load balancing. Then the CID doesn't matter to the proxy. In this case the client MUST not change the destination CID in forwarded packets. If it needs to migrate, it can open a new 0RTT connection to the proxy and can even use the same inner connection.\r\n\r\nUnfortunately, this breaks migration for tunneled connections in these deployments as well.\r\n\r\n3. There could be a \"proxy-behind-lb\" response header. If present, and the client must migrate, all subsequent client packets MUST use tunneled mode until one of them is acked. The proxy LB is 4-tuple based if it has observed the 4-tuple before; otherwise, it uses the CID (i.e. it assumes the packet is tunnel mode). I suspect most Quic-LB devices will keep 4-tuple state in this manner anyway, though it isn't required.\r\n\r\nThe idea here is that the tunneled packets allow the LB to learn to associate the 4 tuple with the correct proxy, informed by the outer CID, before reverting to forwarding mode.\r\n",
      "createdAt": "2021-10-09T23:29:44Z",
      "updatedAt": "2022-10-31T20:30:47Z",
      "closedAt": "2022-10-31T20:30:47Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "#60 and #62 added virtual CID support in the proxy, which should address support for QUIC-LB. @martinduke please a file a new issue if you see more that would need to be done!",
          "createdAt": "2022-10-31T15:50:33Z",
          "updatedAt": "2022-10-31T15:50:33Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "Yes, this is a clever solution to the core issue. I will file a new issue for further complaints.",
          "createdAt": "2022-10-31T20:30:47Z",
          "updatedAt": "2022-10-31T20:30:47Z"
        }
      ]
    },
    {
      "number": 56,
      "id": "I_kwDOEHrEP85Dob8c",
      "title": "Links no longer working regarding the \"connect\" WG",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/56",
      "state": "CLOSED",
      "author": "starrify",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "(Sorry in advance for this potentially stupid ticket. :sweat_smile:)\r\n\r\nI happen to notice that these three links are not working: \r\nhttps://github.com/tfpauly/quic-proxy/blob/ad94640114f279624009dc17873953d7fde42f42/CONTRIBUTING.md?plain=1#L20-L31\r\n\r\nIt looks a little bit weird because there seems to be no working group called \"connect\" from [the current list](https://datatracker.ietf.org/wg/) and [the historical list](https://datatracker.ietf.org/group/concluded/).",
      "createdAt": "2022-02-12T21:55:37Z",
      "updatedAt": "2022-02-12T22:17:50Z",
      "closedAt": "2022-02-12T22:17:49Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Weird, I think some automated setup did that wrong! I'll fix it.",
          "createdAt": "2022-02-12T22:16:49Z",
          "updatedAt": "2022-02-12T22:16:49Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed to point to masque.",
          "createdAt": "2022-02-12T22:17:49Z",
          "updatedAt": "2022-02-12T22:17:49Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "I_kwDOEHrEP85L8SDb",
      "title": "Happy Eyeballs?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/59",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Discuss"
      ],
      "body": "CONNECT-UDP can't perform Happy Eyeballs because UDP doesn't have an equivalent of the TCP SYN-ACK. However, QUIC has such an equivalent. This extension could recommend performing Happy Eyeballs when target_host is a DNS host name.",
      "createdAt": "2022-06-16T21:21:40Z",
      "updatedAt": "2025-02-06T22:47:47Z",
      "closedAt": "2025-02-06T02:37:02Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "How would that work, the proxy duplicating the Client initial over a v4 and a v6 path? That doesn't sound good",
          "createdAt": "2022-06-16T21:44:36Z",
          "updatedAt": "2022-06-16T21:44:36Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": " Have to agree with @LPardue here. I don't see how this can work. A UDP Proxy can clearly run happy eyeball and race the quick connection between the masque client and the masque server (proxy) over IPv4 and IPv6 and in this case it would be the MASQUE used HTTP establishment that is raced. For the end-to-end connection that is being tunnelled, that require the application above the QUIC connection(s) to perform happy eyeballs. If you want to enable this, then you need to have the end-to-end application open two QUIC connection over the same proxy and race these and thus indicate a preference for IPv4 or IPv6 when doing the request for proxying. \r\n \r\n I don't believe in the proxy duplicating what it thinks is a QUIC handshake packet for the E2E quic connection and send it over both IPv4 and IPv6 for domains that have both A and AAAA DNS records. If you one would do that and then select which to use based on the response. Then first you are impacting when the response can be sent. So any attempt in this direction would need an extension and explicit signalling about it. ",
          "createdAt": "2022-06-20T09:09:52Z",
          "updatedAt": "2022-06-20T09:09:52Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, the client would need to be involved in order to run proper happy eyeballs, I think.\r\n\r\nThe proxy could certainly learn for commonly accessed targets that a particular address actually doesn't work \u2014 like if the DNS entry had IPv6 addresses, but never responded, for future requests the proxy could prefer IPv4.",
          "createdAt": "2022-06-21T16:07:05Z",
          "updatedAt": "2022-06-21T16:07:12Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Proxy heuristics seem fine but then that seems common to any type of HTTP CONNECT proxy. Is there anything special to say here? ",
          "createdAt": "2022-06-21T16:29:04Z",
          "updatedAt": "2022-06-21T16:29:04Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure there's something specific to say here, no, but David may have ideas.",
          "createdAt": "2022-06-21T16:47:32Z",
          "updatedAt": "2022-06-21T16:47:32Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "(For the sake of simplicity, I'm assuming there's only one v4 address and one v6 address below, but this generalizes)\r\n\r\nMy initial thought was to have the proxy send the INITIAL to both the v4 and v6 target addresses (staggered as in HEv2, not all at once) and then pick the first target address that replies as its target, and forward the reply to the client. If the proxy receives a reply from the other address, there are two scenarios:\r\n1. the second reply has packet number 0: this means that it came from a different target server - the proxy drops the reply and generates a fake INITIAL CONNECTION_CLOSE and sends it to the second target address to tell that server to give up\r\n2. the second reply has packet number > 0: this means that it was the same target server as the first reply - the proxy forwards the reply to the client and picks the best target address as its future target address to send to\r\n\r\nOf course we'd need something a bit more smart to handle packet loss but I think the general idea would work.\r\n\r\nIf folks think this is too complicated I'm happy to take that to an extension, but since we haven't adopted this yet I thought it might be worth thinking about since we're not delaying progress.",
          "createdAt": "2022-06-21T17:02:07Z",
          "updatedAt": "2022-06-21T17:02:07Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "My concerns stem from implications of reuse of connection IDs and tokens, e.g.\r\n\r\n> An endpoint MUST NOT reuse a connection ID when sending from more than one local address -- for example, when initiating connection migration\r\n\r\nMaybe we could make this more of explicit behaviour? E.g. the client gives a proxy multiple SCIDS to use for this and then just returns packets with the selected one",
          "createdAt": "2022-06-21T18:30:36Z",
          "updatedAt": "2022-06-21T18:30:36Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "That MUST NOT is post-handshake though. The client not allowed to switch its SCID during the handshake (except to the one the server gives it)",
          "createdAt": "2022-06-21T18:33:01Z",
          "updatedAt": "2022-06-21T18:33:01Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, but duplication of CiDS in initial across paths could still provide some form of linkability? \r\n\r\nDo clients already do this kind of happy eyeballs copying behaviour without any proxy in the mix?",
          "createdAt": "2022-06-21T18:37:02Z",
          "updatedAt": "2022-06-21T18:37:02Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "> Right, but duplication of CiDS in initial across paths could still provide some form of linkability?\r\n\r\nYou'd be linking the public IPv4 and IPv6 addresses of the proxy together. I don't think the proxy cares.\r\n\r\n> Do clients already do this kind of happy eyeballs copying behaviour without any proxy in the mix?\r\n\r\nOur client does Happy Eyeballs across protocols in the sense that it tries QUIC on the first address and if that's sad it falls back to TCP, but that's because our client only does h3. But if I were to implement a QUIC-only client today I would create two separate QUIC connections so there wouldn't be duplication of initials. You could definitely do that through the proxy, but you'd save on CPU costs and latency by doing it from the proxy with duplication. Definitely a tradeoff.",
          "createdAt": "2022-06-21T18:57:29Z",
          "updatedAt": "2022-06-21T18:57:29Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah agree it's a tradeoff. \r\n\r\nThinking aloud.\r\nIt seems like in an era of HTTPS records, happy eyeballs for QUIC could be useful for non-proxy clients. And guidance on how to close an uneeded connection seems useful. The decision whether to duplicate Initials could be part of guidance around tradeoffs. A proxy could then take that and use it. A CONNECT-UDP proxy that snoops could even employ the approach ypu outline ",
          "createdAt": "2022-06-21T19:09:33Z",
          "updatedAt": "2022-06-21T19:09:33Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed with David, OK to close",
          "createdAt": "2025-02-06T02:37:02Z",
          "updatedAt": "2025-02-06T02:37:02Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "To add context from that offline discussion here: both Tommy's and my deployment end up only using IPv6 to the target, so Happy Eyeballs isn't a pressing need for us. Since this can be added in a future document just as easily, it makes sense to punt it for now.",
          "createdAt": "2025-02-06T22:47:46Z",
          "updatedAt": "2025-02-06T22:47:46Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "I_kwDOEHrEP85RqzVn",
      "title": "Consider virtual CIDs for traffic from target to client",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/61",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "To improve CID privacy when migrating, etc, and to have more parallelism between client-to-target and target-to-client, we should look at having virtual CIDs for both directions.",
      "createdAt": "2022-09-12T16:22:10Z",
      "updatedAt": "2022-10-18T21:36:19Z",
      "closedAt": "2022-10-18T21:36:19Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "@ehaydenr ",
          "createdAt": "2022-09-12T16:22:38Z",
          "updatedAt": "2022-09-12T16:22:38Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "I_kwDOEHrEP85URc--",
      "title": "Consistency between \"forwarded\" and \"forwarding\" modes",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/63",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Ready for Text"
      ],
      "body": "",
      "createdAt": "2022-10-18T21:22:00Z",
      "updatedAt": "2022-10-19T03:23:02Z",
      "closedAt": "2022-10-19T03:23:02Z",
      "comments": []
    },
    {
      "number": 65,
      "id": "I_kwDOEHrEP85UzBmh",
      "title": "Capsules and Port Reuse",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/65",
      "state": "OPEN",
      "author": "ehaydenr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "With the introduction of capsules, a proxy receives request headers and client connection id separately. In order to reuse ports, a proxy must know the client connection id when selecting a socket so that it can properly demultiplex when receiving on that target-facing socket. We should clarify what clients and proxies should do to increase the likelihood of proxies being able to reuse target-facing ports.",
      "createdAt": "2022-10-25T15:31:06Z",
      "updatedAt": "2022-10-25T15:31:06Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 67,
      "id": "I_kwDOEHrEP85VQyVt",
      "title": "Example could use a few 1RTT packets",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/67",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [
        "ehaydenr"
      ],
      "labels": [
        "Ready for Text"
      ],
      "body": "This is a minor editorial point, but it might be worthwhile to show a few 1-RTT packets in Section 6.\r\n\r\nIn particular:\r\n\r\nbefore the REGISTER_TARGET_CID exchange, server->client packets are in forwarding mode but client->server is still funneled.\r\n\r\nafter the exchange, everything is in forwarding mode.",
      "createdAt": "2022-10-31T20:37:19Z",
      "updatedAt": "2023-03-10T19:58:36Z",
      "closedAt": "2023-03-10T19:58:36Z",
      "comments": []
    },
    {
      "number": 68,
      "id": "I_kwDOEHrEP85VQ-L2",
      "title": "CID Registration doesn't consider uncooperative servers",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/68",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [
        "ehaydenr"
      ],
      "labels": [
        "Ready for Text"
      ],
      "body": "I'm really happy with the virtual CID concept, and I think it will work well with the happy path. IIUC there is a 1-to-1 mapping of connection IDs to virtual connection IDs and vice versa. Thus the proxy has a very simple job of substituting one for the other.\r\n\r\nHowever, there are some target behaviors where migration won't work all that well:\r\n\r\n1) The target has disabled migration but the proxy allows it. When the client migrates, it wants to use a new (virtual) target connection ID but the new target connection ID might not be routed correctly.\r\n\r\n2) The target is not issuing new connection IDs. Again, the client would like to use a new target virtual CID but obviously can't use a new target CID.\r\n\r\n3) The client changes the connection ID in use, but the target doesn't observe migration (proxy IP address is the same) so it declines to use a new client connection ID (I believe this is allowed in RFC 9000). Thus proxy->client packets will use the old virtual client CID and remain linkable.\r\n\r\nHaving thought about it for a moment, the answer is probably to decouple the \"actual\" CIDs and the virtual ones. I think this means lots of different capsules.\r\n\r\nREGISTER_VIRTUAL_CLIENT_CID: adds to a pool of CIDs that the proxy can choose from. When the client changes address, the proxy MUST choose a new CID from this pool (this requirement is already sorta there because the proxy can't use the same CID on two paths).\r\n\r\nREGISTER_CLIENT_CID: As the target will not experience a migration, it's not clear to me why a client would ever send a NEW_CONNECTION_ID frame. But if it chooses to, the proxy has to know that incoming packets with that CID correspond to this stream.\r\n\r\n[Perhaps \"retire\" versions of this capsule are also necessary?]\r\n\r\nREQUEST_VIRTUAL_TARGET_CID: Regardless of whether or not the actual target CID is changing, the client needs new proxy CIDs in case the client->proxy connection migrates. This must be acked with a routable CID.\r\n\r\n[again, maybe there has to be a proxy-sent capsule that retires these? A long lived connection might need to discard old QUIC-LB CIDs if the keys have rotated, etc]\r\n\r\nUPDATE_TARGET_CID: I believe the proxy only needs one target CID at a time, which it applies to all outgoing packets in forwarding mode. The only reason the client should start using a new target CID is if the old one is being retired. This is not a migration and doesn't need probes, etc. \r\n\r\n(this Issue does not consider Multipath QUIC, which has its own set of concerns.)\r\n\r\n\r\n\r\n",
      "createdAt": "2022-10-31T21:19:01Z",
      "updatedAt": "2023-03-07T23:59:19Z",
      "closedAt": "2023-03-07T23:59:19Z",
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "I should also add that I think this decoupling has good privacy properties. In general, there will be many clients connected to the proxy with many outgoing connections to a variety of destinations. If a client migrates to a new address, and there is no change at all in the CIDs between proxy and target, that leaks very little info about what that client is connected to.",
          "createdAt": "2022-10-31T21:41:23Z",
          "updatedAt": "2022-10-31T21:41:23Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "I_kwDOEHrEP85VRCdq",
      "title": "Are there potentially no ACKs? What then?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/69",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Ready for Text"
      ],
      "body": "Forwarding mode, of course, doesn't have packet numbers for the outer connection. If there's nothing else going over the outer connection, it is therefore impractical for the proxy to send ACKs. So what are the implications for congestion control, idle timeouts, and so on?\r\n\r\nFrequent ACKs in response to QUIC packets are pretty fundamental to congestion control, timeouts, and perhaps other transport layer mechanisms, and we ought to think through the implications of fully relying on the inner connection for all of those functions.\r\n\r\n",
      "createdAt": "2022-10-31T21:36:48Z",
      "updatedAt": "2023-03-10T18:30:04Z",
      "closedAt": "2023-03-10T18:30:04Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "That's a good point, if we're exclusively using forwarding mode the outer QUIC connection could succumb to an idle timeout. It's pretty easy to avoid that by periodically sending PING frames, I'd suggest we mention this to warn implementers.",
          "createdAt": "2022-10-31T23:02:28Z",
          "updatedAt": "2022-10-31T23:02:28Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah in practice we have periodic pings to the proxy that\u2019s in forwarding mode. ",
          "createdAt": "2022-11-01T03:58:48Z",
          "updatedAt": "2022-11-01T03:58:48Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "I_kwDOEHrEP85VRE9n",
      "title": "ECN",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/70",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Ready for Text"
      ],
      "body": "In this context, it's probably worthwhile to specify the ECN behavior more precisely. ISTM the proxy should copy the ECN bits when forwarding even though the IP header is being replaced.",
      "createdAt": "2022-10-31T21:47:21Z",
      "updatedAt": "2023-03-10T18:29:51Z",
      "closedAt": "2023-03-10T18:29:51Z",
      "comments": []
    },
    {
      "number": 71,
      "id": "I_kwDOEHrEP85ViWw5",
      "title": "Contradictory guidance on when it's acceptable to send capsule",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/71",
      "state": "CLOSED",
      "author": "ehaydenr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This seems contradictory\r\n > If the client does not receive this header in responses, the client SHALL assume that the proxy\r\ndoes not understand how to parse Connection ID capsules, and MUST NOT send any\r\nConnection ID capsules.\r\n\r\nFollowed by\r\n>Note that the initial REGISTER_CLIENT_CID capsule MAY be sent prior to receiving an\r\nHTTP response from the proxy.\r\n\r\nClients wishing to send capsules along with request headers cannot do so without violating the requirement that the server responded with the Proxy-QUIC-Forwarding header. Since CONNECT-UDP implementations MUST be able to parse capsules (and ignore capsules they do not understand), I think it's safe to remove the \"MUST NOT send any Connection ID capsules\".",
      "createdAt": "2022-11-03T18:04:19Z",
      "updatedAt": "2022-11-04T16:36:27Z",
      "closedAt": "2022-11-04T16:36:27Z",
      "comments": []
    },
    {
      "number": 74,
      "id": "I_kwDOEHrEP85gIGYH",
      "title": "Feature request: CID compression",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/74",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Discuss"
      ],
      "body": "One of the features of the [original MASQUE proposal](https://www.ietf.org/archive/id/draft-schinazi-masque-protocol-03.html#name-quic-proxying) was the ability to compress QUIC connection IDs to minimize encapsulation overhead. This might no longer be necessary now that we have \"forwarded mode\", but I'm filing this issue so we discuss whether CID compression is still relevant or not. This feature would be useful for use cases that cannot accept the reduced security properties of forwarded mode, but we should discuss as a WG whether such use cases exist in real life and whether we want to support them.",
      "createdAt": "2023-03-07T05:06:03Z",
      "updatedAt": "2023-03-07T23:09:54Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 79,
      "id": "I_kwDOEHrEP85iCqKB",
      "title": "Forwarded packets are not part of the MASQUE connection",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/79",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This is editorial, but I would like the \"forwarding mode\" section to unambiguously state that the forwarding-mode packets are not part of the outer connection for any purpose (congestion control, flow control, acks, etc). This is implied by the keepalive section, but ought to be explicit.",
      "createdAt": "2023-03-29T00:56:57Z",
      "updatedAt": "2023-04-03T18:20:02Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "Priority is another thing where one might be tempted to apply connection rules.",
          "createdAt": "2023-04-03T18:20:02Z",
          "updatedAt": "2023-04-03T18:20:02Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "I_kwDOEHrEP85iCt8e",
      "title": "Padding",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/80",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Traffic analysis remains the biggest exposure with this design.  Encryption and virtual CIDs help obscure the pattern of bits, but packet size and timing are harder to defend.\r\n\r\nFor packet size, it might be useful if there was a way to pad before encryption.  However, padding will necessarily expand packets.  Also, it would help if the padding were on a per-packet basis.  As things approach MTU, the relative information they leak through size diminishes, but smaller packets can be highly identifying.\r\n\r\nPadding would be applied by the client when sending to the proxy and by the proxy when forwarding to the client.\r\n\r\nTo indicate when padding is in use I think that we should look to steal one of the public bits in the first byte of the QUIC header.  I see just a few options:\r\n\r\n1. The short/long flag (0x80).  This is available because we only ever set a value to 0.  This would violate QUIC invariants, but ...... \u00af\\\\\\_( \u0361\u00b0 \u035c\u0296 \u0361\u00b0)\\_/\u00af\r\n2. The QUIC bit (0x40).  This is available, but if we ever find another use for it this use might conflict with that use.  We wouldn't be able to negotiate the use of this bit for other purposes (including grease) unless we were willing to do two-way trial decryption.\r\n3. The spin bit (0x20).  This is basically already in use, but we might conclude that not spinning the bit is OK for this application.\r\n\r\nOnce we have that bit, we can toggle it to indicate that there is padding.  I would suggest that we pad at the end of the packet, so that we don't need to move packet contents around.  Standard padding schemes are to include a run of zeros from the last octet, with padding ending on a non-zero octet (this is the TLS padding scheme).  There are, of course, many equally-valid alternatives.\r\n",
      "createdAt": "2023-03-29T01:13:34Z",
      "updatedAt": "2024-07-18T22:16:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "In a multi-hop proxy model, probably the best thing to do for packet size correlation mitigation is to have the connection between the client and the second proxy always send QUIC SH packets of known sizes (small / medium / large fixed sizes) such that the sizes are not interesting.\r\n\r\nAt that point, I don't think it is helpful for the first proxy to add any padding.\r\n\r\nEssentially, my initial impression is that this a problem for the client-to-target (obviously assuming that the client and target can sufficiently coordinate).",
          "createdAt": "2023-03-29T07:27:27Z",
          "updatedAt": "2023-03-29T07:27:27Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "That requires client-client coordination to be effective; whereas padding by the proxy does not.  I realize that you might be less interested in that approach, but I don't see much harm in specifying it.",
          "createdAt": "2023-03-29T09:45:09Z",
          "updatedAt": "2023-03-29T09:45:09Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Related to https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/92",
          "createdAt": "2024-07-18T22:16:21Z",
          "updatedAt": "2024-07-18T22:16:21Z"
        }
      ]
    },
    {
      "number": 81,
      "id": "I_kwDOEHrEP85iCuQP",
      "title": "Congestion Control Loops",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/81",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In general, in tunneled mode there is an inner (client-target) and outer (client-proxy) congestion control loop.\r\n\r\nIn forwarding mode, there is no outer loop.\r\n\r\nIf the bottleneck(s) are between client and proxy, then the outer loop has a shorter RTT and for most congestion controls will capture more of the bottleneck bandwidth. The throughput advantage of tunneled mode could, in principle, overwhelm the overhead advantages of forwarding mode.\r\n\r\nIt would be nice to see some simulations or other data to show that this is not a problem in practice before we adopted this work.\r\n",
      "createdAt": "2023-03-29T01:15:12Z",
      "updatedAt": "2023-03-29T01:15:12Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 82,
      "id": "I_kwDOEHrEP85iwGRx",
      "title": "\"<->\" is not a word",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/82",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Ready for Text"
      ],
      "body": "It's a nice shorthand for email conversation, but maybe a little less so in a specification, where the implication might not be clear to some readers.",
      "createdAt": "2023-04-06T06:51:43Z",
      "updatedAt": "2024-07-18T22:12:41Z",
      "closedAt": "2024-07-18T22:12:41Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed by https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/111",
          "createdAt": "2024-07-18T22:12:41Z",
          "updatedAt": "2024-07-18T22:12:41Z"
        }
      ]
    },
    {
      "number": 83,
      "id": "I_kwDOEHrEP85qZnK1",
      "title": "Explain compatibility for future QUIC versions",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/83",
      "state": "OPEN",
      "author": "marten-seemann",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Ready for Text"
      ],
      "body": "The Register Target Connection ID capsule and the Virtual Connection ID capsule allow connection IDs of up to 255 bytes. This is because RFC 8999 allows up to 255 bytes, while RFC 9000 restricts them to 20 bytes.\r\n\r\nThe capsules also contain stateless reset tokens. However, stateless resets are not a concept defined in RFC 8999, they\u2019re only defined in RFC 9000.\r\n\r\nIt seems like the hope when defining this extension is that once a new QUIC version that allows longer CIDs ships, it will still contain the concept of stateless reset tokens, with unchanged semantics and wire format. This might or might not hold true.",
      "createdAt": "2023-07-03T01:13:19Z",
      "updatedAt": "2023-07-24T17:07:51Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "That's a good point, but I don't think we should make any change.\r\n\r\n- If there is a new version that has the same CID lengths and reset token behavior as v1, we're good.\r\n- If there is a new version that has longer CID length, but the same reset token behavior as v1, we're good.\r\n- If there is a new version that has no reset token support, then we can just leave those as empty, and we're still good.\r\n- If there is a new version that needs entirely different reset token semantics or format, then we define new capsule types when we get there for that version.\r\n\r\nWould you agree?",
          "createdAt": "2023-07-03T17:01:05Z",
          "updatedAt": "2023-07-03T17:01:05Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "NONE",
          "body": "I agree with your summary. Should this document specify that the extension only works with QUIC versions that satisfy (1) - (3), but not (4)?",
          "createdAt": "2023-07-04T20:06:52Z",
          "updatedAt": "2023-07-04T20:06:52Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, I think it would be good to add a line to explain that if the behavior of stateless reset changes or other requirements are added, we need new capsules.",
          "createdAt": "2023-07-05T14:12:29Z",
          "updatedAt": "2023-07-05T14:12:29Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "A few things that can be done here:\r\n- a \"Version Dependence\" section (similar to QUIC-LB) that writes down exactly what assumptions beyond 8999 you are relying on\r\n- The option for the client to specifically request version-specific services (like stateless reset) \r\n- The proxy having a \"version aware\" mode where it does version-specific stuff, and a version-independent one that provides minimum services",
          "createdAt": "2023-07-24T17:07:51Z",
          "updatedAt": "2023-07-24T17:07:51Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "I_kwDOEHrEP85qZoW_",
      "title": "recommend registering client-issued CIDs with the proxy first",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/84",
      "state": "OPEN",
      "author": "marten-seemann",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Discuss"
      ],
      "body": "When the client wishes to issue a new CID for the target, it might be advantageous to register it with the proxy first (and wait for acknowledgement), before actually sending it to the target. That way, if the proxy rejects the CID, there\u2019s no risk that the target already started using that CID, which would lead to the loss of all packets sent using that CID, until that CID is retired (which takes at least 1 RTT).",
      "createdAt": "2023-07-03T01:18:13Z",
      "updatedAt": "2025-02-13T22:22:14Z",
      "closedAt": null,
      "comments": [
        {
          "author": "marten-seemann",
          "authorAssociation": "NONE",
          "body": "Looks like I opened this issue too early (reading through the document from top to bottom).\r\n\r\nThis is already recommended in section 4.2. However, in section 4 it says:\r\n> The client sends a REGISTER_CLIENT_CID capsule whenever it advertises a new Client Connection ID to the target\r\n\r\nThis sentence could probably be reworded by replacing \u201cwhenever\u201d with \u201cbefore\u201d.",
          "createdAt": "2023-07-03T01:21:01Z",
          "updatedAt": "2023-07-03T01:21:01Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, it would be useful to clarify the ordering \u2014 saying \"before\" is good there, or at least in the same packet to the proxy so the proxy is able to read the content first before passing along a packet to the next hop.",
          "createdAt": "2023-07-03T02:22:19Z",
          "updatedAt": "2023-07-03T02:22:19Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "As a note here, this text:\n\n> If the rejection indicated a conflict due to the client CID, the client MUST select a new Connection ID before sending a new request, and generate a new packet. For example, if a client is sending a QUIC Initial packet and chooses a Connection ID that conflicts with an existing mapping to the same target server, it will need to generate a new QUIC Initial.[\u00b6](https://ietf-wg-masque.github.io/draft-ietf-masque-quic-proxy/draft-ietf-masque-quic-proxy.html#section-4.9.1-5)\n\nExplains that a client needs to resend the initial, but doesn't describe how the proxy drops this initial, or how it knows which packets to allow/drop.",
          "createdAt": "2025-02-13T22:19:07Z",
          "updatedAt": "2025-02-13T22:19:07Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Option:\n- If the proxy sends a close client CID capsule, it will drop all packets sent by the client until the proxy sends an acknowledgement of a new client CID. This regresses us into a slower case when we have a conflict. The client can be told to only send the initial flight before getting the ack or close, and to then not send anything more until it gets an ack.",
          "createdAt": "2025-02-13T22:22:12Z",
          "updatedAt": "2025-02-13T22:22:12Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "I_kwDOEHrEP85saQ-F",
      "title": "Consider security issues of ECN forwarding",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/85",
      "state": "OPEN",
      "author": "enygren",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As we do work to decouple the potential risks on correlation between the incoming/outgoing connections, the forwarding of ECN has potential risk.  An active attacker could embed signals over a series of packets by clearing+setting ECN bits and observing the same signal on the output side. \r\n\r\nThe end-to-end QUIC congestion control makes it so we really do want to forward ECN, so it's unclear what can be done about this risk in a way that also allows ECN to be applied on any of the hops. \r\n\r\nThis might be something to just capture as a known potential risk and downside for this use-case.",
      "createdAt": "2023-07-24T17:20:07Z",
      "updatedAt": "2023-07-24T17:20:07Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 86,
      "id": "I_kwDOEHrEP85saTM2",
      "title": "Recommendations for Address Migration",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/86",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The best practice when clients migrate is not immediately obvious.\r\n\r\nAs the proxy's source IP does not change, changing the connection ID is not strictly necessary between proxy and target.\r\n\r\nIf a client migrates, clearly the virtual connection ID should change, to avoid linkability along the client/proxy path. But it's not totally clear to me if the \"real\" connection IDs should change.\r\n\r\nIf the connection IDs do not change, and an attacker is otherwise able to correlate client-proxy flows with proxy-target flows, then that makes things linkable.\r\n\r\nHowever, changing the connection ID means short header packets start with a new connection ID, which is the signature of a migrating connection. This could actually allow an observer to correlate a client-proxy flow with a proxy-target flow.\r\n\r\nI don't have a solution but I'm happy to help think through the tradeoffs here.",
      "createdAt": "2023-07-24T17:25:52Z",
      "updatedAt": "2024-07-19T00:10:10Z",
      "closedAt": null,
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "Maybe we should consider that as part of supporting multiple paths between the client and the target. I think that if the clients want some privacy with multiple paths, they will use a different proxy for each path, thus \"the same proxy\" should be considered a degenerate case. So maybe establish a separate CONNECT-UDP context for each of the paths, and treat the new path as a new connection: register the connection ID for the path, etc.",
          "createdAt": "2024-07-14T20:43:28Z",
          "updatedAt": "2024-07-14T20:43:28Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "I have been looking at how to combine Masque and QUIC Multipath. I think the cleanest architecture is to map each QUIC path to a separate a CONNECT UDP context, defined by the IP Address and Port used by the proxy, and the IP Address and Path used by the target. But the client can only specify the target address in the CONNECT UDP request. So, today, the only way the client can create independent paths is to associate each QUIC path to a different proxy.\r\n\r\nIf the proxy is multi-homed, the client may be able to open several Masque connections to the different proxy addresses, knowing that the outgoing UDP packets will be source by that address.",
          "createdAt": "2024-07-19T00:09:38Z",
          "updatedAt": "2024-07-19T00:10:10Z"
        }
      ]
    },
    {
      "number": 88,
      "id": "I_kwDOEHrEP850sOlJ",
      "title": "Infinite Loops with Client Virtual Connection IDs",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/88",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Discuss"
      ],
      "body": "As described in thread that begins in https://mailarchive.ietf.org/arch/msg/masque/y4M_VX7-dMvOqkhKoHCtKUgnomA/\r\n\r\nI believe the possible mitigations are:\r\n- Have the server pick the virtual client connection ID\r\n- Require the proxy to open a new target-facing UDP socket for each connection request\r\n- Not do virtual client connection IDs at all",
      "createdAt": "2023-10-23T18:19:38Z",
      "updatedAt": "2024-07-08T02:45:55Z",
      "closedAt": "2024-07-08T02:45:54Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Or require that if servers share a VIP, they need to coordinate on their VCID mappings? That seems to be a simple requirement.\r\n\r\nI don't think removing VCIDs or allowing servers to select the CIDs that clients advertise to targets is feasible.",
          "createdAt": "2023-10-23T19:05:46Z",
          "updatedAt": "2023-10-23T19:05:46Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "> Or require that if servers share a VIP, they need to coordinate on their VCID mappings? That seems to be a simple requirement.\r\n\r\nIt sounds very expensive to globally share all of the VCIDs that clients have chosen!\r\n\r\n> \r\n> I don't think removing VCIDs or allowing servers to select the CIDs that clients advertise to targets is feasible.\r\n\r\nWhy? The client sends REGISTER_CLIENT_CID to the proxy, but without including a virtual. The client can't start sending packets with that CID because the proxy hasn't confirmed that there is no collision at its target-facing socket. The ACK_CLIENT_CID could contain the Virtual client CID the proxy wants the client to use.\r\n\r\nThis is, IIUC, exactly how target CIDs work.\r\n\r\n",
          "createdAt": "2023-10-23T19:10:45Z",
          "updatedAt": "2023-10-23T19:10:45Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it's OK if we wanted the VCID to be determined by the proxy \u2014 I was saying that it's not OK for the actual client CID to be determined by the proxy.\r\n\r\nIf we just have the VCID be determined by the proxy, does that sufficiently solve the issue? If so, that's probably the best outcome.",
          "createdAt": "2023-10-23T19:52:20Z",
          "updatedAt": "2023-10-23T19:52:20Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "I think the spec currently has the client picking the actual CID (subject to rejection by the proxy due to a collision)? I don't yet see an attack if the client picks with proxy approval.\r\n\r\nI agree that the more CIDs the proxy picks, the less it's open to this sort of attack. On the other hand, I've been playing a bit with similar attacks in a forward direction, and haven't gotten them to work. It also would be nicely symmetric if the client picked both target-facing CIDs and the proxy picked both CIDs on the proxy-client hop (i.e. REGISTER_*_CID and ACK_*_CID had the same format for * = {CLIENT, TARGET}).\r\n\r\nBut to answer your question, yes, that would solve this particular attack.",
          "createdAt": "2023-10-23T20:00:16Z",
          "updatedAt": "2023-10-23T20:00:16Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "If the proxy picks the virtual CID, it also MUST NOT just reuse the client-provided one, because of this vulnerability.\r\n\r\nThe same goes for target connection IDs: I can easily recreate this attack in the forward direction if the proxy just reuses the target CID for the virtual. In fact, if the relationship between CID and Virtual CIDs is **predictable**, I can do a forward direction infinite loop with a colluding target.\r\n\r\nBut I guess that's already good advice if we're trying to prevent linkabilty between target-side and client-side.",
          "createdAt": "2023-10-23T20:32:05Z",
          "updatedAt": "2023-10-23T20:32:05Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Should be fixed with #104 ",
          "createdAt": "2024-07-08T02:45:54Z",
          "updatedAt": "2024-07-08T02:45:54Z"
        }
      ]
    },
    {
      "number": 91,
      "id": "I_kwDOEHrEP8514gWQ",
      "title": "No way of disabling forwarding mode half way through stream",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/91",
      "state": "OPEN",
      "author": "ehaydenr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ehaydenr"
      ],
      "labels": [],
      "body": "Connection ID registration capsules allow the client to communicate client and target connection IDs to the proxy. This enables both port reuse on the proxy and the option to use forwarding mode.\r\n\r\nWhen the head `Proxy-QUIC-Forwarding=?1` was mutually communicated, the client **may** send in forwarding mode, but **must** be able to receive in forwarding mode. As a client, if \"mid stream\" I decide a don't want to do forwarding anymore, I don't have a way to communicate this to the proxy. CloseClientCid/CloseTargetCid capsules don't work here because that would break the proxy's ability to distinguish QUIC packets on a reused UDP port.",
      "createdAt": "2023-11-05T11:29:30Z",
      "updatedAt": "2025-02-17T16:55:14Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Do you have a use case where this might be useful? (I'm not against this feature, just curious what it's for)",
          "createdAt": "2023-11-05T12:24:29Z",
          "updatedAt": "2023-11-05T12:24:29Z"
        },
        {
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "body": "The concept of disabling forwarding mode mid-stream was brought up recently in an encryption design team meeting where the proxy may choose to disable forwarding mode when it thinks there may be an active attacker on the client-proxy path. I can't think of a case where the client would wish to stop forwarding mode mid-stream (the scenario I described above). Perhaps there's no reason for the client to tell the proxy to stop forwarding, but, if we do make it possible for the proxy to tell the client to stop sending forwarded mode packets, it may or may not make sense to make that symmetrical.",
          "createdAt": "2023-11-05T14:26:54Z",
          "updatedAt": "2023-11-05T14:26:54Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "That makes sense, thanks",
          "createdAt": "2023-11-05T14:45:15Z",
          "updatedAt": "2023-11-05T14:45:15Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "One option here is to migrate the end-to-end QUIC connection to a new MASQUE request stream that doesn't allow forwarding",
          "createdAt": "2025-02-13T22:30:28Z",
          "updatedAt": "2025-02-13T22:30:28Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "That's definitely a workable solution. And unless we have a use case that someone's shipping where that solution isn't good enough, maybe we resolve this by adding text to recommend this?",
          "createdAt": "2025-02-15T02:07:00Z",
          "updatedAt": "2025-02-15T02:07:00Z"
        },
        {
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "body": "That works for me!",
          "createdAt": "2025-02-17T16:55:08Z",
          "updatedAt": "2025-02-17T16:55:08Z"
        }
      ]
    },
    {
      "number": 92,
      "id": "I_kwDOEHrEP8547y-C",
      "title": "Add packet transform that allows adding padding",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/92",
      "state": "OPEN",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Future work"
      ],
      "body": "In addition to scramble, we should define a \"scramble-padded\" variant. This would be the same crypto as scramble but could either:\r\n- Always add a one byte at the end that describes the length of padded bytes at the end\r\n- Optionally add one byte at the end that describes padded length, which must be preceded by at least N (4?) bytes of zero",
      "createdAt": "2023-12-06T16:28:38Z",
      "updatedAt": "2024-03-13T20:39:46Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After thinking about this for a bit, I'm not convinced that this is a good idea.\r\n\r\nLet's consider a few possible passive attackers:\r\n\r\n1. Double-sided attacks on Connection ID mapping.  The attacker sees all traffic into and out of the proxy, and is attempting to identify which Virtual CIDs correspond to which real CIDs.\r\n1a. Attacker must present a small number of packets that provide absolute proof of a given VCID-CID pair.\r\n1b. Attacker can collect and analyze an unbounded amount of traffic to generate strong evidence/suspicion of a mapping.\r\n2. Single-sided attacks on content identity.  The attacker is attempting to identify packet transmission patterns indicative of using a particular service or downloading particular content.\r\n2a. Attacker on the client-proxy link.\r\n2b. Attacker on the proxy-target link.\r\n\r\nThe \"scramble\" transform is design to defeat threat model 1a.  We don't need padding in this threat model.\r\n\r\nThe \"scramble-padding\" transform would not be sufficient to address threat 1b.  It is still a \"packet for packet\" proxy, so the attacker can use the timing of individual packets and the large-scale patterns in traffic flows to identify CID mappings.  Note that per-packet padding is much less effective here than in DNS (RFC 8467), because QUIC packets form long-term flows that are visible on both sides from their fixed CIDs.  Padding in this way would also be less efficient than padding with ordinary \"connect-udp\", for two reasons:\r\n\r\n1. \"connect-udp\" does not reveal the distinct flows on the client-proxy link.\r\n2. \"connect-udp\" permits packet aggregation and splitting, obscuring the precise number of packets sent and allowing padding to be amortized across a flight of packets.\r\n\r\nGiven that QUIC Forwarding Mode is motivated (at least in part) by a desire to reduce the space overhead of \"connect-udp\", it seems paradoxical to define a mode that would require _more_ overhead to reach the desired privacy level.\r\n\r\nA \"scramble-padding\" mode could be targeted at threat 2a.  However, this mode competes with the alternative of applying end-to-end padding on the client-target connection.  In that comparison, \"scramble-padding\" has several deficiencies:\r\n\r\n* It does not defend against attacker 2b.  More generally, it is dependent on use of the proxy.\r\n* The proxy does not know anything about the content, such as its privacy relevance or its delay sensitivity, so it cannot select a sensible padding policy.  The client would need a new protocol for communicating this kind of policy information to the proxy.\r\n* As above, it is less efficient than end-to-end padding due to the inability to coalesce packets.\r\n\r\nI do think these threat models are worth addressing, but I suspect that the right solutions do not involve QUIC Forwarding Mode.  Threat 1b will require a deeper design that hides short-term correlation and also breaks long-term flow linkability.  Threat 2a/2b is best addressed by improving support for end-to-end padding in QUIC.",
          "createdAt": "2024-01-03T16:55:39Z",
          "updatedAt": "2024-01-03T16:58:54Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think \"just use regular CONNECT-UDP / tunneled mode\" is a great answer here: when we have multiple nested CONNECT-UDP tunnels, that padding would be on the client-proxyA , client-proxyB, client-proxyC, etc connections, as opposed to client-proxyA, proxyA-proxyB, proxyB-proxyC. That means that you'd increase padding the closer you get to the client. A forwarding mode transform with padding would allow hop-by-hop padding, and I think that has value.",
          "createdAt": "2024-01-05T10:35:58Z",
          "updatedAt": "2024-01-05T10:35:58Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No, forwarding mode transforms are client to proxy, and proxy A is not the client to proxy B -- it's just a transport proxy.  Proxy A doesn't even know that Proxy B _is_ a proxy.\r\n\r\nI don't think hop-by-hop padding is desirable, because it conflicts with the privacy goal of limiting the damage that each proxy can do.  It seems more logical to pad once, at the innermost possible layer.",
          "createdAt": "2024-01-05T20:54:34Z",
          "updatedAt": "2024-01-05T20:54:34Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "If the goal is to decorrelate traffic on both sides of a proxy, independent hop-by-hop padding will be much more effective than only innermost padding",
          "createdAt": "2024-01-05T21:19:29Z",
          "updatedAt": "2024-01-05T21:19:29Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It sounds like you're describing threat model 1b (defined above).  That attacker is essentially too powerful for a padding packet transform to do any good.  We will need a different approach.",
          "createdAt": "2024-01-05T21:35:43Z",
          "updatedAt": "2024-01-05T21:35:43Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "The dichotomy above between 1a and 1b lacks nuance. There is value in reducing the amount of signal that an attacker has. The attacker I have in mind can see traffic on both sides of the proxy but only has the ability to save limited amounts of data. When the cost of building a solution that supports padding is low, I'd rather build a solution without necessarily using it, rather than needing it and not having it. This is an instance where \"we'll build it when we need it\" means that receivers won't support receiving the padding.",
          "createdAt": "2024-01-05T21:42:15Z",
          "updatedAt": "2024-01-05T21:42:15Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "An attacker just has to store the sequence (not even timestamps!) of CIDs and VCIDs crossing the proxy.  With any reasonable compression scheme this will be less than 4 bytes per packet.  I think an attacker will be able to deanonymize most flows long before they hit any practical storage limit.\r\n\r\nPacket transforms are negotiated explicitly, so defining it early doesn't especially increase the likelihood that it will be broadly supported or used.",
          "createdAt": "2024-01-05T22:12:41Z",
          "updatedAt": "2024-01-05T22:12:41Z"
        }
      ]
    },
    {
      "number": 93,
      "id": "I_kwDOEHrEP85473Hq",
      "title": "Add security considerations for packet transforms",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/93",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ehaydenr"
      ],
      "labels": [
        "Design team"
      ],
      "body": "",
      "createdAt": "2023-12-06T16:36:28Z",
      "updatedAt": "2024-03-13T20:39:10Z",
      "closedAt": "2024-03-13T20:39:10Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "@ehaydenr will take a first stab at adding this in",
          "createdAt": "2023-12-06T16:39:43Z",
          "updatedAt": "2023-12-06T16:39:43Z"
        }
      ]
    },
    {
      "number": 94,
      "id": "I_kwDOEHrEP85473bw",
      "title": "Fill out IANA registry creation for packet transforms",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/94",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mirjak"
      ],
      "labels": [
        "Design team"
      ],
      "body": "",
      "createdAt": "2023-12-06T16:37:11Z",
      "updatedAt": "2024-01-03T16:12:31Z",
      "closedAt": "2024-01-03T16:12:31Z",
      "comments": [
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can give it a try",
          "createdAt": "2023-12-06T16:42:19Z",
          "updatedAt": "2023-12-06T16:42:19Z"
        }
      ]
    },
    {
      "number": 96,
      "id": "I_kwDOEHrEP857CsKf",
      "title": "Use \"scramble-draft-XX\" transform names during experimentation?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/96",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Design team"
      ],
      "body": "To allow for early deployments of transforms (like \"scramble\") we could have deployments use a draft version of the name, since the crypto could change before being finalized.",
      "createdAt": "2024-01-03T16:18:54Z",
      "updatedAt": "2024-03-13T20:39:03Z",
      "closedAt": "2024-03-13T20:39:03Z",
      "comments": []
    },
    {
      "number": 100,
      "id": "I_kwDOEHrEP859QohH",
      "title": "No protection against packet modification",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/100",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Design team"
      ],
      "body": "scramble doesn't prevent an attacker from flipping bits as there is no extra authentication tag.  In a protocol like QUIC, I think that this is probably OK.\r\n\r\nIn other similar systems, a damaged packet might cause significant side effects, like session teardown.  In QUIC, that packet is simply dropped.\r\n\r\nHowever, if the attacker is aware that the packet would ordinarily cause an observable activity at its destination and it doesn't otherwise have connection ID mappings, then it can use that damage to help correlate packets across a proxy (this is just a variation on the burst thing in the pull request already).\r\n\r\nMight be worth pointing out.  Because this does not work if you don't have strong integrity protection at the QUIC layer.",
      "createdAt": "2024-01-26T03:17:43Z",
      "updatedAt": "2024-03-17T02:43:46Z",
      "closedAt": "2024-03-17T02:43:46Z",
      "comments": [
        {
          "author": "afressancourt",
          "authorAssociation": "NONE",
          "body": "Hello,\r\n\r\nI agree that, in the absence of an authentication tag, there is a possibility that an attacker uses a packet manipulation to track the packet. \r\n\r\nOne question we need to ask ourselves is whether we want the packet's integrity to be checked at every single hop or end to end. Verifying the integrity end to end does not prevent an attack in which the attacker controls the destination and want to know where the packet is coming from by introducing a bit manipulation at a given proxy or on a given link. \r\n\r\nChecking the packet's integrity at every hop would prevent this attack from happening, but then the question is who is responsible for writing the authentication tag checked at a given proxy: is it the source? the proxy before?",
          "createdAt": "2024-01-29T09:06:26Z",
          "updatedAt": "2024-01-29T09:06:26Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Actually we discussed this attack but as it seems did not add text to the security consideration. I think we should add it.",
          "createdAt": "2024-01-29T17:45:27Z",
          "updatedAt": "2024-01-29T17:45:27Z"
        }
      ]
    },
    {
      "number": 101,
      "id": "I_kwDOEHrEP859QqMf",
      "title": "Rename null transform to identity transform?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/101",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Design team"
      ],
      "body": "$f(X) \\mapsto X$ is the identity function if $\\forall x\\in X, f(x) = x$.  I think that is what you want.",
      "createdAt": "2024-01-26T03:21:41Z",
      "updatedAt": "2024-03-17T02:43:36Z",
      "closedAt": "2024-03-17T02:43:36Z",
      "comments": []
    },
    {
      "number": 103,
      "id": "I_kwDOEHrEP85_V6QP",
      "title": "Virtual connection IDs in multi-hop settings",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/103",
      "state": "OPEN",
      "author": "kelmenhorst",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "From my understanding, there is additional overhead at connection setup when using QUIC-aware in a _multi-hop setting_. \r\nLet's assume a simple multi-hop proxy setup with P1 and P2 where both proxies should do QUIC-forward: \r\n`Client -- P1 -- P2 -- Target`.\r\n\r\nDue to the proxy choosing the virtual target CID, the client needs to\r\n* setup a MASQUE connection to reach the target and learn its chosen CID,\r\n* tell P2 about the target's CID via REGISTER_TARGET_CID, \r\n* learn P2's virtual target CID from ACK_TARGET_CID,\r\n* tell P1 about P2's virtual target CID via REGISTER_TARGET_CID (so that: virtual target CID of P2 == real target CID of P1) ,\r\n* learn P1's virtual target CID from ACK_TARGET_CID,\r\n\r\nin order to finally start forward mode on the uplink. Crucially, the above steps have to be done sequentially.\r\nYou can see that this overhead increases with each added proxy.\r\n\r\nIn the target to client direction, the problem does not exist because the client chooses the virtual client CID. The client still needs to make sure that for each set of adjacent proxies P(n) and P(n+1), where P(n+1) is closer to the target, it must hold that the virtual client CID of P(n+1) is equal to the real client CID of P(n).\r\n\r\nI made a sketch about what I think the setup of virtual CIDs looks like: [cids-multi-hop.pdf](https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/files/14296870/cids-multi-hop.pdf). \r\n\r\nI don't have a solution for this and I don't know if one is needed but I think it should probably at least be mentioned in the draft if the mechanism to select/communicate virtual CIDs stays as it is now.",
      "createdAt": "2024-02-15T12:53:09Z",
      "updatedAt": "2024-02-29T18:14:51Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Is your concern performance? At the start of the connection, tunneled mode can be used while this setup is happening, so it shouldn't introduce any delay. That said, you're right that we should mention this in the draft and mention that using tunneled can help avoid delays.",
          "createdAt": "2024-02-16T21:48:46Z",
          "updatedAt": "2024-02-16T21:48:46Z"
        },
        {
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm working with @kelmenhorst on this. We were also thinking if there is an easy way to improve this, e.g. by having the client pick both sides of the virtual CIDs. However, that would be problematic for load-balancing. Still, in any case, as you say @DavidSchinazi, it would probably helpful to discuss this in the draft as it needs to be considered during implementation and it wasn't obvious when we started. ",
          "createdAt": "2024-02-29T14:54:30Z",
          "updatedAt": "2024-02-29T14:54:30Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Letting the client pick both is tricky because it violates the general QUIC mindset of having the receiver pick its own CIDs. See the related discussion in #104.",
          "createdAt": "2024-02-29T18:14:49Z",
          "updatedAt": "2024-02-29T18:14:49Z"
        }
      ]
    },
    {
      "number": 108,
      "id": "I_kwDOEHrEP86Jlj6w",
      "title": "loop detection using Bloom filters",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/108",
      "state": "OPEN",
      "author": "marten-seemann",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This might be a crazy idea: Loop detection could be implemented using a Bloom filter.\r\n\r\nOver a certain period of time, the proxy would insert every packet it forwards into a bloom filter. How big would this filter need to be? Let's say you want to insert all packets seen within a time frame of 5s at a speed of 10 Gbps (assuming an MTU of ~1400). At a false positive rate of 1e-6 (rejecting 1 packet in a million), you'd need ~120 MB: https://hur.st/bloomfilter/?n=35M&p=1.0E-6&m=&k=. \r\n\r\nThis would allow the proxy to detect all loops with an RTT of less than 5s. This period can be extended by either enlarging the size of the bloom filter, or by keeping the N most recent bloom filters around.\r\n\r\nProxies could also get a bit more advanced in their detection logic. For example, they could decide to only drop duplicate packets once the rate of duplicates surpasses a certain threshold (there's no harm in forwarding a few looped packets, as long as the volume is low enough).\r\n\r\n",
      "createdAt": "2024-05-21T13:32:16Z",
      "updatedAt": "2024-05-28T17:00:31Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "Interesting idea!\r\n\r\nBut doesn't the packet transform make it hard to detect duplicate packets?",
          "createdAt": "2024-05-28T17:00:30Z",
          "updatedAt": "2024-05-28T17:00:30Z"
        }
      ]
    },
    {
      "number": 109,
      "id": "I_kwDOEHrEP86L3UUn",
      "title": "guidance for proxies to limit the number of concurrently registered CIDs",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/109",
      "state": "CLOSED",
      "author": "ehaydenr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ehaydenr"
      ],
      "labels": [
        "Discuss"
      ],
      "body": "A client can send many bogus REGISTER_TARGET_CID/REGISTER_CLIENT_CID capsules. A proxy has to maintain the forwarding / port demultiplexing rules for each of the registered CIDs it acknowledges. Should proxies signal some limit? Or should they merely CLOSE_CLENT_CID/CLOSE_TARGET_CID when the limit is exceeded?",
      "createdAt": "2024-06-11T14:06:19Z",
      "updatedAt": "2024-10-19T03:07:19Z",
      "closedAt": "2024-10-19T03:07:19Z",
      "comments": [
        {
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed at IETF 120. Favorable towards a credit based system. Multiple people suggested reusing QUIC's connection ID issuing/retiring strategy but with capsules.",
          "createdAt": "2024-07-23T23:17:23Z",
          "updatedAt": "2024-07-23T23:17:23Z"
        }
      ]
    },
    {
      "number": 112,
      "id": "I_kwDOEHrEP86Oau1f",
      "title": "Require client VCID length to be at least as long as real client CID length?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/112",
      "state": "CLOSED",
      "author": "ehaydenr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ehaydenr"
      ],
      "labels": [
        "Discuss"
      ],
      "body": ">To reduce the likelihood of connection ID conflicts, the proxy SHOULD choose a\r\nVirtual Client Connection ID that is at least as long as the Client Connection\r\n\r\nThis prevents clients from doing uniform CID comparison and potentially increases the likelihood of conflicts. Context [here](https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/104#issuecomment-1971686813) and [here](https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/104#issuecomment-2094505252)\r\n\r\nTo address this, we can change this SHOULD to a MUST",
      "createdAt": "2024-07-03T20:04:11Z",
      "updatedAt": "2024-10-02T18:36:26Z",
      "closedAt": "2024-10-02T18:36:26Z",
      "comments": [
        {
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "body": "This was discussed at 120. No objections to making a MUST.",
          "createdAt": "2024-07-29T19:22:46Z",
          "updatedAt": "2024-07-29T19:22:46Z"
        }
      ]
    },
    {
      "number": 113,
      "id": "I_kwDOEHrEP86PgMT4",
      "title": "How to handle preferred address migration?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/113",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Ready for Text"
      ],
      "body": "I am wondering what is supposed to happen if the server sends a \"preferred address\" parameter. My understanding of the draft is that all packets produced by the client are sent to the IP address and port specified in the CONNECT-UDP request. It follows that if the client wants to heed the \"preferred address\" parameter, it should set up a new proxy connection for that. Is that a correct understanding? Should we explain that in the draft?",
      "createdAt": "2024-07-14T20:11:39Z",
      "updatedAt": "2024-11-03T13:21:38Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "@huitema do you mean if the _proxy_ server sends a preferred address parameter, or the _target_ server sends a preferred address parameter?\r\n\r\nIf the proxy sends that, then the client should move to use that for all of its proxying, and the flows just go there. The \"client-to-proxy 5-tuple\" moves.\r\n\r\nIf the target sends that, then it's more about moving the \"proxy-to-target 5-tuple\". The proxy wouldn't know what new preferred address is, so the client would need signal the proxy.\r\n\r\nThis could either be done as an entirely new connect-udp proxy request, or as a new capsule to the proxy.",
          "createdAt": "2024-07-18T21:57:37Z",
          "updatedAt": "2024-07-18T21:57:37Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "See also https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/86",
          "createdAt": "2024-07-18T22:20:35Z",
          "updatedAt": "2024-07-18T22:20:35Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "Preferred address migration is pretty much the only example of migrating to a different *server* address. There is an interesting interaction with the multipath extension, which suggests that preferred address migration be treated as a migration event. \r\n\r\nI think that the only way to signal a server address is by sending another CONNECT_UDP command, with a different \"path\" value. Maybe we should explain that in the draft.\r\n",
          "createdAt": "2024-07-18T23:59:30Z",
          "updatedAt": "2024-07-18T23:59:30Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "So shouldn't the server preferred address for the QUIC connection and its migration happen prior to processing the CONNECT_UDP request? I only see it working to process it early if the one responding have full control and can control both the preferred address and its external side address(es). As a server if you are migrating you need to have that in mind before you process quic aware proxying capsules as they would need to apply to both original and migrated address if you process them prior to the migration have happened. ",
          "createdAt": "2024-07-19T08:15:58Z",
          "updatedAt": "2024-07-19T08:15:58Z"
        },
        {
          "author": "ihlar",
          "authorAssociation": "NONE",
          "body": "> I think that the only way to signal a server address is by sending another CONNECT_UDP command, with a different \"path\" value. Maybe we should explain that in the draft.\r\n\r\nAgree, when migrating to new target server address the most straight forward solution would be to simply make a new connect-request. I don't think we need to do any protocol changes for this case, e.g., defining new capsules, but describing the scenario is a good idea. ",
          "createdAt": "2024-07-19T08:34:40Z",
          "updatedAt": "2024-07-19T08:34:40Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Using a different CONNECT-UDP request is definitely the simplest option. The issue is that the second CONNECT-UDP request could land on a different proxy from the first (especially in the presence of intermediaries), so you could end up reaching the preferred address from a proxy that can't reach it. Not sure if that's something worth worrying about though. Same for the performance cost of bringing up a whole new CONNECT-UDP context. I suspect using a second CONNECT-UDP request is good enough for now, and if these problems do happen in practice, then we'll have a reason to solve them.",
          "createdAt": "2024-07-19T17:17:55Z",
          "updatedAt": "2024-07-19T17:17:55Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "Yes, I thought about that extra complexity of multiple paths either from the client or from the proxy. The client can certainly connect to several proxies, and have different paths routed through different proxies -- that would get you some independent end-to-end paths. But in the case of the \"multihomed proxy\", the client currently does not control the source IP of the packets sent to the target. We would need a mechanism for the proxy to provide a list of available addresses, and an extension to the \"path\" parameter to indicate the preferred source address.",
          "createdAt": "2024-07-19T19:17:35Z",
          "updatedAt": "2024-07-19T19:17:35Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "To answer the question about timing from @gloinul : it is probably best to not tie the internal state of the QUIC path and the state of the QUIC-Connect context. The timing should be something like:\r\n\r\n* QUIC connection is requested to open a new path with specific target address,\r\n* new UDP Connect is requested, specifying new address.\r\n* UDP connect is accepted\r\n* Packet containing Path Challenge is sent to the proxy using the new context\r\n* Proxy forwards the Path Challenge to the target\r\n* Target replies with Path Response\r\n* Target packet recognizes the source IP and source port of the path response, associate the response with the UDP Connect context.\r\n* Proxy send the Path Response to the client per UDP context.\r\n* Client sets target context for the selected CID.\r\n\r\nThe client does not really know which CID the proxy will pick for the response, so it cannot create a context before receiving the path response, so the proxy shall be able to find the Connect UDP context based on addresses.",
          "createdAt": "2024-07-19T23:49:14Z",
          "updatedAt": "2024-07-19T23:49:14Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "Yes, one will have to run the path challenge at least in tunneled mode. After that one can optimize the forwarding when the CIDs for the E2E path is properly known. ",
          "createdAt": "2024-07-20T18:38:34Z",
          "updatedAt": "2024-07-20T18:38:34Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "At 120 we said that we should just do a new connect-udp request, and have some text that describes the case. The one case that could be suboptimal is that the client might not know which address was used originally, so if the preferred address is the same as the original, the client might unnecessarily make a new proxy connection (unless if gets a proxy-status header back to tell what the next hop is). This can be described. ",
          "createdAt": "2024-11-03T13:21:30Z",
          "updatedAt": "2024-11-03T13:21:30Z"
        }
      ]
    },
    {
      "number": 114,
      "id": "I_kwDOEHrEP86PgMpg",
      "title": "How many CONNECT UDP requests per QUIC connection?",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/114",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Do we request that a client establishes a new QUIC/H3 connection to the proxy for each target, or is it OK to simply create multiple proxy connections by sending multiple CONNECT-UDP requests on the same connection? ",
      "createdAt": "2024-07-14T20:15:59Z",
      "updatedAt": "2024-07-18T21:52:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "body": "It is OK to create multiple connect-udp requests on the same connection",
          "createdAt": "2024-07-15T15:02:02Z",
          "updatedAt": "2024-07-15T15:02:02Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "Maybe say so somewhere in the draft?",
          "createdAt": "2024-07-15T21:00:02Z",
          "updatedAt": "2024-07-15T21:00:02Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "There's no such language for vanilla CONNECT UDP, what does this document change?",
          "createdAt": "2024-07-15T21:05:10Z",
          "updatedAt": "2024-07-15T21:05:10Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "I am looking at management issues, and \"how many connections can a client establish through the proxy\" is indeed a problem. Resource is not infinite. What is the proxy to do when there are too many Connect UDP contexts open?\r\n\r\nYes, there should be something like that in Connect UDP. But there isn't.",
          "createdAt": "2024-07-15T23:38:05Z",
          "updatedAt": "2024-07-15T23:38:05Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Why should there be something in connect-udp? The issue of limiting the number of requests per connection is general to HTTP and in no way specific to connect-udp or to this extension. Servers can use flow control stream limits to choose exactly how many requests they want to allow.",
          "createdAt": "2024-07-15T23:40:18Z",
          "updatedAt": "2024-07-15T23:40:18Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed",
          "createdAt": "2024-07-15T23:44:12Z",
          "updatedAt": "2024-07-15T23:44:12Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the same question of limits would apply to normal CONNECT/CONNECT-TCP in general. While something might be worth saying here, I don't think it's in this document alone?",
          "createdAt": "2024-07-18T21:52:07Z",
          "updatedAt": "2024-07-18T21:52:07Z"
        }
      ]
    },
    {
      "number": 115,
      "id": "I_kwDOEHrEP86XV-1h",
      "title": "Active attack on IV for SCRAMBLE transform",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/115",
      "state": "OPEN",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "An attacker that has access and capability to modify packets part of an end-to-end QUIC connection prior to QUIC aware forwarding with SCRAMBLE transform can enable defeating the scramble transform. This is done by manipulating the part of the QUIC packet that will be used as IV. The attack modify some packets prior to reaching either the MASQUE client or the MASQUE proxy so this set of packets all have the same bit-value in the parts that will be used as IV. This will result in the E2E packet will be dropped at arrival at the endpoint. \r\n\r\nBy setting the same IV two effects will be achieved:\r\n1) The scrambled IV after AES-ECB application will have the same value in all the packets, enabling an attacker that captures all packets after the Masque tunnel ingress's forwarding and transformation to look for the packet with the same but unknown bit-pattern in a given location within the packet\r\n2) Due to the use of the same IV in AES-CTR mode between the multiple packet that actual scrambling can be defeated. Although I think this in most cases would have limited value as it would only allow recovering the End-to-End packet that this attacker already have access to. I think 1) is sufficient to enable the important linking of input and output 5-tuples and CIDs. \r\n\r\nThe weakness here is that the attacker can chose the IV, which is not true in the QUIC header protection application of using part of the packet as IV. But, in this case the MASQUE proxy or client can't verify the end-to-end forwarded packets integrity before choosing to use it as IV. \r\n\r\nI don't know if this attack is serious enough for scramble to change its solution, but at a minimal the potential attack and the weakness it creates needs to be documented. But likely a bit of thought should be put into if another solution can be found to avoid this attack.  ",
      "createdAt": "2024-09-20T15:41:37Z",
      "updatedAt": "2024-09-20T15:41:37Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 116,
      "id": "I_kwDOEHrEP86XWKbh",
      "title": "Don't use the term ECB \ud83d\ude31",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/116",
      "state": "OPEN",
      "author": "emanjon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://csrc.nist.gov/News/2022/proposal-to-revise-sp-800-38a\r\n\r\nThat RFC 9001 says it uses ECB is a disaster. It have heard people stating several times that ECB is ok in other settings as it is used by QUIC.\r\n\r\nStating that you use ECB will soon be non-compliant as NIST will soon disallow ECB.\r\n\r\nhttps://csrc.nist.gov/News/2022/proposal-to-revise-sp-800-38a\r\n\r\n_\"the use of ECB to encrypt confidential information constitutes a severe security vulnerability\"\r\n\"In the revision, NIST proposes to limit the approval of ECB to instances that are specifically allowed by other NIST standards or guidance.\"_\r\n\r\nPlease reformulate to state that you use AES encryption or AES-CTR, AES-CBC, AES-OFB, or AES-CFB.\r\n",
      "createdAt": "2024-09-20T16:06:42Z",
      "updatedAt": "2024-09-20T16:07:44Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 2,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ2NTY2Njkz",
      "title": "Clarify a few things.",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/2",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Some of which was discussed offline.",
      "createdAt": "2020-07-09T01:37:50Z",
      "updatedAt": "2020-07-09T02:17:17Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "0b71cb0fabec72a3420daefa7d0052382f1b7c59",
      "headRepository": null,
      "headRefName": "caw/edits",
      "headRefOid": "dab617684d1f67a2db487ca23af7316106fce70a",
      "closedAt": "2020-07-09T02:17:17Z",
      "mergedAt": "2020-07-09T02:17:16Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "8115bc3ba5fd3a69395914c2d31a5f5d3425d9dd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MjQ1Mzgy",
          "commit": {
            "abbreviatedOid": "dab6176"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-09T02:17:11Z",
          "updatedAt": "2020-07-09T02:17:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 9,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1ODEwOTEy",
      "title": "HTTP/3 has no END_HEADERS",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/9",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-09-30T21:55:58Z",
      "updatedAt": "2020-10-02T13:53:48Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "2e9c5ea7030685b37147d942e6f55814265c21e6",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "no-end-headers",
      "headRefOid": "953cf1943182113278bfde8aba240a38be7ab847",
      "closedAt": "2020-10-02T13:53:48Z",
      "mergedAt": "2020-10-02T13:53:48Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "240038eab12d5c81fa38651038cc59685141876d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMTU1NTE4",
          "commit": {
            "abbreviatedOid": "953cf19"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-02T13:53:44Z",
          "updatedAt": "2020-10-02T13:53:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 16,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAwMjE4MTgw",
      "title": "Address Lucas's comments",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/16",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Closes #5, Closes #6, Closes #7, Closes #8, Closes #10, Closes #11, Closes #12, Closes #13, and Closes #15.",
      "createdAt": "2020-10-08T22:12:08Z",
      "updatedAt": "2020-10-09T16:57:52Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "240038eab12d5c81fa38651038cc59685141876d",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "tfp/lucas-comments",
      "headRefOid": "1e218f5c523a70098594d2307918c731b3b7ae4b",
      "closedAt": "2020-10-09T16:57:52Z",
      "mergedAt": "2020-10-09T16:57:51Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "7f4994b44c3959f0fc7a7dd9f37ef02f6f3e8260"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1NjA1OTc3",
          "commit": {
            "abbreviatedOid": "1e218f5"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "These look great thanks.",
          "createdAt": "2020-10-09T11:58:37Z",
          "updatedAt": "2020-10-09T11:58:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 19,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAzMDYyMDEy",
      "title": "Fix typoes and CONNECT-UDP reference",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/19",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-14T02:21:16Z",
      "updatedAt": "2020-10-15T17:09:30Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "7f4994b44c3959f0fc7a7dd9f37ef02f6f3e8260",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "typoes20201013",
      "headRefOid": "58b3176c0dbaf6756dda9efe5b61f7fce77d52dd",
      "closedAt": "2020-10-15T17:09:30Z",
      "mergedAt": "2020-10-15T17:09:30Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "8d6ecdd699ec778fc40056a264f3f946ffce005d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NTk1Mjg5",
          "commit": {
            "abbreviatedOid": "58b3176"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-15T17:09:25Z",
          "updatedAt": "2020-10-15T17:09:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 24,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA0MjU4MjM5",
      "title": "Define proxy mapping state more rigorously",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/24",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Addressing #23, #22, #21, #20",
      "createdAt": "2020-10-15T17:18:07Z",
      "updatedAt": "2020-10-16T18:10:58Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "48709d612f77ed7cd6d64ca7aea72f576da69ad3",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "tfp/mappings",
      "headRefOid": "0fe8032e3ef999f80a33883c0145fa895651a944",
      "closedAt": "2020-10-16T18:10:58Z",
      "mergedAt": "2020-10-16T18:10:58Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "f8c8ffe11a236bebe0959d263c8bdb7b618f7be6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NzQyMzE5",
          "commit": {
            "abbreviatedOid": "55b42be"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This is super helpful. Thanks. \r\n\r\nI've got suggestions for nits. But also there's some things I think could be improvements.",
          "createdAt": "2020-10-15T20:02:55Z",
          "updatedAt": "2020-10-15T21:16:14Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "HTTP/3 DATAGRAM frames?",
              "createdAt": "2020-10-15T20:02:55Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 78,
              "body": "```suggestion\r\nserver-facing socket for every proxied QUIC connection. The mapping is critical for any case where server-facing\r\n```",
              "createdAt": "2020-10-15T20:09:47Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 49,
              "body": "At first, my marginal editorial suggestion was to move this sentence to the start of the section. But then I questioned myself whether the sentence is a notable comment or a complete description. The same applies to all 3 sections. I'll leave it to your discretion on what to do.",
              "createdAt": "2020-10-15T20:13:11Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 93,
              "body": "\r\n```suggestion\r\nA clients sends new CONNECT-QUIC requests when it wants to start\r\n```\r\n\r\nor \"a new\"",
              "createdAt": "2020-10-15T20:14:35Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 118,
              "body": "```suggestion\r\n## New Proxied Connection Setup\r\n```",
              "createdAt": "2020-10-15T20:18:00Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 126,
              "body": "This para seems a bit repetitive but is useful because it makes it clear what is required in this instance of the request. We can editorialize later.",
              "createdAt": "2020-10-15T20:25:40Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 140,
              "body": "As an alternative, does this read more clearly?\r\n\r\n```suggestion\r\nexpected to cooperate with proxies in selecting Client Connection IDs. A proxy\r\ndetects a conflict when it is not able to create a unique mapping using the Client Connection ID. \r\nIt can reject requests that would cause a conflict and indicate this to the client by replying with a\r\n409 (Conflict) status. In order to avoid conflicts, clients SHOULD select Connection IDs of at least\r\n8 bytes in length with unpredictable values.\r\n```",
              "createdAt": "2020-10-15T20:37:56Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 142,
              "body": "```suggestion\r\nA client also MUST NOT select a Client Connection ID that matches the ID used for the QUIC\r\nconnection to the proxy, as this inherently creates\r\n```",
              "createdAt": "2020-10-15T20:41:03Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 195,
              "body": "I could have missed it but this seems to be the first mention of rejection due to a Connection ID that is too short",
              "createdAt": "2020-10-15T20:48:13Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 199,
              "body": "```suggestion\r\n## Adding New Client Connection IDs\r\n```",
              "createdAt": "2020-10-15T20:48:31Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 202,
              "body": "to the proxy or the target? This gets confusing with the next paragraph.",
              "createdAt": "2020-10-15T20:49:42Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 206,
              "body": "```suggestion\r\nNEW_CONNECTION_ID frame once a successful response is received.\r\n```",
              "createdAt": "2020-10-15T20:50:08Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 208,
              "body": "```suggestion\r\n## Sending With Forwarded Mode\r\n```",
              "createdAt": "2020-10-15T20:50:53Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 218,
              "body": "This reads a little loose. It would help to say something like \"if a client Server-Connection-ID-containing request is rejected, for example with a 409 (Conflict) response, it MUST NOT forward...\"\r\n\r\nPerhaps more broadly, coming up with some terser terms for Client-Connection-ID-containing request and Server-Connection-ID-containing request could help this document...",
              "createdAt": "2020-10-15T20:55:59Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 227,
              "body": "```suggestion\r\n## Receiving With Forwarded Mode\r\n```",
              "createdAt": "2020-10-15T20:56:54Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 242,
              "body": "See earlier comment about more terse terms. We could then tighten this up to say soemthing \"The proxy MUST validate that the CONNECT-QUIC request is either type X or Y...\"",
              "createdAt": "2020-10-15T21:02:14Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 306,
              "body": "This section reads a little weird. I'll make a spin off issueo work on improvements for talking about request stream lifecycle; it should also cover the similar stuff described in H3's CONNECT section like what frames are valid.",
              "createdAt": "2020-10-15T21:14:56Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODE3ODM3",
          "commit": {
            "abbreviatedOid": "55b42be"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T21:20:14Z",
          "updatedAt": "2020-10-15T21:20:15Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "```suggestion\r\n- Datagram flow, which is a flow of HTTP/3 DATAGRAMs specific to a single client QUIC connection to the proxy.\r\n```",
              "createdAt": "2020-10-15T21:20:14Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODQ5NTM0",
          "commit": {
            "abbreviatedOid": "f88d64d"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T22:22:38Z",
          "updatedAt": "2020-10-15T22:22:39Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "I just tried arranging it the other way, but I think it was less clear. It flows right now as:\r\n- Text description of the mapping requirement\r\n- Diagram of the mapping\r\n- Explanation for what the mapping means",
              "createdAt": "2020-10-15T22:22:39Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODUwMDY2",
          "commit": {
            "abbreviatedOid": "f88d64d"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T22:23:48Z",
          "updatedAt": "2020-10-15T22:23:49Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Yeah that works for me.",
              "createdAt": "2020-10-15T22:23:49Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODUwNTEw",
          "commit": {
            "abbreviatedOid": "f88d64d"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T22:24:47Z",
          "updatedAt": "2020-10-15T22:24:47Z",
          "comments": [
            {
              "originalPosition": 242,
              "body": "Yeah, I think I may leave that for a later editorial cleanup. I am hesitant to add too much jargon yet.",
              "createdAt": "2020-10-15T22:24:47Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODUwODIx",
          "commit": {
            "abbreviatedOid": "f88d64d"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T22:25:27Z",
          "updatedAt": "2020-10-15T22:25:27Z",
          "comments": [
            {
              "originalPosition": 306,
              "body": "Sounds good, new issue welcome (and text welcome too!)",
              "createdAt": "2020-10-15T22:25:27Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODUxMDAw",
          "commit": {
            "abbreviatedOid": "7121f75"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T22:25:50Z",
          "updatedAt": "2020-10-15T22:25:51Z",
          "comments": [
            {
              "originalPosition": 218,
              "body": "Fixed this up!",
              "createdAt": "2020-10-15T22:25:51Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODM0NTg4",
          "commit": {
            "abbreviatedOid": "f88d64d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for writing this, it really addresses a lot of things! Sorry about the mountain of comments, many are editorial but some are design issues that we'd need to address if we want to resolve the 4 issues",
          "createdAt": "2020-10-15T21:51:22Z",
          "updatedAt": "2020-10-15T22:34:43Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "To be slightly pedantic it's not a UDP address:\r\n```suggestion\r\nbeing used by proxied connections, along with the UDP sockets (IP addresses and ports)\r\n```",
              "createdAt": "2020-10-15T21:51:22Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nallows the proxy to reuse server-facing sockets for multiple connections and support the forwarding\r\n```",
              "createdAt": "2020-10-15T21:53:48Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nA QUIC Connection ID identifies the receiver of a packet, and is chosen by the receiver.\r\n```",
              "createdAt": "2020-10-15T21:54:14Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 28,
              "body": "```suggestion\r\n- Datagram flow ID, which represents a flow of HTTP/3 DATAGRAMs specific to a single client QUIC connection to the proxy.\r\n```",
              "createdAt": "2020-10-15T21:54:45Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 29,
              "body": "```suggestion\r\n- Client-facing socket, which is the 4-tuple of UDP addresses and ports used to communicate between the client and the proxy.\r\n```",
              "createdAt": "2020-10-15T21:55:32Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 30,
              "body": "```suggestion\r\n- Server-facing socket, which is the 4-tuple of UDP addresses and ports used to communicate between the proxy and the target.\r\n```",
              "createdAt": "2020-10-15T21:55:44Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nThere are three required unidirectional mappings, described below.\r\n```",
              "createdAt": "2020-10-15T21:56:55Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 12,
              "body": "We should clarify that this is the full 4-tuple, you need the local ports too.",
              "createdAt": "2020-10-15T21:57:42Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 38,
              "body": "This is a little hard to reason about. How about instead explicitly map from (QuicConnection, flowID) tuple?",
              "createdAt": "2020-10-15T21:59:38Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 48,
              "body": "Well technically the client could send a packet with a flow ID that's unknown to the server",
              "createdAt": "2020-10-15T22:02:16Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 29,
              "body": "Our implementation doesn't use connected sockets on the server - each QUIC server has a single client-facing non-connected UDP socket. Maybe just mentioning somewhere that this spec uses \"socket\" as a way to refer to a 4-tuple and that it can be implemented a variety of ways",
              "createdAt": "2020-10-15T22:04:18Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 70,
              "body": "I don't think that's right, the mapping should be to a QUIC connection, not a client-facing socket - because multiple QUIC connections can share a client-facing socket",
              "createdAt": "2020-10-15T22:06:28Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 78,
              "body": "I'm not sure we've defined the term \"proxied QUIC connection\" anywhere. I ask because that's a concept that the proxy doesn't really have access to - the proxy can't distinguish between \"two CIDs belonging to one connection\" vs \"two connections\" if only short headers are involved",
              "createdAt": "2020-10-15T22:09:02Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 101,
              "body": "```suggestion\r\npseudo-header identifying the target. All requests for the same QUIC\r\n```",
              "createdAt": "2020-10-15T22:10:09Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 102,
              "body": "Why is this a SHOULD and not a MUST? It's required for correctness",
              "createdAt": "2020-10-15T22:11:25Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 103,
              "body": "We should address the discrepancy between authority and server-facing 4-tuple, they're not quite the same because DNS can return multiple results so we need to mention that the proxy has to save the authority in the mappings and reuse the DNS result from the first time around. (I'm also realizing the proxy really shouldn't perform happy eyeballs here because that would make things way more complicated)",
              "createdAt": "2020-10-15T22:13:14Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 123,
              "body": "```suggestion\r\nThe first request the clients makes MUST contain the authority pseudo-header and the\r\n```",
              "createdAt": "2020-10-15T22:16:58Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 138,
              "body": "We should define the term of \"conflict\" before using it. It particular, one CID being a prefix of another is a \"conflict\" for the purposes of this draft.",
              "createdAt": "2020-10-15T22:19:21Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 217,
              "body": "This is ambiguous: the server could decide to reject the request because it doesn't like the authority (e.g. if the client sends \"localhost\" as the authority, the proxy really ought to refuse to proxy there). Another example is DNS failure. I think that we need a way to convey the scenario where \"the proxy agrees to proxy to this authority and has opened a target-facing socket, but cannot use forwarding mode due to a conflict\".",
              "createdAt": "2020-10-15T22:25:43Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 229,
              "body": "As discussed in #23, it would be great to allow clients to disable forwarding mode",
              "createdAt": "2020-10-15T22:27:07Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 244,
              "body": "```suggestion\r\nif the requested datagram flow ID has already been used on that client-to-proxy QUIC connection\r\n```",
              "createdAt": "2020-10-15T22:28:02Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 255,
              "body": "I would phrase this as \"avoiding conflict\" instead of \"unique\" because conflicts here aren't only about equality",
              "createdAt": "2020-10-15T22:31:05Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODU3MjA5",
          "commit": {
            "abbreviatedOid": "7121f75"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T22:40:05Z",
          "updatedAt": "2020-10-15T22:40:05Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "So, my thought here was that a client _could_ decide to be sneaky and represent what is one connection between the client and the target as two subsequent flows to proxy, which could make it \"migrate\". It'd be some paranoid privacy thing, but I could see a reason it would be illegal as long as the client followed the rest of the rules.",
              "createdAt": "2020-10-15T22:40:05Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODU4MDM2",
          "commit": {
            "abbreviatedOid": "7121f75"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T22:41:56Z",
          "updatedAt": "2020-10-15T22:41:57Z",
          "comments": [
            {
              "originalPosition": 202,
              "body": "```suggestion\r\nA client can add new Connection IDs to a proxied QUIC connection by sending\r\na NEW_CONNECTION_ID frame to the target.\r\n```",
              "createdAt": "2020-10-15T22:41:56Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODU4NjI3",
          "commit": {
            "abbreviatedOid": "7121f75"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T22:43:21Z",
          "updatedAt": "2020-10-15T22:43:22Z",
          "comments": [
            {
              "originalPosition": 229,
              "body": "So my thought here is that disabling forwarding is essentially just using CONNECT-UDP (which is fine). My question is if that is a separate method, like CONNECT-UDP, or if it is a CONNECT-QUIC request that has a flow ID and authority but no connection ID.",
              "createdAt": "2020-10-15T22:43:21Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODU4ODM4",
          "commit": {
            "abbreviatedOid": "7121f75"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T22:43:54Z",
          "updatedAt": "2020-10-15T22:43:54Z",
          "comments": [
            {
              "originalPosition": 244,
              "body": "```suggestion\r\nif the requested datagram flow ID has already been used on that client <-> proxy QUIC connection\r\n```",
              "createdAt": "2020-10-15T22:43:54Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODU5MDkw",
          "commit": {
            "abbreviatedOid": "7121f75"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T22:44:31Z",
          "updatedAt": "2020-10-15T22:44:31Z",
          "comments": [
            {
              "originalPosition": 255,
              "body": "```suggestion\r\nClient Connection ID and the selected server-facing socket does not create a conflict, the proxy creates\r\n```",
              "createdAt": "2020-10-15T22:44:31Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODU5NDMz",
          "commit": {
            "abbreviatedOid": "7121f75"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T22:45:09Z",
          "updatedAt": "2020-10-15T22:45:10Z",
          "comments": [
            {
              "originalPosition": 268,
              "body": "```suggestion\r\nand the client-facing socket on which the request was received does not create a conflict, the proxy\r\n```",
              "createdAt": "2020-10-15T22:45:09Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODcyNjEz",
          "commit": {
            "abbreviatedOid": "e6a7f5b"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:18:21Z",
          "updatedAt": "2020-10-15T23:18:21Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Clarified",
              "createdAt": "2020-10-15T23:18:21Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODcyNjk3",
          "commit": {
            "abbreviatedOid": "e6a7f5b"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:18:32Z",
          "updatedAt": "2020-10-15T23:18:32Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Updated the mapping to that!",
              "createdAt": "2020-10-15T23:18:32Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODczNDA0",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:20:26Z",
          "updatedAt": "2020-10-15T23:20:26Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Clarified the text to be about this particular flow ID",
              "createdAt": "2020-10-15T23:20:26Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODczOTE3",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:21:48Z",
          "updatedAt": "2020-10-15T23:21:48Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Updated the mappings. I think there are still two mappings\u00a0\u2014 one to the QUIC Connection + Datagram Flow ID, and one to the client-facing socket (for forwarding).",
              "createdAt": "2020-10-15T23:21:48Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODc0MDgz",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:22:20Z",
          "updatedAt": "2020-10-15T23:22:20Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Added a note about what the term \"socket\" means for this document.",
              "createdAt": "2020-10-15T23:22:20Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODc0NDU1",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:23:27Z",
          "updatedAt": "2020-10-15T23:23:27Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Changed this to refer to the datagram flow ID, which is what it actually knows.",
              "createdAt": "2020-10-15T23:23:27Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODc0NjE0",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:23:54Z",
          "updatedAt": "2020-10-15T23:23:54Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "Added a paragraph about this in the proxy behavior section, since it really belongs there (the client doesn't really care)",
              "createdAt": "2020-10-15T23:23:54Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODc0NzEz",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:24:10Z",
          "updatedAt": "2020-10-15T23:24:10Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "Added a section early on (in state requirements) about what conflicts mean.",
              "createdAt": "2020-10-15T23:24:10Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODc1OTI2",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:27:15Z",
          "updatedAt": "2020-10-15T23:27:15Z",
          "comments": [
            {
              "originalPosition": 217,
              "body": "Requests that include Server-Connection-Id are only about opening up forwarding paths, not creating new upstream connections. Thus, I think the correct response here is to not forward, whatever the particular error code; assuming that you already were able to open up a tunneling path with the earlier request.",
              "createdAt": "2020-10-15T23:27:15Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODgwMTg2",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:33:50Z",
          "updatedAt": "2020-10-15T23:33:50Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Good point, agreed.",
              "createdAt": "2020-10-15T23:33:50Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODgwNTIz",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:34:19Z",
          "updatedAt": "2020-10-15T23:34:19Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Thanks, I like that.",
              "createdAt": "2020-10-15T23:34:19Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODgyNTUw",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:37:18Z",
          "updatedAt": "2020-10-15T23:37:18Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "That makes sense for the flow ID, but not for the authority - perhaps we say MUST be sent to the same authority and SHOULD be sent to the same Datagram-Flow-Id?",
              "createdAt": "2020-10-15T23:37:18Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODg0MDc1",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:39:30Z",
          "updatedAt": "2020-10-15T23:39:30Z",
          "comments": [
            {
              "originalPosition": 269,
              "body": "```suggestion\r\nIf a proxy reuses server-facing sockets, it SHOULD store which authorities (which could be a domain name or IP address literal)\r\n```",
              "createdAt": "2020-10-15T23:39:30Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODg0MzAw",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:39:49Z",
          "updatedAt": "2020-10-15T23:39:50Z",
          "comments": [
            {
              "originalPosition": 271,
              "body": "```suggestion\r\nnew DNS query and potentially choosing a different server IP address which could map to a different server.\r\n```",
              "createdAt": "2020-10-15T23:39:49Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODg0Nzg3",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:40:29Z",
          "updatedAt": "2020-10-15T23:40:29Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "Agreed, that's a better spot for it - I'll create new comments over there.",
              "createdAt": "2020-10-15T23:40:29Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODg1NzA2",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:41:54Z",
          "updatedAt": "2020-10-15T23:43:34Z",
          "comments": [
            {
              "originalPosition": 272,
              "body": "I'd suggest adding some text about how the server needs to resolve domain name authorities to IP addresses in the first place, we have text for reusing sockets but this might warrant its own paragraph",
              "createdAt": "2020-10-15T23:41:54Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 138,
              "body": "New text LGTM",
              "createdAt": "2020-10-15T23:43:34Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODg4OTE0",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:46:00Z",
          "updatedAt": "2020-10-15T23:46:01Z",
          "comments": [
            {
              "originalPosition": 217,
              "body": "I think this complicates the design - I'd rather think about any request being able to open up any mapping or socket - and I'd rather not use 4xx to indicate partial success - there are probably implementations out there that close the stream if the response isn't 2xx.",
              "createdAt": "2020-10-15T23:46:01Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODkxMDEx",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:49:10Z",
          "updatedAt": "2020-10-15T23:49:10Z",
          "comments": [
            {
              "originalPosition": 229,
              "body": "I think there's value in using CONNECT-QUIC without forwarding: one is allowing the proxy to only need one socket, another is if we decide to later add short header connection ID compression to CONNECT-QUIC",
              "createdAt": "2020-10-15T23:49:10Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5OTIyNTk2",
          "commit": {
            "abbreviatedOid": "803c908"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T00:21:42Z",
          "updatedAt": "2020-10-16T00:21:43Z",
          "comments": [
            {
              "originalPosition": 272,
              "body": "Added some text on this above!",
              "createdAt": "2020-10-16T00:21:42Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5OTIzMDY5",
          "commit": {
            "abbreviatedOid": "803c908"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T00:22:04Z",
          "updatedAt": "2020-10-16T00:22:04Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "Removed that bit\u2014it's now explained in the \"conflicts\" section.",
              "createdAt": "2020-10-16T00:22:04Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNTk2NTU3",
          "commit": {
            "abbreviatedOid": "adbec76"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T15:51:49Z",
          "updatedAt": "2020-10-16T15:51:49Z",
          "comments": [
            {
              "originalPosition": 229,
              "body": "Okay, updated text to allow either side to opt out of forwarding!",
              "createdAt": "2020-10-16T15:51:49Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNTk3MzEz",
          "commit": {
            "abbreviatedOid": "adbec76"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T15:52:49Z",
          "updatedAt": "2020-10-16T15:52:50Z",
          "comments": [
            {
              "originalPosition": 217,
              "body": "Updated the text to clarify this. The stream will indeed be closed and failed with any 4xx response (that just doesn't invalidate a separate stream that requested non-forwarding proxying to the same authority).",
              "createdAt": "2020-10-16T15:52:50Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjU0NTgz",
          "commit": {
            "abbreviatedOid": "adbec76"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T17:10:44Z",
          "updatedAt": "2020-10-16T17:19:21Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "```suggestion\r\nA client sends new CONNECT-QUIC requests when it wants to start\r\n```",
              "createdAt": "2020-10-16T17:10:44Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjgzMjIw",
          "commit": {
            "abbreviatedOid": "adbec76"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for the discussion and edits! Approved modulo a few small suggestions",
          "createdAt": "2020-10-16T17:48:03Z",
          "updatedAt": "2020-10-16T18:03:48Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nBoth clients and proxies can unilaterally choose to disable forwarded mode for any client <-> target connection.\r\n```",
              "createdAt": "2020-10-16T17:48:03Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 91,
              "body": "```suggestion\r\nThese mappings guarantee that any QUIC packet sent from a target to the proxy can be sent to the correct client,\r\nin either tunelled or forwarded mode. Note that this mapping becomes trivial if the proxy always opens a new\r\n```",
              "createdAt": "2020-10-16T17:51:18Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 199,
              "body": "```suggestion\r\n409 (Conflict) status. In order to avoid conflicts, clients SHOULD select Client Connection IDs of at least\r\n```",
              "createdAt": "2020-10-16T17:54:05Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 215,
              "body": "```suggestion\r\nSpecifically, this can occur if the Client Connection ID causes a conflict and the proxy\r\n```",
              "createdAt": "2020-10-16T17:54:40Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 234,
              "body": "```suggestion\r\nID, the client MUST send a CONNECT-QUIC request with the Client-Connection-Id header to the proxy, and only send the\r\n```",
              "createdAt": "2020-10-16T17:55:46Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 241,
              "body": "```suggestion\r\nheader to request the ability to forward packets. The client MUST wait for a successful (2xx)\r\n```",
              "createdAt": "2020-10-16T17:56:56Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 269,
              "body": "```suggestion\r\nA proxy MUST NOT forward packets from the target to the client until after the client has\r\nsent at least one packet in forwarded mode. Once this occurs, the proxy MAY use forwarded\r\n```",
              "createdAt": "2020-10-16T17:58:50Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 25,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA0MzkwMTc0",
      "title": "Explain guarantees provided by CONNECT-QUIC",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/25",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Explanatory text to explain goals and limitations",
      "createdAt": "2020-10-15T21:11:14Z",
      "updatedAt": "2020-10-16T15:47:14Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "8d6ecdd699ec778fc40056a264f3f946ffce005d",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "tfp/guarantees",
      "headRefOid": "519aefffab18c265962aed2fb37f2e6e68f6b423",
      "closedAt": "2020-10-16T15:47:14Z",
      "mergedAt": "2020-10-16T15:47:14Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "48709d612f77ed7cd6d64ca7aea72f576da69ad3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODI2NjYy",
          "commit": {
            "abbreviatedOid": "519aeff"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2020-10-15T21:36:08Z",
          "updatedAt": "2020-10-15T21:36:08Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODMzNTU1",
          "commit": {
            "abbreviatedOid": "519aeff"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-15T21:49:15Z",
          "updatedAt": "2020-10-15T21:49:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 28,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA1MDE5NTg5",
      "title": "Redefine as an extension of CONNECT-UDP",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/28",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Switch over from CONNECT-QUIC to be an extension to CONNECT-UDP. Also rename the document. I'd like to publish a version after this!",
      "createdAt": "2020-10-16T18:16:03Z",
      "updatedAt": "2020-10-16T18:52:22Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "f8c8ffe11a236bebe0959d263c8bdb7b618f7be6",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "tfp/extension",
      "headRefOid": "3be87ad8a92e1ebff1cdffb1c4a268af626b0473",
      "closedAt": "2020-10-16T18:52:22Z",
      "mergedAt": "2020-10-16T18:52:22Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "44d633141ef9f0e6fb48acb34c749f4a0ddc12ef"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzA3NTM1",
          "commit": {
            "abbreviatedOid": "7be1f02"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-16T18:25:27Z",
          "updatedAt": "2020-10-16T18:36:31Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Since you \ud83d\udc4d the idea \ud83d\ude07\r\n```suggestion\r\n\r\n -\r\n    ins: \"D. Schinazi\"\r\n    name: \"David Schinazi\"\r\n    organization: \"Google LLC\"\r\n    street: \"1600 Amphitheatre Parkway\"\r\n    city: \"Mountain View, California 94043\"\r\n    country: \"United States of America\"\r\n    email: dschinazi.ietf@gmail.com\r\n\r\n```",
              "createdAt": "2020-10-16T18:25:27Z",
              "updatedAt": "2020-10-16T18:51:36Z"
            },
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nThe CONNECT-UDP HTTP method {{!CONNECT-UDP=I-D.ietf-masque-connect-udp}} defines a way to send\r\n```",
              "createdAt": "2020-10-16T18:28:10Z",
              "updatedAt": "2020-10-16T18:51:36Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nand a target server. This can be used to proxy QUIC connections {{!QUIC=I-D.ietf-quic-transport}},\r\n```",
              "createdAt": "2020-10-16T18:28:21Z",
              "updatedAt": "2020-10-16T18:51:36Z"
            },
            {
              "originalPosition": 96,
              "body": "```suggestion\r\nand responses. All other requirements defined for CONNECT-UDP {{CONNECT-UDP}}\r\n```",
              "createdAt": "2020-10-16T18:29:48Z",
              "updatedAt": "2020-10-16T18:51:36Z"
            },
            {
              "originalPosition": 112,
              "body": "```suggestion\r\nLike the Datagram-Flow-Id header {{CONNECT-UDP}}, the Client-Connection-Id and\r\n```",
              "createdAt": "2020-10-16T18:30:16Z",
              "updatedAt": "2020-10-16T18:51:36Z"
            },
            {
              "originalPosition": 114,
              "body": "```suggestion\r\nsupport HTTP/3 datagrams {{!H3DGRAM=I-D.schinazi-quic-h3-datagram}}, or it does not support the extension defined\r\n```",
              "createdAt": "2020-10-16T18:31:14Z",
              "updatedAt": "2020-10-16T18:51:36Z"
            },
            {
              "originalPosition": 115,
              "body": "HTTP doesn't suggest to blindly echo headers, so I don't think the proxy is technically removing the header.\r\n```suggestion\r\nin this document, it MUST NOT send the Client-Connection-Id and Server-Connection-Id headers on any\r\n```",
              "createdAt": "2020-10-16T18:32:31Z",
              "updatedAt": "2020-10-16T18:51:36Z"
            },
            {
              "originalPosition": 293,
              "body": "Assuming you take the suggestion at the top \ud83d\ude07,\r\n```suggestion\r\nThanks to Lucas Pardue, Ryan Hamilton, and Mirja K\u00fchlewind for their inputs\r\n```",
              "createdAt": "2020-10-16T18:34:15Z",
              "updatedAt": "2020-10-16T18:51:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzE5ODAx",
          "commit": {
            "abbreviatedOid": "7be1f02"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T18:45:19Z",
          "updatedAt": "2020-10-16T18:45:19Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This title is fine but I can predict there might be a slight risk of confusion (i.e. \"can't you already do that?\"). An alternative could be \"QUIC-aware proxying using CONNECT-UDP\"",
              "createdAt": "2020-10-16T18:45:19Z",
              "updatedAt": "2020-10-16T18:51:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzIxNTcz",
          "commit": {
            "abbreviatedOid": "bedec04"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T18:48:15Z",
          "updatedAt": "2020-10-16T18:48:15Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I second this!",
              "createdAt": "2020-10-16T18:48:15Z",
              "updatedAt": "2020-10-16T18:51:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzIxOTAz",
          "commit": {
            "abbreviatedOid": "bedec04"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T18:48:44Z",
          "updatedAt": "2020-10-16T18:48:44Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Sounds good to me!",
              "createdAt": "2020-10-16T18:48:44Z",
              "updatedAt": "2020-10-16T18:51:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzIzMjI0",
          "commit": {
            "abbreviatedOid": "bedec04"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T18:50:54Z",
          "updatedAt": "2020-10-16T18:50:55Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "cool. It also conveniently avoids any assertions of optimized or efficient :D",
              "createdAt": "2020-10-16T18:50:54Z",
              "updatedAt": "2020-10-16T18:51:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzIzOTg0",
          "commit": {
            "abbreviatedOid": "3be87ad"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T18:52:02Z",
          "updatedAt": "2020-10-16T18:52:03Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "=) Updated",
              "createdAt": "2020-10-16T18:52:02Z",
              "updatedAt": "2020-10-16T18:52:03Z"
            }
          ]
        }
      ]
    },
    {
      "number": 29,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA1MDkxMTQ3",
      "title": "Various cleanups",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/29",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR is mostly editorial, but it also adds a little text to close Lucas' two issues.\r\n\r\nCloses #26, closes #27.",
      "createdAt": "2020-10-16T20:38:32Z",
      "updatedAt": "2020-10-16T21:14:08Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "44d633141ef9f0e6fb48acb34c749f4a0ddc12ef",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "one_more_pr",
      "headRefOid": "248e57ad5f58ce3e8756e24bca8a3064acfe3244",
      "closedAt": "2020-10-16T21:14:08Z",
      "mergedAt": "2020-10-16T21:14:07Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "66eda61d40a4b97d34cbfc27d345301c3cf500b2"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "The linebreak changes make this impossible to review on my phone, laptop packed away for the night sorry.",
          "createdAt": "2020-10-16T21:00:19Z",
          "updatedAt": "2020-10-16T21:00:19Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry about that @LPardue ",
          "createdAt": "2020-10-16T21:04:28Z",
          "updatedAt": "2020-10-16T21:04:28Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "No problem, just don't block on me if you want to merge and publish.",
          "createdAt": "2020-10-16T21:12:32Z",
          "updatedAt": "2020-10-16T21:12:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzg4Nzc5",
          "commit": {
            "abbreviatedOid": "c9d7d2a"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Approved pending nits!",
          "createdAt": "2020-10-16T20:47:11Z",
          "updatedAt": "2020-10-16T20:58:11Z",
          "comments": [
            {
              "originalPosition": 815,
              "body": "I had done this as a comment to not render in the spec, since we're tracking it already as an issue on the GitHub. We could also just remove?",
              "createdAt": "2020-10-16T20:47:11Z",
              "updatedAt": "2020-10-16T21:09:42Z"
            },
            {
              "originalPosition": 325,
              "body": "Amazing insights! ;)",
              "createdAt": "2020-10-16T20:51:40Z",
              "updatedAt": "2020-10-16T21:09:42Z"
            },
            {
              "originalPosition": 295,
              "body": "Whoops, thanks!",
              "createdAt": "2020-10-16T20:52:03Z",
              "updatedAt": "2020-10-16T21:09:42Z"
            },
            {
              "originalPosition": 103,
              "body": "```suggestion\r\n<-> target QUIC connections: the Header Form bit and the Destination Connection ID field in the short header.\r\n```",
              "createdAt": "2020-10-16T20:57:04Z",
              "updatedAt": "2020-10-16T21:09:42Z"
            },
            {
              "originalPosition": 102,
              "body": "```suggestion\r\nQUIC proxies only need to understand two fields from packets in client\r\n```",
              "createdAt": "2020-10-16T20:57:21Z",
              "updatedAt": "2020-10-16T21:09:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzk2NzYz",
          "commit": {
            "abbreviatedOid": "c9d7d2a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:02:44Z",
          "updatedAt": "2020-10-16T21:02:44Z",
          "comments": [
            {
              "originalPosition": 815,
              "body": "Oh, I see. It was only commenting out the first line, I've tweaked it to make it a multi-line comment now",
              "createdAt": "2020-10-16T21:02:44Z",
              "updatedAt": "2020-10-16T21:09:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzk2OTE2",
          "commit": {
            "abbreviatedOid": "c9d7d2a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:03:01Z",
          "updatedAt": "2020-10-16T21:03:02Z",
          "comments": [
            {
              "originalPosition": 325,
              "body": "Yeah gotta love IETF specs :) ",
              "createdAt": "2020-10-16T21:03:01Z",
              "updatedAt": "2020-10-16T21:09:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzk3Mzg3",
          "commit": {
            "abbreviatedOid": "c9d7d2a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:03:59Z",
          "updatedAt": "2020-10-16T21:04:00Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "That's not quite right, it also needs to look at long headers in target-proxy packets",
              "createdAt": "2020-10-16T21:03:59Z",
              "updatedAt": "2020-10-16T21:09:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzk3NDkw",
          "commit": {
            "abbreviatedOid": "c9d7d2a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:04:12Z",
          "updatedAt": "2020-10-16T21:04:12Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "That's not quite right, it also needs to look at long headers in target-proxy packets",
              "createdAt": "2020-10-16T21:04:12Z",
              "updatedAt": "2020-10-16T21:09:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzk3Njcw",
          "commit": {
            "abbreviatedOid": "c9d7d2a"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:04:37Z",
          "updatedAt": "2020-10-16T21:04:38Z",
          "comments": [
            {
              "originalPosition": 296,
              "body": "```suggestion\r\nfor all elements on the left side of the mapping diagrams above.\r\n\r\nSince very short Connection IDs are more likely to lead to conflicts, particularly zero-length\r\nConnection IDs, a proxy MAY choose to reject all requests for very short Connection IDs as\r\nconflicts, in anticipation of future conflicts.\r\n```",
              "createdAt": "2020-10-16T21:04:37Z",
              "updatedAt": "2020-10-16T21:09:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 30,
      "id": "MDExOlB1bGxSZXF1ZXN0NTEyODMzNTI2",
      "title": "\u0415\u0449\u0435 \u043e\u0434\u0438\u043d pr",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/30",
      "state": "CLOSED",
      "author": "Whoerr",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "closed",
      "createdAt": "2020-10-30T08:17:59Z",
      "updatedAt": "2021-02-25T18:30:53Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "tfp/lucas-comments",
      "baseRefOid": "1e218f5c523a70098594d2307918c731b3b7ae4b",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "one_more_pr",
      "headRefOid": "248e57ad5f58ce3e8756e24bca8a3064acfe3244",
      "closedAt": "2021-02-25T18:30:53Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 31,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE4MTA4NTkw",
      "title": "Add hacky interop parser.",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/31",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This spits out:\r\n\r\n```\r\n\u251c\u2500\u2500 interop\r\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 tests\r\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 connect-udp.mjs\r\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 draft-pauly-masque-quic-proxy.mjs\r\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 index.mjs\r\n```\r\n\r\nWith contents:\r\n\r\n```\r\nexport default\r\n{\r\n    \"description\": \"TBD\", \r\n    \"tests\": [\r\n        {\r\n            \"kind\": \"must\", \r\n            \"name\": \"Client sends `Client-Connection-Id` in first `CONNECT-UDP` request\", \r\n            \"id\": \"connect-udp-quic-client-cid\"\r\n        }\r\n    ], \r\n    \"name\": \"QUIC-Aware Proxying Using CONNECT-UDP\", \r\n    \"id\": \"draft-pauly-masque-quic-proxy.mjs\"\r\n}\r\n```",
      "createdAt": "2020-11-09T23:33:20Z",
      "updatedAt": "2020-11-10T04:06:08Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "f36b33ba34999f07cb4c0d64d874fcad6b48aeeb",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "caw/interop-automate",
      "headRefOid": "6d454ee1cdd516eec611b580ffda332787a2bdfa",
      "closedAt": "2020-11-10T04:06:08Z",
      "mergedAt": "2020-11-10T04:06:08Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "6a41e82adf3284abfa217eff603332a4bb70ad5e"
      },
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This all seems fine, but why is it in the repository for this individual draft? Shouldn't we have an official MASQUE WG repo that can hold things like this for CONNECT-UDP interop results?",
          "createdAt": "2020-11-10T01:02:39Z",
          "updatedAt": "2020-11-10T01:02:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This all seems fine, but why is it in the repository for this individual draft? Shouldn't we have an official MASQUE WG repo that can hold things like this for CONNECT-UDP interop results?\r\n\r\nMaybe, though it seems simpler to manage interop requirements and results right alongside the document source. This change extracts requirements from the document source and turns them into test targets. Implementations then submit PRs indicating their conformance against those targets.\r\n\r\nI expect the actual mechanics here to change as we get experience and feedback on how good, bad, ugly this is. ",
          "createdAt": "2020-11-10T01:09:22Z",
          "updatedAt": "2020-11-10T01:09:22Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2ODM3Mzkx",
          "commit": {
            "abbreviatedOid": "6d454ee"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good! Added a provisional description.",
          "createdAt": "2020-11-10T04:06:02Z",
          "updatedAt": "2020-11-10T04:06:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 32,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE4MTk5NDE3",
      "title": "Fill out interop requirements",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/32",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-11-10T04:26:00Z",
      "updatedAt": "2020-11-10T13:48:16Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "6a41e82adf3284abfa217eff603332a4bb70ad5e",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "tfp/interop-requirements",
      "headRefOid": "f147e2f463303a50b8a448634bf70ae6949e8040",
      "closedAt": "2020-11-10T13:48:16Z",
      "mergedAt": "2020-11-10T13:48:16Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9ebf5d4a2a50f090116e2516f2ccc4816dc6bf1d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 44,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE0NjcyNDIz",
      "title": "Describe conflicts with no connection IDs",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/44",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #34",
      "createdAt": "2021-04-13T18:24:58Z",
      "updatedAt": "2021-04-13T18:52:19Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "90bcff196d632b929a414b219dc4adee96466b36",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "tfpauly-patch-1",
      "headRefOid": "c388c428602fcff8f4a1eb6939f6674f67714631",
      "closedAt": "2021-04-13T18:52:19Z",
      "mergedAt": "2021-04-13T18:52:19Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "c2ca73020e216b49e10e5bd585e73dc7bc464d3e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM0OTE5OTkz",
          "commit": {
            "abbreviatedOid": "c388c42"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-13T18:47:55Z",
          "updatedAt": "2021-04-13T18:47:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 45,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE0Njc3MTIy",
      "title": "Add packet size considerations",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/45",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #33",
      "createdAt": "2021-04-13T18:33:29Z",
      "updatedAt": "2021-04-13T19:10:50Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "90bcff196d632b929a414b219dc4adee96466b36",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "tfpauly-patch-2",
      "headRefOid": "07764ba355c25d8c28d614cf8cab7fe652ac319d",
      "closedAt": "2021-04-13T18:54:48Z",
      "mergedAt": "2021-04-13T18:54:48Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "bad4057706e799843b53736d04dc6cace020f9df"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM0OTIwODM3",
          "commit": {
            "abbreviatedOid": "7f17f7c"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-13T18:48:55Z",
          "updatedAt": "2021-04-13T18:48:55Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "This doesn't parse?",
              "createdAt": "2021-04-13T18:48:55Z",
              "updatedAt": "2021-04-13T18:51:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM0OTIzMTMw",
          "commit": {
            "abbreviatedOid": "7f17f7c"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-13T18:51:41Z",
          "updatedAt": "2021-04-13T18:51:42Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nDATAGRAM frame. If the client does not begin with a larger packet size than 1200 bytes, it\r\n```",
              "createdAt": "2021-04-13T18:51:41Z",
              "updatedAt": "2021-04-13T18:51:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM0OTI0NTQy",
          "commit": {
            "abbreviatedOid": "07764ba"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-13T18:53:31Z",
          "updatedAt": "2021-04-13T18:53:51Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "you'll probably want to reflow this to match the line length limit",
              "createdAt": "2021-04-13T18:53:31Z",
              "updatedAt": "2021-04-13T18:53:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM0OTM4MjIw",
          "commit": {
            "abbreviatedOid": "07764ba"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-13T19:10:50Z",
          "updatedAt": "2021-04-13T19:10:50Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "(I can't suggest)\r\n\r\nnit: s/connections/connection",
              "createdAt": "2021-04-13T19:10:50Z",
              "updatedAt": "2021-04-13T19:10:50Z"
            }
          ]
        }
      ]
    },
    {
      "number": 46,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE0Njc5NDUy",
      "title": "Restrictions on use of server-facing socket",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/46",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #40",
      "createdAt": "2021-04-13T18:37:46Z",
      "updatedAt": "2021-04-13T18:52:35Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "90bcff196d632b929a414b219dc4adee96466b36",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "tfpauly-patch-3",
      "headRefOid": "13fe7ad80dc010dcad90089bd6dbf19c40c3ee2a",
      "closedAt": "2021-04-13T18:52:35Z",
      "mergedAt": "2021-04-13T18:52:35Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "179444508583fe5a3b4efcf537f02641dafbe4b9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM0OTIxNDYy",
          "commit": {
            "abbreviatedOid": "13fe7ad"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-13T18:49:40Z",
          "updatedAt": "2021-04-13T18:49:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 47,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE0NjgzNDcw",
      "title": "Mention connection migration",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/47",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #41",
      "createdAt": "2021-04-13T18:45:13Z",
      "updatedAt": "2021-04-13T18:52:09Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "90bcff196d632b929a414b219dc4adee96466b36",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "tfpauly-patch-4",
      "headRefOid": "6b4a1f49505def12156a8b46a6da4db1dfb0350b",
      "closedAt": "2021-04-13T18:52:09Z",
      "mergedAt": "2021-04-13T18:52:09Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "97566f816bd12e16031eeb5e6bc2ad387bf0603e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM0OTIyMDI0",
          "commit": {
            "abbreviatedOid": "6b4a1f4"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-13T18:50:19Z",
          "updatedAt": "2021-04-13T18:50:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 51,
      "id": "PR_kwDOEHrEP84s3q1n",
      "title": "Adopt capsules for QUIC-aware proxying",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/51",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Taking a pass a rewriting QUIC-aware proxying using the H3 capsule format",
      "createdAt": "2021-10-07T03:31:44Z",
      "updatedAt": "2021-10-08T17:12:14Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "e9412b137249c29ae282fb4fd61631c204406f99",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "tfp/capsules",
      "headRefOid": "6e68e29c5d83497c45693a46f2f2f765121a617f",
      "closedAt": "2021-10-08T17:12:14Z",
      "mergedAt": "2021-10-08T17:12:14Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "fdb6bf9ce1041e5dd68cccdc1f9d801255cadfec"
      },
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "@DavidSchinazi thanks for the review! I've updated accordingly, and think this is good now. Please re-review when you can.",
          "createdAt": "2021-10-07T23:32:24Z",
          "updatedAt": "2021-10-07T23:32:24Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "The use of capsules is a lot neater than the old multiple requests things.I haven't got my head around all of the implications yet.\r\n\r\nI don't understand the point of QUIC-proxy header but it seems harmless. Maybe some more text would help to explain why it is useful.",
          "createdAt": "2021-10-08T00:17:32Z",
          "updatedAt": "2021-10-08T00:17:32Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for all the comments @DavidSchinazi and @LPardue!\r\n\r\n@LPardue, regarding the header, I added that based on David's review. It's a way to negotiate that the new capsule types are supported, so the client knows that it won't ever get capsule responses if it doesn't hear back. We could just ignore that annoyance, and say that clients that don't hear an ACK back just deal with it. Thoughts? I'm OK to remove if we agree on that.",
          "createdAt": "2021-10-08T02:45:06Z",
          "updatedAt": "2021-10-08T02:45:06Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Right I can sort see that making sense but it's a bit finicky. Would we really see that being enabled on a per request basis? If its a property of the connection endpoints could state it in a setting.\r\n\r\nAlternatively if this sort of thing is useful deemed useful, you could twizzle it a bit. Define a common Capsule-Extensions header that lists entries that are supported. E.g. the client would send \"Capsule-Extensions: quic-aware, foo, bar\"",
          "createdAt": "2021-10-08T03:11:39Z",
          "updatedAt": "2021-10-08T03:11:39Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "@LPardue I guess the issue with a setting is that we don't have a way to get that in H1. The nice thing about connect-udp is that it has a protocol step via Upgrade or the extended CONNECT to negotiate support.\r\n\r\nIf we do want a way to say \"I support these capsules\", that might be nice as a generic thing rather than needing headers in each extension.\r\n\r\n@DavidSchinazi , thoughts?",
          "createdAt": "2021-10-08T03:15:43Z",
          "updatedAt": "2021-10-08T03:15:43Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "I can live with whatever is chosen here, it's easily modifiable ",
          "createdAt": "2021-10-08T03:17:15Z",
          "updatedAt": "2021-10-08T03:17:15Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually, I think we can use the header to also indicate if forwarding is supported/desired. I'm going to keep this as-is in this PR, and then do a follow-up.",
          "createdAt": "2021-10-08T17:10:14Z",
          "updatedAt": "2021-10-08T17:10:14Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP84uKLsr",
          "commit": {
            "abbreviatedOid": "17218e2"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Overall this looks great. Many small comments inline",
          "createdAt": "2021-10-07T21:39:59Z",
          "updatedAt": "2021-10-07T22:12:14Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "CONNECT-UDP isn't an \"extended CONNECT protocol\", that's just how it's conveyed over h2 and h3.\r\n```suggestion\r\nThis document defines an extension to UDP Proxying over HTTP\r\n```",
              "createdAt": "2021-10-07T21:39:59Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 24,
              "body": "```suggestion\r\nUDP Proxying over HTTP {{!CONNECT-UDP=I-D.ietf-masque-connect-udp}}\r\n```",
              "createdAt": "2021-10-07T21:40:52Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 63,
              "body": "```suggestion\r\n{{!HTTP3=I-D.ietf-quic-http}} and not any earlier versions of HTTP.\r\n```",
              "createdAt": "2021-10-07T21:41:19Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 77,
              "body": "```suggestion\r\n- Proxy: the endpoint that responds to the UDP proxying request.\r\n```",
              "createdAt": "2021-10-07T21:41:47Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 82,
              "body": "Do we still need to define this term here? Quarter stream ID is an encoding detail of HTTP datagrams over h3, I think this spec should just refer to the stream or the request?",
              "createdAt": "2021-10-07T21:42:53Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 91,
              "body": "I'd just call this the Stream Mapping. Conceptually in our implementation we'll map from the stream object, the fact that streams have IDs is a wire format detail",
              "createdAt": "2021-10-07T21:43:51Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 83,
              "body": "We've renamed HTTP/3 Datagrams to HTTP Datagrams\r\n```suggestion\r\n{{!HTTP-DGRAM=I-D.schinazi-quic-h3-datagram}} specific to a single client <-> proxy\r\n```",
              "createdAt": "2021-10-07T21:44:35Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 195,
              "body": "The max of 20 comes from QUICv1, but this spec mentions that it supports the invariants. So I'd remove this maximum. Saying that zero is invalid makes sense, but I don't think that needs to be enforced here since it'll be enforced by the conflict-checking code.",
              "createdAt": "2021-10-07T21:47:22Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 188,
              "body": "```suggestion\r\n  Connection ID (8..2040),\r\n```",
              "createdAt": "2021-10-07T21:47:38Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 187,
              "body": "We don't need the length since the capsule is self-terminating. Just use the capsule length.",
              "createdAt": "2021-10-07T21:48:13Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 237,
              "body": "I think you accidentally pasted a \u00b6 character here\r\n```suggestion\r\nstring encoded in UTF-8.\r\n```",
              "createdAt": "2021-10-07T21:49:15Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 269,
              "body": "```suggestion\r\nA client initiates UDP proxying via a CONNECT request as defined\r\n```",
              "createdAt": "2021-10-07T21:50:46Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 271,
              "body": "Should we have normative text saying that the client MUST first register a CID with the proxy and wait for the ACK_CLIENT_CID before it sends a NEW_CONNECTION_ID frame to the target server? If we don't things won't work right?",
              "createdAt": "2021-10-07T21:51:55Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 294,
              "body": "Should there be a header on both request/response so that the client can learn whether the proxy supports QUIC aware proxying? If not, the proxy is going to silently drop the REGISTER_CLIENT_CID capsule and the client will be stuck waiting",
              "createdAt": "2021-10-07T21:53:55Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 298,
              "body": "We should say that the proxy MUST reply to all REGISTER with ACK or CLOSE",
              "createdAt": "2021-10-07T21:54:19Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 213,
              "body": "We might want some normative text around which endpoint is allowed to send which capsule",
              "createdAt": "2021-10-07T21:54:49Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 426,
              "body": "```suggestion\r\nthe proxy validates the registration, tries to establish the appropriate\r\n```",
              "createdAt": "2021-10-07T21:57:51Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 428,
              "body": "I would have expected only new requests to establish server-facing sockets, not registration capsules",
              "createdAt": "2021-10-07T21:58:31Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 441,
              "body": "The demultiplexing here is by HTTP request, not on contexts\r\n\r\n```suggestion\r\nsockets across multiple UDP proxying requests, or have a unique server-facing socket\r\nfor every UDP proxying request.\r\n```",
              "createdAt": "2021-10-07T21:59:28Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 492,
              "body": "What's the point of supporting this extension if you don't support forwarding at all?",
              "createdAt": "2021-10-07T22:00:46Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 230,
              "body": "Calling these close codes conflicts with HTTP-DGRAM and is going to be confusing. How about CID Close Code? Especially renaming the prose in the rest of the doc would help.",
              "createdAt": "2021-10-07T22:02:05Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 516,
              "body": "QUIC stream states are unidirectional. Should we say that either side of the stream is closed here?",
              "createdAt": "2021-10-07T22:03:02Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 532,
              "body": "```suggestion\r\nA proxy can close its server-facing socket once all UDP proxying requests mapped to\r\n```",
              "createdAt": "2021-10-07T22:03:33Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 558,
              "body": "This qualification isn't correct for HTTP 1 and 2\r\n\r\n```suggestion\r\nan HTTP datagram.\r\n```",
              "createdAt": "2021-10-07T22:04:29Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 608,
              "body": "This is making me realize a failure mode:\r\n- client sets up UDP proxying to proxy\r\n- client sends INITIAL with SCID 0x11111111 and DCID 0x33333333\r\n- proxy decapsulates INITIAL and sends it to target server\r\n- server replies but swaps its own CID so it sends INITIAL with DCID 0x11111111 and SCID 0x77777777\r\n- proxy already has a mapping for 0x77777777 on another connection when it receives the server's packet",
              "createdAt": "2021-10-07T22:07:17Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 668,
              "body": "Replace DATAGRAM frames with HTTP Datagrams everywhere",
              "createdAt": "2021-10-07T22:08:43Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 714,
              "body": "```suggestion\r\n## CID Close Codes {#iana-close-codes}\r\n```",
              "createdAt": "2021-10-07T22:09:07Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 749,
              "body": "Now that I've read through the whole thing, I don't think there's value in having CID Close Codes at all. The purpose of Context Close Codes is to allow the client to take different action based on the code. I'm not seeing that here. If we want to indicate \"forwarding mode not allowed\" I'd suggest using a header instead.",
              "createdAt": "2021-10-07T22:11:50Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKXq8",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:07:22Z",
          "updatedAt": "2021-10-07T23:07:23Z",
          "comments": [
            {
              "originalPosition": 749,
              "body": "Agreed, I've removed this!",
              "createdAt": "2021-10-07T23:07:22Z",
              "updatedAt": "2021-10-07T23:07:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKXs3",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:07:37Z",
          "updatedAt": "2021-10-07T23:07:37Z",
          "comments": [
            {
              "originalPosition": 668,
              "body": "Replaced!",
              "createdAt": "2021-10-07T23:07:37Z",
              "updatedAt": "2021-10-07T23:07:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKXtr",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:07:44Z",
          "updatedAt": "2021-10-07T23:07:44Z",
          "comments": [
            {
              "originalPosition": 516,
              "body": "Fixed ",
              "createdAt": "2021-10-07T23:07:44Z",
              "updatedAt": "2021-10-07T23:07:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKXug",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:07:53Z",
          "updatedAt": "2021-10-07T23:07:53Z",
          "comments": [
            {
              "originalPosition": 230,
              "body": "Removed the close codes",
              "createdAt": "2021-10-07T23:07:53Z",
              "updatedAt": "2021-10-07T23:07:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKXwL",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:08:05Z",
          "updatedAt": "2021-10-07T23:08:05Z",
          "comments": [
            {
              "originalPosition": 428,
              "body": "Indeed, this is leftover text.",
              "createdAt": "2021-10-07T23:08:05Z",
              "updatedAt": "2021-10-07T23:08:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKXxt",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:08:18Z",
          "updatedAt": "2021-10-07T23:08:18Z",
          "comments": [
            {
              "originalPosition": 213,
              "body": "Added normative text",
              "createdAt": "2021-10-07T23:08:18Z",
              "updatedAt": "2021-10-07T23:08:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKXy0",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:08:27Z",
          "updatedAt": "2021-10-07T23:08:28Z",
          "comments": [
            {
              "originalPosition": 298,
              "body": "Added in the proxy behavior section.",
              "createdAt": "2021-10-07T23:08:28Z",
              "updatedAt": "2021-10-07T23:08:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKX0s",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:08:39Z",
          "updatedAt": "2021-10-07T23:08:40Z",
          "comments": [
            {
              "originalPosition": 187,
              "body": "Sounds good, removed",
              "createdAt": "2021-10-07T23:08:40Z",
              "updatedAt": "2021-10-07T23:08:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKX3P",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:08:58Z",
          "updatedAt": "2021-10-07T23:08:58Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "Sounds good. I think we should still allow 0-2040.",
              "createdAt": "2021-10-07T23:08:58Z",
              "updatedAt": "2021-10-07T23:08:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKX4K",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:09:06Z",
          "updatedAt": "2021-10-07T23:09:07Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "Fixed",
              "createdAt": "2021-10-07T23:09:06Z",
              "updatedAt": "2021-10-07T23:09:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKX5B",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:09:12Z",
          "updatedAt": "2021-10-07T23:09:13Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Fixed",
              "createdAt": "2021-10-07T23:09:13Z",
              "updatedAt": "2021-10-07T23:09:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKX5j",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:09:18Z",
          "updatedAt": "2021-10-07T23:09:18Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "Removed",
              "createdAt": "2021-10-07T23:09:18Z",
              "updatedAt": "2021-10-07T23:09:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKX9m",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:09:54Z",
          "updatedAt": "2021-10-07T23:09:54Z",
          "comments": [
            {
              "originalPosition": 492,
              "body": "The other case we describe is using a shared socket from the proxy to the server.",
              "createdAt": "2021-10-07T23:09:54Z",
              "updatedAt": "2021-10-07T23:09:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKYRN",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:12:44Z",
          "updatedAt": "2021-10-07T23:12:44Z",
          "comments": [
            {
              "originalPosition": 608,
              "body": "I think that's fine\u2014the proxy wouldn't be able to allow forwarding for the new client's connection to a server, where the server CID is 0x77777777, but it's OK for the new server to send to the client, since it's the client's CID (the DCID in the packet here) that matters, which is 0x11111111.",
              "createdAt": "2021-10-07T23:12:44Z",
              "updatedAt": "2021-10-07T23:12:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKYU4",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:13:16Z",
          "updatedAt": "2021-10-07T23:13:16Z",
          "comments": [
            {
              "originalPosition": 271,
              "body": "We do have that already:\r\n\r\n```\r\nPrior to informing the target of a new chosen client connection ID, the client\r\nMUST send a REGISTER_CLIENT_CID capsule request containing the new Client\r\nConnection ID.\r\n```",
              "createdAt": "2021-10-07T23:13:16Z",
              "updatedAt": "2021-10-07T23:13:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKaPi",
          "commit": {
            "abbreviatedOid": "80cb71a"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:32:00Z",
          "updatedAt": "2021-10-07T23:32:00Z",
          "comments": [
            {
              "originalPosition": 294,
              "body": "Added a header and explained its usage!",
              "createdAt": "2021-10-07T23:32:00Z",
              "updatedAt": "2021-10-07T23:32:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKadD",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:34:15Z",
          "updatedAt": "2021-10-07T23:34:16Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "This title is OK. But, based on the renaming of the dependent specs and how you treat that in your body text, perhaps you could call it\r\n\r\n`QUIC Proxying Optimization using HTTP/3`\r\n\r\nShortened to QPOH and pronounce like \"kapow!\"",
              "createdAt": "2021-10-07T23:34:15Z",
              "updatedAt": "2021-10-07T23:34:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKash",
          "commit": {
            "abbreviatedOid": "80cb71a"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:36:44Z",
          "updatedAt": "2021-10-07T23:36:44Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "It's not until mid-way through the intro does it become clear this only works for HTTP/3 connections. That _might_ be useful to know earlier.",
              "createdAt": "2021-10-07T23:36:44Z",
              "updatedAt": "2021-10-07T23:37:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKa7K",
          "commit": {
            "abbreviatedOid": "1f3e6ff"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:39:14Z",
          "updatedAt": "2021-10-07T23:39:14Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "@LPardue the quic-awareness works for all versions of HTTP, it's just forwarding mode that is HTTP/3 only.",
              "createdAt": "2021-10-07T23:39:14Z",
              "updatedAt": "2021-10-07T23:39:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKa-J",
          "commit": {
            "abbreviatedOid": "80cb71a"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:39:45Z",
          "updatedAt": "2021-10-07T23:39:46Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "it's adopted now :)\r\n\r\n```suggestion\r\nHTTP Datagram frames {{!HTTP-DGRAM=I-D.masque-h3-datagram}}, or be forwarded\r\n```",
              "createdAt": "2021-10-07T23:39:46Z",
              "updatedAt": "2021-10-07T23:39:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKbDK",
          "commit": {
            "abbreviatedOid": "48f01d8"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:40:35Z",
          "updatedAt": "2021-10-07T23:40:35Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Clarified this in the abstract",
              "createdAt": "2021-10-07T23:40:35Z",
              "updatedAt": "2021-10-07T23:40:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKbKR",
          "commit": {
            "abbreviatedOid": "e85d0f9"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:41:47Z",
          "updatedAt": "2021-10-07T23:41:47Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "Indeed, fixed!",
              "createdAt": "2021-10-07T23:41:47Z",
              "updatedAt": "2021-10-07T23:41:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKbhE",
          "commit": {
            "abbreviatedOid": "e85d0f9"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:45:39Z",
          "updatedAt": "2021-10-07T23:45:40Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "ah fair point. if you change the final word to `HTTP` the acronym still works ;)",
              "createdAt": "2021-10-07T23:45:39Z",
              "updatedAt": "2021-10-07T23:45:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKbmU",
          "commit": {
            "abbreviatedOid": "e85d0f9"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:46:32Z",
          "updatedAt": "2021-10-07T23:46:32Z",
          "comments": [
            {
              "originalPosition": 608,
              "body": "I wasn't concerned about forwarding, more about sharing a socket on the proxy. Because when the proxy picks the socket the CIDs don't conflict but then it finds out they conflict. Or am I misunderstanding how socket sharing works?",
              "createdAt": "2021-10-07T23:46:32Z",
              "updatedAt": "2021-10-07T23:46:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKbs8",
          "commit": {
            "abbreviatedOid": "e85d0f9"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:47:38Z",
          "updatedAt": "2021-10-08T00:13:13Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "```suggestion\r\nProxy awareness of QUIC Connection IDs relies on using capsules ({{HTTP-DGRAM}})\r\n```",
              "createdAt": "2021-10-07T23:47:38Z",
              "updatedAt": "2021-10-08T00:13:13Z"
            },
            {
              "originalPosition": 360,
              "body": "```suggestion\r\nThe client should only inform the target of the new Client Connection ID once an\r\n```",
              "createdAt": "2021-10-07T23:58:33Z",
              "updatedAt": "2021-10-08T00:13:13Z"
            },
            {
              "originalPosition": 372,
              "body": "```suggestion\r\nThe client MUST wait for an ACK_SERVER_CID capsule that contains the echoed\r\n```",
              "createdAt": "2021-10-07T23:58:50Z",
              "updatedAt": "2021-10-08T00:13:13Z"
            },
            {
              "originalPosition": 430,
              "body": "no need to state it's the same if you provide the value to send\r\n\r\n```suggestion\r\nby including a \"Proxy-QUIC\" header with a value of \"?1\" in a\r\nsuccessful response.\r\n```",
              "createdAt": "2021-10-08T00:01:03Z",
              "updatedAt": "2021-10-08T00:13:13Z"
            },
            {
              "originalPosition": 456,
              "body": "It's not the request authority now, it's the path",
              "createdAt": "2021-10-08T00:03:20Z",
              "updatedAt": "2021-10-08T00:13:13Z"
            },
            {
              "originalPosition": 488,
              "body": "is the use of context here correct? The example uses REGISTER_NO_CONTEXT",
              "createdAt": "2021-10-08T00:05:31Z",
              "updatedAt": "2021-10-08T00:13:13Z"
            },
            {
              "originalPosition": 496,
              "body": "\"first request for a given HTTP request\" reads a bit wonky even if it is accurate",
              "createdAt": "2021-10-08T00:06:38Z",
              "updatedAt": "2021-10-08T00:13:13Z"
            },
            {
              "originalPosition": 576,
              "body": "```suggestion\r\nof the new QUIC Client Connection ID, the client also sends a\r\n```",
              "createdAt": "2021-10-08T00:07:56Z",
              "updatedAt": "2021-10-08T00:13:13Z"
            },
            {
              "originalPosition": 664,
              "body": "```suggestion\r\nUpon receiving an ACK_SERVER_CID capsule, the client starts sending Short Header\r\n```",
              "createdAt": "2021-10-08T00:09:39Z",
              "updatedAt": "2021-10-08T00:13:13Z"
            },
            {
              "originalPosition": 753,
              "body": "```suggestion\r\nThis document registers six new values in the \"HTTP Capsule Types\"\r\n```",
              "createdAt": "2021-10-08T00:12:18Z",
              "updatedAt": "2021-10-08T00:13:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKfTJ",
          "commit": {
            "abbreviatedOid": "e85d0f9"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-08T00:28:33Z",
          "updatedAt": "2021-10-08T00:35:32Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Should we also note that this doesn't work in the presence of intermediaries between the client and proxy?",
              "createdAt": "2021-10-08T00:28:33Z",
              "updatedAt": "2021-10-08T00:35:32Z"
            },
            {
              "originalPosition": 488,
              "body": "I'd just skip mention of datagram contexts altogether in this sentence. \"Use the correct thing\" isn't particularly useful",
              "createdAt": "2021-10-08T00:35:08Z",
              "updatedAt": "2021-10-08T00:35:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKpg8",
          "commit": {
            "abbreviatedOid": "e85d0f9"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-08T02:32:10Z",
          "updatedAt": "2021-10-08T02:32:10Z",
          "comments": [
            {
              "originalPosition": 608,
              "body": "There is only one mapping that involves the Server CID, which is this:\r\n\r\n~~~\r\n(Client-facing socket + Server Connection ID)\r\n    => Server-facing socket\r\n~~~\r\n\r\nIt only matters to have a conflict about the Server CID within a given client-facing socket (or to the proxy itself).",
              "createdAt": "2021-10-08T02:32:10Z",
              "updatedAt": "2021-10-08T02:32:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKpn3",
          "commit": {
            "abbreviatedOid": "e85d0f9"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-08T02:33:37Z",
          "updatedAt": "2021-10-08T02:33:37Z",
          "comments": [
            {
              "originalPosition": 456,
              "body": "```suggestion\r\nthe target hostname in the CONNECT request, or finding an existing server-facing\r\n```",
              "createdAt": "2021-10-08T02:33:37Z",
              "updatedAt": "2021-10-08T02:33:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKqVG",
          "commit": {
            "abbreviatedOid": "6e68e29"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-08T02:41:52Z",
          "updatedAt": "2021-10-08T02:41:53Z",
          "comments": [
            {
              "originalPosition": 488,
              "body": "Good call! Fixed up this sentence",
              "createdAt": "2021-10-08T02:41:52Z",
              "updatedAt": "2021-10-08T02:41:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKqXo",
          "commit": {
            "abbreviatedOid": "6e68e29"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-08T02:42:18Z",
          "updatedAt": "2021-10-08T02:42:19Z",
          "comments": [
            {
              "originalPosition": 496,
              "body": "I think this sentence wasn't needed, removed",
              "createdAt": "2021-10-08T02:42:18Z",
              "updatedAt": "2021-10-08T02:42:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKqbE",
          "commit": {
            "abbreviatedOid": "6e68e29"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-08T02:42:55Z",
          "updatedAt": "2021-10-08T02:42:55Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Added text for that",
              "createdAt": "2021-10-08T02:42:55Z",
              "updatedAt": "2021-10-08T02:42:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 52,
      "id": "PR_kwDOEHrEP84s9Y4x",
      "title": "Use header to negotiate forwarding, allow forwarding immediately for \u2026",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/52",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Use header to negotiate forwarding, allow forwarding immediately for short headers.\r\n\r\nThis makes the header more useful, and allows clients to start receiving forwarded packets without waiting. This has been an issue for our deployment, where the MTU changes for short header packets from target to client shortly after switching to SH packets, but not always immediately.",
      "createdAt": "2021-10-08T19:36:02Z",
      "updatedAt": "2021-10-11T18:01:19Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "fdb6bf9ce1041e5dd68cccdc1f9d801255cadfec",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "tfp/header-negotiation",
      "headRefOid": "c2c5c5f8993d9aa43175502bc0f28ffc61e32a71",
      "closedAt": "2021-10-11T18:01:19Z",
      "mergedAt": "2021-10-11T18:01:19Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "ad94640114f279624009dc17873953d7fde42f42"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP84uN0ew",
          "commit": {
            "abbreviatedOid": "a6a2137"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-08T20:11:55Z",
          "updatedAt": "2021-10-08T20:11:55Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "reads weird.\r\n\r\n\"if the proxy supports, it will send Proxy-QUIC-Forwarding, the value says if it supports\"\r\n\r\nAre you trying to distinguish between implementations that support the forwarding feature outright, and implementations that choose to enable or disable forwarding on each request?",
              "createdAt": "2021-10-08T20:11:55Z",
              "updatedAt": "2021-10-08T20:11:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uN0l2",
          "commit": {
            "abbreviatedOid": "a6a2137"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-08T20:12:35Z",
          "updatedAt": "2021-10-08T20:12:36Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "'til death us do part\r\n\r\n```suggestion\r\nnot understand how to parse Connection ID capsules, and SHOULD NOT send any\r\n```",
              "createdAt": "2021-10-08T20:12:35Z",
              "updatedAt": "2021-10-08T20:12:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uN1Ix",
          "commit": {
            "abbreviatedOid": "5eea1ab"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm modulo nits",
          "createdAt": "2021-10-08T20:16:07Z",
          "updatedAt": "2021-10-08T20:16:07Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEHrEP84uN8Ms",
          "commit": {
            "abbreviatedOid": "b36f848"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-08T21:02:38Z",
          "updatedAt": "2021-10-08T21:02:38Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Fixed!",
              "createdAt": "2021-10-08T21:02:38Z",
              "updatedAt": "2021-10-08T21:02:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uSNBN",
          "commit": {
            "abbreviatedOid": "b36f848"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Overall looks great, minor comments inline",
          "createdAt": "2021-10-11T17:30:22Z",
          "updatedAt": "2021-10-11T17:43:09Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "I'd say MUST NOT here (though we need a carveout to say it's OK to send them before receiving the response, but I think that's already written somewhere)",
              "createdAt": "2021-10-11T17:30:22Z",
              "updatedAt": "2021-10-11T17:43:09Z"
            },
            {
              "originalPosition": 77,
              "body": "Perhaps it would help if we define the term \"proxy-facing socket\" in the Terminology section and use it here?",
              "createdAt": "2021-10-11T17:38:11Z",
              "updatedAt": "2021-10-11T17:43:09Z"
            },
            {
              "originalPosition": 79,
              "body": "```suggestion\r\nREGISTER_CLIENT_CID capsule. The client uses the Destination Connection ID field of the received packet to\r\n```",
              "createdAt": "2021-10-11T17:39:07Z",
              "updatedAt": "2021-10-11T17:43:09Z"
            },
            {
              "originalPosition": 43,
              "body": "I feel like this paragraph would fit better in the \"Proxy Response Behavior\" section. Perhaps we move it there and here just say \"Support for forwarding mode is determined by the \"Proxy-QUIC-Forwarding\" header, see {{response}}.\"",
              "createdAt": "2021-10-11T17:40:51Z",
              "updatedAt": "2021-10-11T17:43:09Z"
            },
            {
              "originalPosition": 107,
              "body": "This bit about zero-length CIDs feels out of place. What does it have to do with the rest of the paragraph which doesn't mention zero-length CIDs at all?",
              "createdAt": "2021-10-11T17:42:48Z",
              "updatedAt": "2021-10-11T17:43:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uSSFB",
          "commit": {
            "abbreviatedOid": "c2c5c5f"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T18:00:27Z",
          "updatedAt": "2021-10-11T18:00:27Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Good call, changed",
              "createdAt": "2021-10-11T18:00:27Z",
              "updatedAt": "2021-10-11T18:00:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uSSKU",
          "commit": {
            "abbreviatedOid": "c2c5c5f"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T18:00:53Z",
          "updatedAt": "2021-10-11T18:00:53Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "It's technically the same one as the \"client-facing socket\"... I'll leave this off for now",
              "createdAt": "2021-10-11T18:00:53Z",
              "updatedAt": "2021-10-11T18:00:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uSSLE",
          "commit": {
            "abbreviatedOid": "c2c5c5f"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T18:00:56Z",
          "updatedAt": "2021-10-11T18:00:56Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "Fixed",
              "createdAt": "2021-10-11T18:00:56Z",
              "updatedAt": "2021-10-11T18:00:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uSSMd",
          "commit": {
            "abbreviatedOid": "c2c5c5f"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T18:01:03Z",
          "updatedAt": "2021-10-11T18:01:03Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Good idea! Done.",
              "createdAt": "2021-10-11T18:01:03Z",
              "updatedAt": "2021-10-11T18:01:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uSSPE",
          "commit": {
            "abbreviatedOid": "c2c5c5f"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T18:01:16Z",
          "updatedAt": "2021-10-11T18:01:16Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "Yeah, I changed it to just be about a conflict instead",
              "createdAt": "2021-10-11T18:01:16Z",
              "updatedAt": "2021-10-11T18:01:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 55,
      "id": "PR_kwDOEHrEP84tCBBE",
      "title": "Server -> Target",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/55",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Use \"target\" name more than \"server\" to avoid confusion\r\n\r\nCloses #53 ",
      "createdAt": "2021-10-11T17:44:11Z",
      "updatedAt": "2021-10-11T17:55:09Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "tfp/header-negotiation",
      "baseRefOid": "b36f84899a4ca5ecdad96d282a5a55ec2bb428ab",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "tfp/target",
      "headRefOid": "ef560f0dd700ebacc85291950458037631e68bff",
      "closedAt": "2021-10-11T17:55:09Z",
      "mergedAt": "2021-10-11T17:55:09Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "ad261ff58b58d4133ec8cb24f56d2ca9155da7c3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP84uSQ5r",
          "commit": {
            "abbreviatedOid": "ef560f0"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-11T17:53:32Z",
          "updatedAt": "2021-10-11T17:53:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 57,
      "id": "PR_kwDOEHrEP84z-1TE",
      "title": "Update to draft-ietf-masque-connect-udp-07",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/57",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-03-05T00:49:03Z",
      "updatedAt": "2022-03-05T00:51:15Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "1b046aaaea141cbed076980a2c92f58711417356",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "design_team",
      "headRefOid": "f2409d6c932b13c903180446376f1e27f7676204",
      "closedAt": "2022-03-05T00:51:15Z",
      "mergedAt": "2022-03-05T00:51:15Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "875fd82750e12f47d67e477ee78f000fde935d56"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP841saxM",
          "commit": {
            "abbreviatedOid": "f2409d6"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-05T00:51:11Z",
          "updatedAt": "2022-03-05T00:51:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 58,
      "id": "PR_kwDOEHrEP845fA-d",
      "title": "Clarify mapping language",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/58",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Suggestions from Eric Rosenberg",
      "createdAt": "2022-06-10T18:35:00Z",
      "updatedAt": "2022-06-14T16:08:44Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "875fd82750e12f47d67e477ee78f000fde935d56",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "tfpauly-patch-5",
      "headRefOid": "9be72504bbe5647e1724d5897a64c9fca1c78076",
      "closedAt": "2022-06-14T16:08:44Z",
      "mergedAt": "2022-06-14T16:08:44Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "f9e2b546e44b9ef46920250f7ac6bdfcb9740c65"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP8479zmj",
          "commit": {
            "abbreviatedOid": "bf846dc"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is a great clarification. LGTM modulo two small nits",
          "createdAt": "2022-06-14T15:12:11Z",
          "updatedAt": "2022-06-14T15:12:54Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "We'll probably want to refactor this spec to explain what works with general HTTP and what works only with HTTP/3, but for now I'd suggest keeping this HTTP.\r\n\r\n```suggestion\r\n- Client <-> Proxy HTTP stream: a single HTTP stream established from\r\n```",
              "createdAt": "2022-06-14T15:12:11Z",
              "updatedAt": "2022-06-14T15:12:54Z"
            },
            {
              "originalPosition": 57,
              "body": "```suggestion\r\nHTTP stream or client-facing socket.\r\n```",
              "createdAt": "2022-06-14T15:12:31Z",
              "updatedAt": "2022-06-14T15:12:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 60,
      "id": "PR_kwDOEHrEP84-K2k5",
      "title": "Virtual Target Connection ID",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/60",
      "state": "MERGED",
      "author": "ehaydenr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-08-31T23:52:30Z",
      "updatedAt": "2022-09-02T22:45:36Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "f9e2b546e44b9ef46920250f7ac6bdfcb9740c65",
      "headRepository": "ehaydenr/quic-proxy",
      "headRefName": "virtual",
      "headRefOid": "c2f93997ee56a5c52633f963599b561107ad7659",
      "closedAt": "2022-09-02T22:45:36Z",
      "mergedAt": "2022-09-02T22:45:36Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "050afbdca7d33c327b67a56d6a9ffe5a0353b988"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85BIFGt",
          "commit": {
            "abbreviatedOid": "6561bda"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-01T00:18:22Z",
          "updatedAt": "2022-09-01T00:37:09Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I might say here something that sounds less strict\r\n\r\n\"QUIC endpoints issue Connection IDs to their peers, which are used in the Destination Connection ID field of packets sent by the peer. An endpoint on might rely on a load balancer to route QUIC packets to it, based on encoding information into the Connection IDs it issues; such as described in {{?QUIC-LB=I-D.ietf-quic-load-balancers}}. Such deployments are typically private and deployment specific and, crucially, rely on the peer using the Connection IDs that were issued. When operating in forwarding mode...\"",
              "createdAt": "2022-09-01T00:18:22Z",
              "updatedAt": "2022-09-01T00:39:11Z"
            },
            {
              "originalPosition": 26,
              "body": "How about something like\r\n\r\n\"clients send QUIC packets destined for the Target, directly to the Proxy. These packets\r\nuse Connection IDs issued by the Target, which may fail to meet the exceptions of a\r\nload balancer in front of the Proxy, introducing a potential for packet delivery failure.\"",
              "createdAt": "2022-09-01T00:22:28Z",
              "updatedAt": "2022-09-01T00:39:28Z"
            },
            {
              "originalPosition": 32,
              "body": "In keeping with prior suggestion, something like this maybe? \r\n\r\n\"The Virtual Target Connection ID can be used to address problems with load balancer routing. A Proxy can issue a Virtual Target Connection ID to a client. When the Proxy receives a QUIC packet with a Virtual Target Connection ID value, it substitutes the value with the actual Target Connection ID prior to forwarding. Routing problems are typically only a problem for packets travelling from Client to Target, so Virtual Target Connection IDs are only used in this direction.\"\r\n",
              "createdAt": "2022-09-01T00:33:19Z",
              "updatedAt": "2022-09-01T00:39:44Z"
            },
            {
              "originalPosition": 36,
              "body": "Can probably simplify this, when forwarding mode isn't in use, we're just back to normal UDP proxying (I think). So maybe\r\n\r\n\"When forwarding mode is not used to proxy QUIC, the concerns related to packet routing do not apply.\"",
              "createdAt": "2022-09-01T00:37:06Z",
              "updatedAt": "2022-09-01T00:37:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85BRCUn",
          "commit": {
            "abbreviatedOid": "6561bda"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-02T14:42:44Z",
          "updatedAt": "2022-09-02T14:42:45Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Adjusted this text to be a little more similar to [another place in the document](https://github.com/tfpauly/quic-proxy/blob/main/draft-pauly-masque-quic-proxy.md#adding-new-client-connection-ids)\r\n> Since QUIC connection IDs are chosen by the receiver",
              "createdAt": "2022-09-02T14:42:44Z",
              "updatedAt": "2022-09-02T14:42:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85BRJZe",
          "commit": {
            "abbreviatedOid": "87b295d"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-02T15:04:25Z",
          "updatedAt": "2022-09-02T15:04:26Z",
          "comments": [
            {
              "originalPosition": 171,
              "body": "```suggestion\r\n: The Proxy-chosen connection ID that the client MUST use when sending packets\r\n```",
              "createdAt": "2022-09-02T15:04:25Z",
              "updatedAt": "2022-09-02T15:04:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85BRJpE",
          "commit": {
            "abbreviatedOid": "87b295d"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-02T15:05:07Z",
          "updatedAt": "2022-09-02T15:05:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 62,
      "id": "PR_kwDOEHrEP84_Oxh8",
      "title": "bidirectional virtual connection ids",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/62",
      "state": "MERGED",
      "author": "ehaydenr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "addresses #61 ",
      "createdAt": "2022-09-19T21:43:31Z",
      "updatedAt": "2022-10-18T21:36:19Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "050afbdca7d33c327b67a56d6a9ffe5a0353b988",
      "headRepository": "ehaydenr/quic-proxy",
      "headRefName": "bidirectional-virtual",
      "headRefOid": "67a68aba9a02a55a21b5abcb2f25f3849d6cd1dd",
      "closedAt": "2022-10-18T21:36:10Z",
      "mergedAt": "2022-10-18T21:36:10Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "4bb7edf24c105d7f82fd3dda19cf201991f62d21"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85CVe58",
          "commit": {
            "abbreviatedOid": "16140f1"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for doing this! A few minor comments",
          "createdAt": "2022-09-19T22:00:07Z",
          "updatedAt": "2022-09-19T22:13:15Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "Why the discrepancy here? Is there a reason to force the lengths to be equal?",
              "createdAt": "2022-09-19T22:00:07Z",
              "updatedAt": "2022-09-19T22:13:15Z"
            },
            {
              "originalPosition": 139,
              "body": "```suggestion\r\n: The receiver-chosen connection ID that the sender MUST use when sending\r\n```",
              "createdAt": "2022-09-19T22:00:32Z",
              "updatedAt": "2022-09-19T22:13:15Z"
            },
            {
              "originalPosition": 138,
              "body": "Mentions of sender and receiver in this paragraph are unclear: I was expecting them to be the sender/receiver of the capsule being discussed, but that doesn't appear to be the case",
              "createdAt": "2022-09-19T22:01:37Z",
              "updatedAt": "2022-09-19T22:13:15Z"
            },
            {
              "originalPosition": 149,
              "body": "This isn't specific to this PR, but it would be nice to add a paragraph explaining why proxies care about stateless reset tokens and in which scenarios this feature would be useful",
              "createdAt": "2022-09-19T22:06:50Z",
              "updatedAt": "2022-09-19T22:13:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CViCO",
          "commit": {
            "abbreviatedOid": "eb87156"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-19T22:16:51Z",
          "updatedAt": "2022-09-19T22:16:52Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "To match the order of the CIDs above, let's put Virtual CCID before Virtual TCID",
              "createdAt": "2022-09-19T22:16:51Z",
              "updatedAt": "2022-09-19T22:16:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CVily",
          "commit": {
            "abbreviatedOid": "eb87156"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-19T22:20:07Z",
          "updatedAt": "2022-09-19T22:23:34Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nreceives. Servers receiving QUIC packets may employ load balancing\r\n```",
              "createdAt": "2022-09-19T22:20:07Z",
              "updatedAt": "2022-09-19T22:23:34Z"
            },
            {
              "originalPosition": 26,
              "body": "```suggestion\r\nQUIC allows each endpoint of a connection to choose the destination connection IDs it\r\n```",
              "createdAt": "2022-09-19T22:20:32Z",
              "updatedAt": "2022-09-19T22:23:34Z"
            },
            {
              "originalPosition": 39,
              "body": "I think this is true for all clients, can we just say that \"QUIC requires that connections IDs aren't reused over multiple network paths to...\"?",
              "createdAt": "2022-09-19T22:21:26Z",
              "updatedAt": "2022-09-19T22:23:34Z"
            },
            {
              "originalPosition": 44,
              "body": "To \"a\" proxy network path? To \"the\" proxy network path?",
              "createdAt": "2022-09-19T22:22:04Z",
              "updatedAt": "2022-09-19T22:23:34Z"
            },
            {
              "originalPosition": 45,
              "body": "```suggestion\r\npackets destined for the client would have the same connection ID.\r\n```",
              "createdAt": "2022-09-19T22:22:15Z",
              "updatedAt": "2022-09-19T22:23:34Z"
            },
            {
              "originalPosition": 203,
              "body": "Same socket? Same 5-tuple?",
              "createdAt": "2022-09-19T22:22:52Z",
              "updatedAt": "2022-09-19T22:23:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CVp6U",
          "commit": {
            "abbreviatedOid": "eb87156"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-19T23:11:11Z",
          "updatedAt": "2022-09-19T23:11:11Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "I was thinking about differences between passive and active migration. In the passive case, the CID may not have changed despite having been reused over a new network path. I'm wondering if it is necessary to mention this here or if the language you propose is sufficient.",
              "createdAt": "2022-09-19T23:11:11Z",
              "updatedAt": "2022-09-19T23:11:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CVrCL",
          "commit": {
            "abbreviatedOid": "eb87156"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-19T23:20:00Z",
          "updatedAt": "2022-09-19T23:20:01Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "QUIC has text about that already, I'd be tempted to say that we just refer to that since it was very carefully worded \ud83e\udd37 ",
              "createdAt": "2022-09-19T23:20:00Z",
              "updatedAt": "2022-09-19T23:20:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CVz85",
          "commit": {
            "abbreviatedOid": "eb87156"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T00:35:31Z",
          "updatedAt": "2022-09-20T00:35:31Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "The discrepancy is motivated by implementation considerations. If implementing forwarding in a way that requires fixing IP and/or UDP checksums, only length changes by a multiple of 4 can be done incrementally. If the length difference is not a multiple of 4, the entire checksum would have to be recomputed. One example of this constraint is documented in [Linux's BPF helpers](https://man7.org/linux/man-pages/man7/bpf-helpers.7.html) (bpf_csum_diff):\r\n\r\n> Compute a checksum difference, from the raw buffer\r\n                     pointed by from, of length from_size (that must be\r\n                     a multiple of 4), towards the raw buffer pointed by\r\n                     to, of size to_size (same remark).\r\n\r\nIn the Virtual Target Connection ID case, the requirement to support Virtual Connection IDs of a different length is quite clear. Load balancing strategies such as those described QUIC-LB may require a minimum CID length to encode information (e.g. 17 bytes in the [single-pass encryption](https://datatracker.ietf.org/doc/html/draft-ietf-quic-load-balancers#section-4.3.1) case). If the proxy intended on using an incremental checksum algorithm, it could make sure that the Virtual Target CID is a multiple of 4 larger than the Target CID. For example, if the Target CID is 15 bytes, it could provide a Virtual Target CID of 19 bytes (17 \"real\" bytes encoding/encrypting information followed by 2 randomly chosen bytes). The replace operation of a 19 bytes buffer to a 15 byte buffer would be compatible with incremental checksum algorithms since 4 bytes are removed.\r\n\r\nRequiring the Target Connection ID be at least the length of the Virtual Target Connection ID would necessitate cooperation with the target and as such is a non-starter. The draft currently allows any type of length difference between the Target Connection ID and Virtual Target Connection ID. We could instead tighten this up by requiring that the Virtual Target Connection ID be at least as long as the Target Connection ID, but I'm not sure how useful this is.\r\n\r\nBy requiring that the Client CID and Virtual Client CID lengths be equal, we're guaranteeing that incremental checksum is possible. We could instead require that the difference in length between Client CID and Virtual Client CID be a multiple of 4, but that seems like too specific of a requirement - particularly if it is of no real consequence to simply require they be equal.\r\n\r\nBy taking the above Virtual Target Connection ID length difference case as a requirement, we're precluding the client from using incremental checksum algorithms in the first place because it must be able to translate between arbitrary lengths when sending. Given that the client already needs to handle arbitrary length differences and that Client and Virtual Client CIDs are BOTH generated by the client, I would think that it has sufficient flexibility in crafting a Virtual Client CID of equivalent length that meet its needs. If we chose not to require this, the inclusion of Virtual Client CID (this PR) would introduce the requirement to do a full checksum recalculation for the reasons described above. \r\n",
              "createdAt": "2022-09-20T00:35:31Z",
              "updatedAt": "2022-09-20T00:35:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CV0bs",
          "commit": {
            "abbreviatedOid": "eb87156"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T00:40:08Z",
          "updatedAt": "2022-09-20T00:40:08Z",
          "comments": [
            {
              "originalPosition": 203,
              "body": "I'm reusing the language as above: https://github.com/tfpauly/quic-proxy/blob/050afbdca7d33c327b67a56d6a9ffe5a0353b988/draft-pauly-masque-quic-proxy.md?plain=1#L453 `git blame` shows @DavidSchinazi so I'll defer to him\r\n",
              "createdAt": "2022-09-20T00:40:08Z",
              "updatedAt": "2022-09-20T00:40:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CV1OJ",
          "commit": {
            "abbreviatedOid": "eb87156"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T00:47:41Z",
          "updatedAt": "2022-09-20T00:47:41Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "> ... choose the destination connection IDs it receives\r\n\r\nTo me, that reads a little ambiguously. An endpoints of a QUIC connection \"receives\" connection IDs from its peer via NEW_CONNECTION_ID frames, but that's obviously not what you meant. That being said, I don't love the language as-is either, but it's a carry over from the previous PR. May or may not make sense to address it now. ",
              "createdAt": "2022-09-20T00:47:41Z",
              "updatedAt": "2022-09-20T00:47:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CV1eb",
          "commit": {
            "abbreviatedOid": "eb87156"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T00:50:07Z",
          "updatedAt": "2022-09-20T00:50:08Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "thanks, 148fd98781f95cca92ee3f0fe052469658f17957",
              "createdAt": "2022-09-20T00:50:07Z",
              "updatedAt": "2022-09-20T00:50:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CV1wQ",
          "commit": {
            "abbreviatedOid": "eb87156"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T00:52:48Z",
          "updatedAt": "2022-09-20T00:52:49Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "good catch: 5c419f6be0ae9b855be73a397dc114a6085bb829",
              "createdAt": "2022-09-20T00:52:49Z",
              "updatedAt": "2022-09-20T00:52:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CV2no",
          "commit": {
            "abbreviatedOid": "eb87156"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T01:00:54Z",
          "updatedAt": "2022-09-20T01:00:54Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "thanks, updated the language and made a few other changes here: 65db5de9489c96463f48ab2d9d8edafdfc8f1d8f",
              "createdAt": "2022-09-20T01:00:54Z",
              "updatedAt": "2022-09-20T01:00:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CV2tz",
          "commit": {
            "abbreviatedOid": "16140f1"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T01:01:46Z",
          "updatedAt": "2022-09-20T01:01:46Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "Thanks for the detailed explanation. I would suggest making this a SHOULD instead of a MUST: if the absolute worst case scenario is recomputing the checksum on each packet, then that doesn't warrant a MUST. There might be use-cases where a client or proxy isn't in control of its CID length, and in such scenarios they'd rather pay the checksum cost instead of failing.",
              "createdAt": "2022-09-20T01:01:46Z",
              "updatedAt": "2022-09-20T01:01:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CV3Hv",
          "commit": {
            "abbreviatedOid": "eb87156"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T01:05:30Z",
          "updatedAt": "2022-09-20T01:05:30Z",
          "comments": [
            {
              "originalPosition": 203,
              "body": "Sockets are explicitly defined as UDP 4-tuples in Section 1.2, so using the word \"socket\" here is fine by me",
              "createdAt": "2022-09-20T01:05:30Z",
              "updatedAt": "2022-09-20T01:06:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CV6gt",
          "commit": {
            "abbreviatedOid": "16140f1"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T01:35:27Z",
          "updatedAt": "2022-09-20T01:35:27Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "Something I forgot to include that is also worth considering is that the Virtual Client CID must be at least as long as the Client CID to avoid linkability. Consider the case of connection migration. If the Virtual Client CID is 0xaabb and the Client CID is 0x11223344, and the Virtual Client CID was changed due to migration to 0xccdd, the packet would go from flags byte followed by 0xaabb3344 to 0xccdd3344. The \"3344\" would increase linkability.\r\n\r\nThe Virtual Target Connection ID has the same issue - the client<->proxy network path change would expose any extra client<->target CID bytes. I think in both cases the Virtual Connection ID must be at least as long as its counterpart.",
              "createdAt": "2022-09-20T01:35:27Z",
              "updatedAt": "2022-09-20T01:35:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CZoGk",
          "commit": {
            "abbreviatedOid": "16140f1"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T15:08:59Z",
          "updatedAt": "2022-09-20T15:08:59Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "Addressed here: 6cad095ceea2b5d54233a5111253a2351a894149",
              "createdAt": "2022-09-20T15:08:59Z",
              "updatedAt": "2022-09-20T15:08:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CZpyz",
          "commit": {
            "abbreviatedOid": "16140f1"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T15:13:01Z",
          "updatedAt": "2022-09-20T15:13:01Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "Agreed, how about something like this?\r\n\r\n> The peer-chosen connection ID that the sender of forwarded mode packets MUST\r\n> use when sending. The endpoint rewrites forwarding mode packets to contain the\r\n> correct Connection ID prior to sending them.",
              "createdAt": "2022-09-20T15:13:01Z",
              "updatedAt": "2022-09-20T15:13:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CZxdk",
          "commit": {
            "abbreviatedOid": "16140f1"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T15:30:36Z",
          "updatedAt": "2022-09-20T15:30:36Z",
          "comments": [
            {
              "originalPosition": 149,
              "body": "Great point, I added some language here: f6ab95a1c0313babf5eb4c29e8fad8485fb0cab6",
              "createdAt": "2022-09-20T15:30:36Z",
              "updatedAt": "2022-09-20T15:30:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CZ399",
          "commit": {
            "abbreviatedOid": "16140f1"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T15:46:33Z",
          "updatedAt": "2022-09-20T15:46:33Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "Oh this doesn't match my understanding of how replacement works, which makes me wonder if the replacement is sufficiently well documented. I was assuming that in this scenario you would replace `0x11223344` with `0xaabb` (not `0xaabb3344`) so you might see these two packets in sequence:\r\n* before replacement `0x11223344abcdef...` `0x11223344fedcba...`\r\n* after replacement `0xaabbabcdef...` `0xaabbfedcba...`\r\n\r\nAm I misunderstanding how replacement works?",
              "createdAt": "2022-09-20T15:46:33Z",
              "updatedAt": "2022-09-20T15:46:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CZ8_B",
          "commit": {
            "abbreviatedOid": "f6ab95a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T15:58:59Z",
          "updatedAt": "2022-09-20T15:59:00Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "This new text is great, can we also augment it with an example where one device reboots and loses state, and what happens in that scenario to properly close the connection?",
              "createdAt": "2022-09-20T15:59:00Z",
              "updatedAt": "2022-09-20T15:59:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CaJP_",
          "commit": {
            "abbreviatedOid": "16140f1"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T16:33:20Z",
          "updatedAt": "2022-09-20T16:33:20Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "In a previous commit, the replacement where the virtual cid is smaller than the cid is described [here](https://github.com/tfpauly/quic-proxy/pull/62/commits/6cad095ceea2b5d54233a5111253a2351a894149#diff-4dd090ab6ff7820385219d3ec1e86133930ab3a3b71aee2fe6e1a61a459f8da4L472)\r\n\r\n> If the Virtual Target Connection ID is smaller than the Target Connection ID,\r\n the client MUST only write the Virtual Target Connection ID bytes over the start\r\n of the Target Connection ID, leaving the remainder of the Target Connection ID\r\n unmodified.\r\n\r\nThat was removed in 6cad095ceea2b5d54233a5111253a2351a894149 when changing the requirement to be that the virtual cid be at least as long as the cid.\r\n\r\nI can update to document each case (virtual smaller, equal, and larger) to try to make this clearer once we get some alignment on what (if any) requirements should exist and what replacement should look like.\r\n\r\nI hadn't considered shrinking the packet when the virtual cid is smaller than the cid, but it would satisfy the exposure issue during migration and should work equally well. Assuming we go with this approach, the replacement is always a \"full\" replacement. @tfpauly not sure if you have any opinions here.",
              "createdAt": "2022-09-20T16:33:20Z",
              "updatedAt": "2022-09-20T16:33:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CaQ0C",
          "commit": {
            "abbreviatedOid": "f6ab95a"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T16:56:54Z",
          "updatedAt": "2022-09-20T16:56:54Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "Thanks, I added an example in e191d7d958c2f127038f8df6426917c6958a763f. I went with a slightly different example, but I think it communicates the same thing.",
              "createdAt": "2022-09-20T16:56:54Z",
              "updatedAt": "2022-09-20T16:56:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CaR-4",
          "commit": {
            "abbreviatedOid": "f6ab95a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T17:00:01Z",
          "updatedAt": "2022-09-20T17:00:01Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "Great, thanks!",
              "createdAt": "2022-09-20T17:00:01Z",
              "updatedAt": "2022-09-20T17:00:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85Cya_O",
          "commit": {
            "abbreviatedOid": "16140f1"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-26T16:00:26Z",
          "updatedAt": "2022-09-26T16:00:26Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "@DavidSchinazi removed length restrictions in 02f2fd47be22fcfba66c5d085d9406bf3e752f4c",
              "createdAt": "2022-09-26T16:00:26Z",
              "updatedAt": "2022-09-26T16:00:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85Cyhs8",
          "commit": {
            "abbreviatedOid": "16140f1"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-26T16:15:11Z",
          "updatedAt": "2022-09-26T16:15:12Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "updated with the above language in 7a2ec8dfe7b644a8f93e903a2ef500d6d49972c5",
              "createdAt": "2022-09-26T16:15:11Z",
              "updatedAt": "2022-09-26T16:15:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85EVqiE",
          "commit": {
            "abbreviatedOid": "7a2ec8d"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-18T21:15:27Z",
          "updatedAt": "2022-10-18T21:15:27Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Yeah, let's not address for now.",
              "createdAt": "2022-10-18T21:15:27Z",
              "updatedAt": "2022-10-18T21:15:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85EVrPl",
          "commit": {
            "abbreviatedOid": "7a2ec8d"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-18T21:18:19Z",
          "updatedAt": "2022-10-18T21:27:59Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nusing the Target Connection ID, load balancers would not be able to route packets\r\nto the correct Proxy if the packets were sent with the Target Connection ID.\r\nThe Virtual Target Connection ID is a connection ID chosen\r\n```",
              "createdAt": "2022-10-18T21:18:19Z",
              "updatedAt": "2022-10-18T21:27:59Z"
            },
            {
              "originalPosition": 28,
              "body": "```suggestion\r\nreceives with. Servers receiving QUIC packets can employ load balancing\r\n```",
              "createdAt": "2022-10-18T21:18:36Z",
              "updatedAt": "2022-10-18T21:27:59Z"
            },
            {
              "originalPosition": 30,
              "body": "```suggestion\r\nthat encode routing information in\r\n```",
              "createdAt": "2022-10-18T21:19:54Z",
              "updatedAt": "2022-10-18T21:27:59Z"
            },
            {
              "originalPosition": 275,
              "body": "```suggestion\r\nConnection ID with the real Client Connection ID before processing the packet further.\r\n```",
              "createdAt": "2022-10-18T21:24:37Z",
              "updatedAt": "2022-10-18T21:27:59Z"
            },
            {
              "originalPosition": 122,
              "body": "```suggestion\r\nThe REGISTER_CLIENT_CID and ACK_TARGET_CID capsule types include a Virtual\r\n```",
              "createdAt": "2022-10-18T21:25:51Z",
              "updatedAt": "2022-10-18T21:27:59Z"
            },
            {
              "originalPosition": 84,
              "body": "```suggestion\r\ncan be provided.\r\n```",
              "createdAt": "2022-10-18T21:26:10Z",
              "updatedAt": "2022-10-18T21:27:59Z"
            },
            {
              "originalPosition": 87,
              "body": "```suggestion\r\nIf the client is temporarily unresponsive or unreachable, the proxy might have\r\n```",
              "createdAt": "2022-10-18T21:26:22Z",
              "updatedAt": "2022-10-18T21:27:59Z"
            },
            {
              "originalPosition": 89,
              "body": "```suggestion\r\nthe stream mappings used for forwarding). If the client never learned about the closure, it\r\n```",
              "createdAt": "2022-10-18T21:26:54Z",
              "updatedAt": "2022-10-18T21:27:59Z"
            },
            {
              "originalPosition": 92,
              "body": "```suggestion\r\nand client<->proxy connection are still intact. The proxy will receive these\r\nforwarding mode packets, but won't have any state corresponding to the\r\n```",
              "createdAt": "2022-10-18T21:27:52Z",
              "updatedAt": "2022-10-18T21:27:59Z"
            }
          ]
        }
      ]
    },
    {
      "number": 64,
      "id": "PR_kwDOEHrEP85BDQJm",
      "title": "Unify around \"forwarded mode\"",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/64",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #63 ",
      "createdAt": "2022-10-18T21:41:08Z",
      "updatedAt": "2022-10-19T03:23:02Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "4bb7edf24c105d7f82fd3dda19cf201991f62d21",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "tfp/forwarded",
      "headRefOid": "b1419e860d7bd42818864825c303df54d9edfa11",
      "closedAt": "2022-10-19T03:23:02Z",
      "mergedAt": "2022-10-19T03:23:02Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "bb23e928b080acd6ac5e334651ec85f10368f7c1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85EWK_f",
          "commit": {
            "abbreviatedOid": "b1419e8"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-19T00:23:11Z",
          "updatedAt": "2022-10-19T00:23:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 66,
      "id": "PR_kwDOEHrEP85B171J",
      "title": "client communication of target-provided stateless reset token",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/66",
      "state": "MERGED",
      "author": "ehaydenr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #48, however, instead of converting stateless reset packets to a stream error, they are simply tunneled or forwarded to the client.\r\n\r\nA couple questions come to mind:\r\n\r\n**Should receipt of a stateless reset packet result in a stream error?**\r\n\r\n- Offers reliably delivered signal to the client that the connection is broken.\r\n- Allows the proxy to terminate the stream immediately and avoid having to consider handling of many stateless reset packets\r\n- What H3 error code? `H3_CONNECT_ERROR`?\r\n\r\n**If not a stream error, is tunneled _OR_ forwarded OK?**\r\n\r\n- If we require they be tunneled, does that make things easier for the client at no cost to the proxy?\r\n- Is there any reason why we wouldn't want the stateless reset packet sent \"in the clear\" (forwarded)?",
      "createdAt": "2022-10-30T23:19:01Z",
      "updatedAt": "2022-11-04T13:57:28Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "bb23e928b080acd6ac5e334651ec85f10368f7c1",
      "headRepository": "ehaydenr/quic-proxy",
      "headRefName": "stateless_reset",
      "headRefOid": "6da5331993d9dfb1bbe1c4bc51887f07d5919122",
      "closedAt": "2022-11-03T18:00:03Z",
      "mergedAt": "2022-11-03T18:00:03Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "1f05096db20a65f2139180f8a4a40e046e2483c2"
      },
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "I lean towards forwarding the stateless reset, rather than making this a stream error. That\u2019s effectively what the PR does, right?",
          "createdAt": "2022-10-31T03:46:26Z",
          "updatedAt": "2022-10-31T03:46:26Z"
        },
        {
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "body": "> That\u2019s effectively what the PR does, right?\r\n\r\nYes, that was the intention. It also allows for _either_ tunneled or forwarded. That seemed like the least prescriptive, but I can also see an argument for restricting it only being sent via the tunnel instead of being forwarded. ",
          "createdAt": "2022-10-31T14:48:30Z",
          "updatedAt": "2022-10-31T14:48:30Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah I could see that it might interfere with forwarding. Saying that it only tunnels would be a bit simpler. Only short header packets get forwarded, and this arguably doesn't meet that bar.",
          "createdAt": "2022-10-31T15:54:53Z",
          "updatedAt": "2022-10-31T15:54:53Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85FRnSD",
          "commit": {
            "abbreviatedOid": "d52813b"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-31T17:11:42Z",
          "updatedAt": "2022-10-31T17:11:43Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "@tfpauly, is the wording here strict enough to prohibit forwarding (as opposed to tunneling) of stateless reset packets? If not, any suggested language?",
              "createdAt": "2022-10-31T17:11:42Z",
              "updatedAt": "2022-10-31T17:11:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85FR6wt",
          "commit": {
            "abbreviatedOid": "d52813b"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-31T18:08:39Z",
          "updatedAt": "2022-10-31T18:08:39Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nit can send the packet to the client as a tunnelled datagram. Although Stateless Reset packets\r\nlook like short header packets, they are not technically short header packets and do not contain\r\nnegotiated connection IDs, and thus are not eligible for forwarded mode.\r\n```",
              "createdAt": "2022-10-31T18:08:39Z",
              "updatedAt": "2022-10-31T18:08:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85FR6z7",
          "commit": {
            "abbreviatedOid": "d52813b"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-31T18:08:47Z",
          "updatedAt": "2022-10-31T18:08:48Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "@ehaydenr how about this?",
              "createdAt": "2022-10-31T18:08:47Z",
              "updatedAt": "2022-10-31T18:08:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85FlbTL",
          "commit": {
            "abbreviatedOid": "6da5331"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-11-03T17:59:58Z",
          "updatedAt": "2022-11-03T17:59:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 72,
      "id": "PR_kwDOEHrEP85CN15Z",
      "title": "update forwarded mode migration guidance",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/72",
      "state": "MERGED",
      "author": "ehaydenr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "addresses #68 by clarifying active vs. passive migration guidance and describing how to change virtual CIDs without changing real CIDs",
      "createdAt": "2022-11-04T14:42:29Z",
      "updatedAt": "2023-03-07T23:59:18Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "1f05096db20a65f2139180f8a4a40e046e2483c2",
      "headRepository": "ehaydenr/quic-proxy",
      "headRefName": "network_paths",
      "headRefOid": "3cfbd96bb2914ec3d1abfbe366c0027b770938bf",
      "closedAt": "2023-03-07T23:59:18Z",
      "mergedAt": "2023-03-07T23:59:18Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "8401ab94dba002899df1bd727c8398f7bdbb82eb"
      },
      "comments": [
        {
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "body": "I think one of the challenges with doing CLOSE_ first is if you do CLOSE_CLIENT_CID then the proxy thinks it needs to remove state for port reuse too",
          "createdAt": "2022-11-04T19:49:59Z",
          "updatedAt": "2022-11-04T19:49:59Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85FrG96",
          "commit": {
            "abbreviatedOid": "fb2bf49"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I like re-sending the REGISTER_CLIENT_CID with a new VCID, but it seems a bit odd to send a REGISTER_TARGET_CID that's duplicated as a signal to get a new VCID from the proxy.\r\n\r\nI see a few options:\r\n- Keep this proposal as-is\r\n- Before re-registering, have the client send explicit CLOSE_ messages for the old ones. This gets you to a \"restarted\" state\r\n- Client sends a new REGISTER_CLIENT, but not a REGISTER_TARGET, and the proxy sending a new ACK_TARGET with a new VCID uninitiated.\r\n\r\nNot sure which I prefer...",
          "createdAt": "2022-11-04T17:20:00Z",
          "updatedAt": "2022-11-04T17:24:42Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nit has received a new Target Connection ID for the target. In order to change\r\nthe connection ID bytes on the wire, a client can update a previously advertised Virtual Client\r\nConnection ID by sending a new REGISTER_CLIENT_CID with the same Connection ID,\r\nbut a different Virtual Connection ID. Similarly, the client may solicit a new\r\nVirtual Target Connection ID by sending a REGISTER_TARGET_CID capsule with\r\na previously registered Target Connection ID. Clients are responsible for\r\nchanging Virtual Connection IDs when the HTTP stream's network path changes to\r\navoid linkability across network paths. Note that initial\r\nREGISTER_CLIENT_CID capsules MAY be sent prior to receiving an HTTP response\r\nfrom the proxy.\r\n```",
              "createdAt": "2022-11-04T17:20:00Z",
              "updatedAt": "2022-11-04T17:24:42Z"
            },
            {
              "originalPosition": 49,
              "body": "```suggestion\r\nWhen operating in forwarded mode, the proxy reconfigures or removes forwarding\r\nrules as the network path between the client and proxy changes. In the event of\r\npassive migration, the proxy automatically reconfigures forwarding rules to use\r\nthe latest active and validated network path for the HTTP stream. In the event of\r\nactive migration, the proxy removes forwarding rules in order to not send\r\npackets with the same connection ID bytes over multiple network paths. After\r\ninitiating active migration, clients are no longer able to send forwarded mode\r\npackets since the proxy will have removed forwarding rules. Clients can proceed with\r\ntunnelled mode or can request new forwarding rules via REGISTER_CLIENT_CID and\r\nREGISTER_TARGET_CID capsules. Each of these capsules will contain new virtual\r\nconnection IDs to prevent packets with the same connection ID bytes being used\r\nover multiple network paths. Note that the Client Connection ID and Target\r\nConnection ID can stay the same while the Virtual Target Connection ID and\r\nVirtual Client Connection ID change.\r\n```",
              "createdAt": "2022-11-04T17:22:05Z",
              "updatedAt": "2022-11-04T17:24:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85PQmZn",
          "commit": {
            "abbreviatedOid": "3cfbd96"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-07T23:59:11Z",
          "updatedAt": "2023-03-07T23:59:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 73,
      "id": "PR_kwDOEHrEP85CN3sX",
      "title": "allow clients to send capsules before HTTP response",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/73",
      "state": "MERGED",
      "author": "ehaydenr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "addresses #71 ",
      "createdAt": "2022-11-04T14:47:42Z",
      "updatedAt": "2022-11-04T15:26:53Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "1f05096db20a65f2139180f8a4a40e046e2483c2",
      "headRepository": "ehaydenr/quic-proxy",
      "headRefName": "contradict",
      "headRefOid": "718fbf63b15c091d9db561451dd7cd09b9ec007f",
      "closedAt": "2022-11-04T15:25:48Z",
      "mergedAt": "2022-11-04T15:25:48Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "5ce4e8681e46015af42c3e136888ebfe1fa5c214"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85Fqcjm",
          "commit": {
            "abbreviatedOid": "718fbf6"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-11-04T15:25:43Z",
          "updatedAt": "2022-11-04T15:25:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 75,
      "id": "PR_kwDOEHrEP85LyeA5",
      "title": "Mention using PINGs to keep tunnels alive",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/75",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Closes #69",
      "createdAt": "2023-03-10T17:56:22Z",
      "updatedAt": "2023-03-10T18:30:03Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "17c2b3c631f7a4b516f21b429d30c24f21f7d469",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "tfpauly-patch-6",
      "headRefOid": "45b38a528940ab8cff1b20ef01b9f24f1f066fe3",
      "closedAt": "2023-03-10T18:30:02Z",
      "mergedAt": "2023-03-10T18:30:02Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "6ec2889361d5ff2aaa880bbbff1c125c791d47fb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85PmDk3",
          "commit": {
            "abbreviatedOid": "2306e5e"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-10T18:10:11Z",
          "updatedAt": "2023-03-10T18:15:49Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nlong periods of time in which no ack-eliciting packets (see {{Section 2 of !QUIC-RETRANSMISSION=RFC9002}}) are exchanged\r\n```",
              "createdAt": "2023-03-10T18:10:12Z",
              "updatedAt": "2023-03-10T18:15:50Z"
            },
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nvalues for the client-to-proxy QUIC connection (see {{Section 10.1 of QUIC}}),\r\n```",
              "createdAt": "2023-03-10T18:15:18Z",
              "updatedAt": "2023-03-10T18:15:50Z"
            },
            {
              "originalPosition": 11,
              "body": "Why not in the other direction too?",
              "createdAt": "2023-03-10T18:15:45Z",
              "updatedAt": "2023-03-10T18:15:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85PmFeO",
          "commit": {
            "abbreviatedOid": "2306e5e"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-10T18:14:53Z",
          "updatedAt": "2023-03-10T18:17:18Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "The intent is good, but maybe you just want to defer to QUIC's liveness testing text (https://datatracker.ietf.org/doc/html/rfc9000#section-10.1.1) as to how exactly to do it? ",
              "createdAt": "2023-03-10T18:14:54Z",
              "updatedAt": "2023-03-10T18:17:18Z"
            },
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nlong periods of time in which no stream data or datagrams are exchanged\r\n```\r\n\r\nalternatively maybe just STREAM or DATAGRAM frames",
              "createdAt": "2023-03-10T18:15:30Z",
              "updatedAt": "2023-03-10T18:17:18Z"
            },
            {
              "originalPosition": 9,
              "body": "Rather than refer to the TP, probably better to mention the effective idle timeout for the connection",
              "createdAt": "2023-03-10T18:17:11Z",
              "updatedAt": "2023-03-10T18:17:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85PmGV0",
          "commit": {
            "abbreviatedOid": "2306e5e"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-10T18:17:51Z",
          "updatedAt": "2023-03-10T18:17:52Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I like this as well but was too lazy to offer it as a third suggestion",
              "createdAt": "2023-03-10T18:17:51Z",
              "updatedAt": "2023-03-10T18:17:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85PmH4l",
          "commit": {
            "abbreviatedOid": "dc5e6ba"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-10T18:22:32Z",
          "updatedAt": "2023-03-10T18:22:32Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I guess the proxy _could_, but if it's not tracking activity, it isn't aware that the client actually isn't idle (and if it is tracking, it doesn't need the keep alive). The client is the only one who knows about all of the connections.",
              "createdAt": "2023-03-10T18:22:32Z",
              "updatedAt": "2023-03-10T18:22:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85PmIUx",
          "commit": {
            "abbreviatedOid": "dc5e6ba"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-10T18:23:50Z",
          "updatedAt": "2023-03-10T18:23:51Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nwhich can be done using a PING frame or another ack-eliciting frame as described\r\nin {{Section 10.1.1 of QUIC}}.\r\n```",
              "createdAt": "2023-03-10T18:23:50Z",
              "updatedAt": "2023-03-10T18:23:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85PmIrz",
          "commit": {
            "abbreviatedOid": "5885d7d"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-10T18:25:03Z",
          "updatedAt": "2023-03-10T18:25:03Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEHrEP85PmItT",
          "commit": {
            "abbreviatedOid": "2306e5e"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-10T18:25:08Z",
          "updatedAt": "2023-03-10T18:25:08Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Can you elaborate? What's preventing the client from timing out?",
              "createdAt": "2023-03-10T18:25:08Z",
              "updatedAt": "2023-03-10T18:25:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85PmJHl",
          "commit": {
            "abbreviatedOid": "5885d7d"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-10T18:26:34Z",
          "updatedAt": "2023-03-10T18:26:35Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nbetween the client and proxy. If these periods extend beyond the effective idle\r\ntimeout for the client-to-proxy QUIC connection (see {{Section 10.1 of QUIC}}),\r\n```",
              "createdAt": "2023-03-10T18:26:35Z",
              "updatedAt": "2023-03-10T18:26:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85PmJdo",
          "commit": {
            "abbreviatedOid": "45b38a5"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-10T18:27:41Z",
          "updatedAt": "2023-03-10T18:27:47Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "The client is sending forwarded packets and it knows it is sending them actively \u2014 if it times out, that is the client's own problem (and it can just send PINGs to keep stuff alive itself).",
              "createdAt": "2023-03-10T18:27:41Z",
              "updatedAt": "2023-03-10T18:27:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85PmJgT",
          "commit": {
            "abbreviatedOid": "45b38a5"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-10T18:27:49Z",
          "updatedAt": "2023-03-10T18:27:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEHrEP85PmJil",
          "commit": {
            "abbreviatedOid": "2306e5e"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-10T18:27:57Z",
          "updatedAt": "2023-03-10T18:27:57Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Done!",
              "createdAt": "2023-03-10T18:27:57Z",
              "updatedAt": "2023-03-10T18:27:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 76,
      "id": "PR_kwDOEHrEP85Lyhj4",
      "title": "Explain ECN handling in forwarded mode",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/76",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #70",
      "createdAt": "2023-03-10T18:08:21Z",
      "updatedAt": "2023-03-10T18:29:50Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "17c2b3c631f7a4b516f21b429d30c24f21f7d469",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "tfpauly-patch-7",
      "headRefOid": "c543e0fb73fc60a35fece3ab8d290ee61785ec38",
      "closedAt": "2023-03-10T18:29:50Z",
      "mergedAt": "2023-03-10T18:29:50Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "997dac6d18be47895614171ff2f9a76a34801234"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85PmGPp",
          "commit": {
            "abbreviatedOid": "0949fc5"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-10T18:17:33Z",
          "updatedAt": "2023-03-10T18:17:37Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nforwarded packets in both directions, to allow ECN to function end-to-end. If the proxy does not\r\npreserve ECN markings, it MUST set ECN marks to zero on the IP headers it genrates.\r\n```",
              "createdAt": "2023-03-10T18:17:33Z",
              "updatedAt": "2023-03-10T18:17:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85PmJIn",
          "commit": {
            "abbreviatedOid": "ecee51c"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-10T18:26:38Z",
          "updatedAt": "2023-03-10T18:26:38Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEHrEP85PmJrY",
          "commit": {
            "abbreviatedOid": "ecee51c"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-10T18:28:24Z",
          "updatedAt": "2023-03-10T18:28:24Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nthe proxy replaces IP headers for packets exchanged between the client and target;\r\n```",
              "createdAt": "2023-03-10T18:28:24Z",
              "updatedAt": "2023-03-10T18:28:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 77,
      "id": "PR_kwDOEHrEP85Lypib",
      "title": "add Eric Rosenberg as an author",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/77",
      "state": "MERGED",
      "author": "ehaydenr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-03-10T18:34:43Z",
      "updatedAt": "2023-03-10T18:35:46Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "6ec2889361d5ff2aaa880bbbff1c125c791d47fb",
      "headRepository": "ehaydenr/quic-proxy",
      "headRefName": "author",
      "headRefOid": "3fc0cd443cad4d34dc2ff86a36b37fc6ddcb68e2",
      "closedAt": "2023-03-10T18:35:34Z",
      "mergedAt": "2023-03-10T18:35:34Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "4c6685f371ae6bc1977c4dfd8a0bceed4a747c68"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85PmMhB",
          "commit": {
            "abbreviatedOid": "3fc0cd4"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-10T18:35:27Z",
          "updatedAt": "2023-03-10T18:35:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 78,
      "id": "PR_kwDOEHrEP85LytTa",
      "title": "add forwarded mode packets to example",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/78",
      "state": "MERGED",
      "author": "ehaydenr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "closes #67 ",
      "createdAt": "2023-03-10T18:45:38Z",
      "updatedAt": "2023-03-10T19:58:58Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "4c6685f371ae6bc1977c4dfd8a0bceed4a747c68",
      "headRepository": "ehaydenr/quic-proxy",
      "headRefName": "examples",
      "headRefOid": "100ddf3f240b63c23e8d31f818d0f0c77e2d44e8",
      "closedAt": "2023-03-10T19:58:35Z",
      "mergedAt": "2023-03-10T19:58:35Z",
      "mergedBy": "ehaydenr",
      "mergeCommit": {
        "oid": "28d026341998a4075e099ad9ef9707d986401379"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85PmSm7",
          "commit": {
            "abbreviatedOid": "9ae1642"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-10T18:48:35Z",
          "updatedAt": "2023-03-10T18:49:06Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\n           <--------  UDP Datagram\r\n                        Payload = Forwarded QUIC SH packet\r\n```",
              "createdAt": "2023-03-10T18:48:35Z",
              "updatedAt": "2023-03-10T18:49:06Z"
            },
            {
              "originalPosition": 28,
              "body": "```suggestion\r\nUDP Datagram                     -------->\r\n  Payload = Forwarded QUIC SH packet\r\n```",
              "createdAt": "2023-03-10T18:49:03Z",
              "updatedAt": "2023-03-10T18:49:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85PmTsK",
          "commit": {
            "abbreviatedOid": "9ae1642"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-10T18:50:02Z",
          "updatedAt": "2023-03-10T18:50:02Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Maybe we should just move this down to later when the client is forwarding...? Since we generally don't have server SH packets yet?",
              "createdAt": "2023-03-10T18:50:02Z",
              "updatedAt": "2023-03-10T18:50:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85PmVrH",
          "commit": {
            "abbreviatedOid": "9ae1642"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-10T18:53:31Z",
          "updatedAt": "2023-03-10T18:53:31Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "@ehaydenr what do you think?",
              "createdAt": "2023-03-10T18:53:31Z",
              "updatedAt": "2023-03-10T18:53:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85PmWes",
          "commit": {
            "abbreviatedOid": "9ae1642"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-10T18:55:05Z",
          "updatedAt": "2023-03-10T18:55:06Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Does this capture what you're suggesting? 100ddf3f240b63c23e8d31f818d0f0c77e2d44e8",
              "createdAt": "2023-03-10T18:55:05Z",
              "updatedAt": "2023-03-10T18:55:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85PmqPF",
          "commit": {
            "abbreviatedOid": "100ddf3"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-10T19:58:20Z",
          "updatedAt": "2023-03-10T19:58:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 87,
      "id": "PR_kwDOEHrEP85ch6mr",
      "title": "Proposal: Packet Transforms",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/87",
      "state": "MERGED",
      "author": "bemasc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-11T15:10:22Z",
      "updatedAt": "2023-12-06T16:33:29Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "design-team",
      "baseRefOid": "56dd56d2b2e8a8ac341866cd74ce6323ddca04c4",
      "headRepository": "bemasc/draft-ietf-masque-quic-proxy",
      "headRefName": "bemasc-scramble",
      "headRefOid": "aa04a1d13f5d388c68f00a0a86d4197c5be9abdd",
      "closedAt": "2023-12-06T16:33:29Z",
      "mergedAt": "2023-12-06T16:33:29Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "d477ed7b78a5a89b19b9d92e3e5b864694fa299c"
      },
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Let's add some examples in this PR.",
          "createdAt": "2023-10-11T16:48:11Z",
          "updatedAt": "2023-10-11T16:48:11Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Based on our discussion yesterday I believe this is ready to merge.",
          "createdAt": "2023-10-19T15:31:50Z",
          "updatedAt": "2023-10-19T15:31:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85jodc4",
          "commit": {
            "abbreviatedOid": "7a09db3"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-11T15:20:40Z",
          "updatedAt": "2023-10-11T15:20:41Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "What is considered \"large\" in this case?",
              "createdAt": "2023-10-11T15:20:41Z",
              "updatedAt": "2023-10-11T15:20:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85jogXd",
          "commit": {
            "abbreviatedOid": "7a09db3"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-11T15:23:06Z",
          "updatedAt": "2023-10-11T15:23:07Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "I _think_ the answer is no, but does any state need to be maintained across packet transforms other than k1 and k2?",
              "createdAt": "2023-10-11T15:23:06Z",
              "updatedAt": "2023-10-11T15:23:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85jo5QK",
          "commit": {
            "abbreviatedOid": "7a09db3"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-11T15:41:51Z",
          "updatedAt": "2023-10-11T15:41:51Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "Correct, packets are processed 100% independently.",
              "createdAt": "2023-10-11T15:41:51Z",
              "updatedAt": "2023-10-11T15:41:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85jpA-2",
          "commit": {
            "abbreviatedOid": "7a09db3"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-11T15:51:08Z",
          "updatedAt": "2023-10-11T15:51:08Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "I don't have a clear answer for that.  We don't have a very specific model of timing attacks, which are potentially extremely powerful.\r\n\r\nI think \"scramble\" is probably worth defining, but we should certainly take care to avoid over-promising.",
              "createdAt": "2023-10-11T15:51:08Z",
              "updatedAt": "2023-10-11T15:51:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85jpJlD",
          "commit": {
            "abbreviatedOid": "7a09db3"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-11T15:59:54Z",
          "updatedAt": "2023-10-11T15:59:55Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Should we explain a bit more which kinds of correlation are possible here? To explain that trivial correlation isn't possible, but timing/size or active attacks are possible?",
              "createdAt": "2023-10-11T15:59:54Z",
              "updatedAt": "2023-10-11T15:59:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85jpQqc",
          "commit": {
            "abbreviatedOid": "7a09db3"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-11T16:08:11Z",
          "updatedAt": "2023-10-11T16:08:11Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "Let's add an example of what the whole header looks like",
              "createdAt": "2023-10-11T16:08:11Z",
              "updatedAt": "2023-10-11T16:08:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85jpQyL",
          "commit": {
            "abbreviatedOid": "7a09db3"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-11T16:08:21Z",
          "updatedAt": "2023-10-11T16:08:21Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "Let's add an example of what the whole header looks like",
              "createdAt": "2023-10-11T16:08:21Z",
              "updatedAt": "2023-10-11T16:08:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85jpT-n",
          "commit": {
            "abbreviatedOid": "7a09db3"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-11T16:11:18Z",
          "updatedAt": "2023-10-11T16:11:19Z",
          "comments": [
            {
              "originalPosition": 149,
              "body": "```suggestion\r\nprocessed by the \"scramble\" transform. As such future versions are defined, new transforms\r\ncan be defined to handle forwarding for those packets.\r\n```",
              "createdAt": "2023-10-11T16:11:19Z",
              "updatedAt": "2023-10-11T16:11:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85jpWrA",
          "commit": {
            "abbreviatedOid": "7a09db3"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-11T16:12:59Z",
          "updatedAt": "2023-10-11T16:12:59Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "Let's spell out the fact that both the client and server generate their own key and sends it to the other side",
              "createdAt": "2023-10-11T16:12:59Z",
              "updatedAt": "2023-10-11T16:12:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85jpXoy",
          "commit": {
            "abbreviatedOid": "7a09db3"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-11T16:14:08Z",
          "updatedAt": "2023-10-11T16:14:08Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "On call, discussed having these be derived off of a common key",
              "createdAt": "2023-10-11T16:14:08Z",
              "updatedAt": "2023-10-11T16:14:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85jpgoo",
          "commit": {
            "abbreviatedOid": "7a09db3"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-11T16:26:28Z",
          "updatedAt": "2023-10-11T16:26:28Z",
          "comments": [
            {
              "originalPosition": 149,
              "body": "@DavidSchinazi How about this?\r\n\r\n```suggestion\r\nNOTE: The security of this arrangement relies on the 16 bytes following the\r\nConnection ID (i.e., the `sample`) being pseudorandom.  This is guaranteed\r\nin QUICv1, but future versions of QUIC might not maintain this arrangement.\r\nThe \"scramble\" transform MUST NOT be used with any QUIC version that\r\ndoes not guarantee this property.\r\n```",
              "createdAt": "2023-10-11T16:26:28Z",
              "updatedAt": "2023-10-11T16:54:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85jpkMn",
          "commit": {
            "abbreviatedOid": "7a09db3"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-11T16:30:13Z",
          "updatedAt": "2023-10-11T16:30:14Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Although saving the space in the header probably doesn't help. So keep this for now?",
              "createdAt": "2023-10-11T16:30:14Z",
              "updatedAt": "2023-10-11T16:30:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85jprlc",
          "commit": {
            "abbreviatedOid": "7a09db3"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-11T16:39:02Z",
          "updatedAt": "2023-10-11T16:39:02Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "This syntax is perhaps too customized.  Let's try to stick closer to the style of RFC 9001.",
              "createdAt": "2023-10-11T16:39:02Z",
              "updatedAt": "2023-10-11T16:39:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85jpsSB",
          "commit": {
            "abbreviatedOid": "7a09db3"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-11T16:39:58Z",
          "updatedAt": "2023-10-11T16:39:58Z",
          "comments": [
            {
              "originalPosition": 144,
              "body": "Let's also write the same list in reverse order to decrypt",
              "createdAt": "2023-10-11T16:39:58Z",
              "updatedAt": "2023-10-11T16:39:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85kdLYu",
          "commit": {
            "abbreviatedOid": "7a09db3"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T15:10:52Z",
          "updatedAt": "2023-10-18T15:10:52Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "I've adjusted this text to remove mention of \"large numbers\" and \"statistical analysis\", neither of which is required when there are few users of a proxy.",
              "createdAt": "2023-10-18T15:10:52Z",
              "updatedAt": "2023-10-18T15:10:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85kdL0F",
          "commit": {
            "abbreviatedOid": "7a09db3"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T15:11:27Z",
          "updatedAt": "2023-10-18T15:11:28Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "I've added some text pointing out that the choice of transform makes a difference here.",
              "createdAt": "2023-10-18T15:11:27Z",
              "updatedAt": "2023-10-18T15:11:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85kdL3g",
          "commit": {
            "abbreviatedOid": "7a09db3"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T15:11:32Z",
          "updatedAt": "2023-10-18T15:11:32Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "Done",
              "createdAt": "2023-10-18T15:11:32Z",
              "updatedAt": "2023-10-18T15:11:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85kdMFb",
          "commit": {
            "abbreviatedOid": "7a09db3"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T15:11:42Z",
          "updatedAt": "2023-10-18T15:11:43Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "Done",
              "createdAt": "2023-10-18T15:11:42Z",
              "updatedAt": "2023-10-18T15:11:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85kdMb4",
          "commit": {
            "abbreviatedOid": "7a09db3"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T15:11:56Z",
          "updatedAt": "2023-10-18T15:11:56Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "Done",
              "createdAt": "2023-10-18T15:11:56Z",
              "updatedAt": "2023-10-18T15:11:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85kdMxF",
          "commit": {
            "abbreviatedOid": "7a09db3"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T15:12:09Z",
          "updatedAt": "2023-10-18T15:12:09Z",
          "comments": [
            {
              "originalPosition": 144,
              "body": "Done (with some compactification).",
              "createdAt": "2023-10-18T15:12:09Z",
              "updatedAt": "2023-10-18T15:12:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85keA0v",
          "commit": {
            "abbreviatedOid": "217489c"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T16:35:20Z",
          "updatedAt": "2023-10-18T16:35:21Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "Let's change this to note that the client doesn't have to use forwarded mode if the proxy doesn't support any of the offered transforms.",
              "createdAt": "2023-10-18T16:35:21Z",
              "updatedAt": "2023-10-18T16:35:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85keCrY",
          "commit": {
            "abbreviatedOid": "23ee057"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T16:38:11Z",
          "updatedAt": "2023-10-18T16:38:11Z",
          "comments": [
            {
              "originalPosition": 174,
              "body": "This needs a little bit more work due to the hypothetical use of CCM_8 in QUICv1.",
              "createdAt": "2023-10-18T16:38:11Z",
              "updatedAt": "2023-10-18T16:38:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85kfCVo",
          "commit": {
            "abbreviatedOid": "217489c"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T18:45:10Z",
          "updatedAt": "2023-10-18T18:45:10Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "Done",
              "createdAt": "2023-10-18T18:45:10Z",
              "updatedAt": "2023-10-18T18:45:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85kfCY8",
          "commit": {
            "abbreviatedOid": "23ee057"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T18:45:19Z",
          "updatedAt": "2023-10-18T18:45:19Z",
          "comments": [
            {
              "originalPosition": 174,
              "body": "Done",
              "createdAt": "2023-10-18T18:45:19Z",
              "updatedAt": "2023-10-18T18:45:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85kfD_W",
          "commit": {
            "abbreviatedOid": "4122011"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-18T18:49:03Z",
          "updatedAt": "2023-10-18T18:49:04Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "@tfpauly If the proxy sends \"?0\", does that mean the proxy does or does not want to receive the REGISTER_*_CID capsules?\r\n\r\nThis is relevant because we need to decide how the proxy says \"I don't support any of the offered transforms but please still send me REGISTER_*_CID capsules for multiplexing\".",
              "createdAt": "2023-10-18T18:49:03Z",
              "updatedAt": "2023-10-18T18:49:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85kh0Kk",
          "commit": {
            "abbreviatedOid": "f009a66"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-19T03:18:01Z",
          "updatedAt": "2023-10-19T03:18:01Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "The text currently says this:\r\n\r\n> If the client wants to enable QUIC packet forwarding for this request, it sets the value to \"?1\". If it doesn't want to enable forwarding, but instead only provide information about QUIC Connection IDs for the purpose of allowing the proxy to share a target-facing socket, it sets the value to \"?0\".\r\n\r\nSo if you don't support any QUIC-aware, you don't include the header\r\nIf you support multiplexing only, you send ?0\r\nIf you support forwarding, you send ?1",
              "createdAt": "2023-10-19T03:18:01Z",
              "updatedAt": "2023-10-19T03:18:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85kmIXx",
          "commit": {
            "abbreviatedOid": "4122011"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-19T13:17:36Z",
          "updatedAt": "2023-10-19T13:17:36Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "OK, thanks.  That's the for client, but I see that the proxy-side text is meant to convey the same idea.",
              "createdAt": "2023-10-19T13:17:36Z",
              "updatedAt": "2023-10-19T13:17:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85lMk_N",
          "commit": {
            "abbreviatedOid": "d56f8b8"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-25T16:27:01Z",
          "updatedAt": "2023-10-25T16:30:32Z",
          "comments": [
            {
              "originalPosition": 191,
              "body": "```suggestion\r\n      scramble-key=:abc...789=:\r\n```",
              "createdAt": "2023-10-25T16:27:02Z",
              "updatedAt": "2023-10-25T16:30:32Z"
            },
            {
              "originalPosition": 202,
              "body": "```suggestion\r\n                            scramble-key=:ABC...321=:\r\n```",
              "createdAt": "2023-10-25T16:27:10Z",
              "updatedAt": "2023-10-25T16:30:32Z"
            },
            {
              "originalPosition": 151,
              "body": "Can we phrase this in terms of the AES-CTR primitive instead of manually spelling out CTR in terms of ECB?",
              "createdAt": "2023-10-25T16:29:52Z",
              "updatedAt": "2023-10-25T16:30:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85lM84T",
          "commit": {
            "abbreviatedOid": "16ecc88"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-25T17:25:11Z",
          "updatedAt": "2023-10-25T17:25:11Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "We can, but I haven't found a reference for an AES-CTR primitive so we would still need to define it.  Also, if the primitive \"performs encryption\" (vs. \"provides a keystream\") then there would be some extra complexity in explaining how to deal with the first byte.\r\n\r\nThere's an additional issue that AES-CTR is conventionally defined with an IV and a counter that starts at zero, but here we need the counter to (1) start at some specified value (not zero) and (2) increment as a uint128, not a uint32 or uint64 (due to the potential for the random initial counter value to be near MAX_UINT32 or MAX_UINT64).  (Technically we could also treat it as a uint32 and allow it to wrap on overflow, but a pre-packaged AES-CTR implementation should fail rather than wrap, to avoid the two-time pad problem.)\r\n\r\nAnyway, feel free to suggest an alternative formulation if you think you see a clearer way.",
              "createdAt": "2023-10-25T17:25:11Z",
              "updatedAt": "2023-10-25T17:25:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85lNVI-",
          "commit": {
            "abbreviatedOid": "16ecc88"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-25T18:21:16Z",
          "updatedAt": "2023-10-25T18:21:16Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "The first byte issue could be solved by doing something like\r\n```\r\ncleartext = packet[0] | packet[L+17:]`\r\nciphertext = AES-CTR(plaintext)\r\nencrypted_packet = ciphertext[0] | packet[1:L] | ciphertext[1:]\r\n```\r\nit's not necessarily how this would be implemented, but it's a lot easier to reason about\r\n\r\nCan you elaborate on the custom counter needed here? I would assume that we're fine with the counter starting at 0 and the nonce being 16 bytes - in that construction you XOR the nonce and counter to create the IV\r\n",
              "createdAt": "2023-10-25T18:21:16Z",
              "updatedAt": "2023-10-25T18:21:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85lOKbX",
          "commit": {
            "abbreviatedOid": "d56f8b8"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-25T20:37:34Z",
          "updatedAt": "2023-10-25T20:37:35Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "OK, I've updated the PR to pull in a formal definition of AES-CTR from NIST, with appropriate text to specify which variation of AES-CTR we're using, and assign a standard syntax for it.",
              "createdAt": "2023-10-25T20:37:35Z",
              "updatedAt": "2023-10-25T20:37:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85lOs5N",
          "commit": {
            "abbreviatedOid": "be7a902"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, this is way easier to reason about",
          "createdAt": "2023-10-25T22:39:58Z",
          "updatedAt": "2023-10-25T22:39:58Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEHrEP85nSZHP",
          "commit": {
            "abbreviatedOid": "c9a45dc"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-15T20:13:56Z",
          "updatedAt": "2023-11-15T20:13:56Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "HTTP editorial style is not to use ABNF, so you can save yourself the effort here and just delete the whole  block",
              "createdAt": "2023-11-15T20:13:56Z",
              "updatedAt": "2023-11-15T20:13:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 89,
      "id": "PR_kwDOEHrEP85d5CXJ",
      "title": "Note that the QUIC bit cannot be used with forwarding mode",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/89",
      "state": "OPEN",
      "author": "bemasc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-26T16:56:23Z",
      "updatedAt": "2023-10-26T19:53:24Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "56dd56d2b2e8a8ac341866cd74ce6323ddca04c4",
      "headRepository": "bemasc/draft-ietf-masque-quic-proxy",
      "headRefName": "bemasc-grease-quic-bit",
      "headRefOid": "53095bd2b761daa9e430152c7c6ffe2e5286a788",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "You might want to cite or defer to the managability draft that is related - https://www.rfc-editor.org/rfc/rfc9312.html#section-3.1",
          "createdAt": "2023-10-26T17:06:06Z",
          "updatedAt": "2023-10-26T17:06:06Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue Thanks, that's interesting.  I couldn't figure out how to reference it here though.\r\n\r\nIt occurs to me that we might also want to say something about disabling the Spin Bit, which is normally a bit dangerous in forwarding mode because it reveals the end-to-end latency of each Connection ID.  However, I'm not sure exactly what the advice would be, especially because it's possibly safe when \"scramble\" is enabled (#87).",
          "createdAt": "2023-10-26T17:25:33Z",
          "updatedAt": "2023-10-26T17:25:33Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "I was thinking something simple like - \"The considerations of Identifying QUIC traffic in Section 3.1 of QUIC-MANAGEABILTIY] apply to forwarding proxies. Specifically, ... <the text you already have>\" \r\n\r\nbut if that doesn't help, or feels shoehorned, feel free to ignore",
          "createdAt": "2023-10-26T19:49:05Z",
          "updatedAt": "2023-10-26T19:49:17Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's tricky because the proxy is both an endpoint and a middlebox (for QUIC).  QUIC-MANAGEABILITY doesn't apply to endpoints.  In the proxy's role as a middlebox, there is no protocol identification involved because (formally) only QUIC can flow through the forwarder, so QUIC-MANAGEABILITY doesn't apply there either.\r\n\r\nThe weird thing is that the forwarder shares a 5-tuple with the proxy endpoint, so some of the protocol identification restrictions on middleboxes spill over onto the proxy's QUIC endpoint.",
          "createdAt": "2023-10-26T19:53:24Z",
          "updatedAt": "2023-10-26T19:53:24Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 90,
      "id": "PR_kwDOEHrEP85eQbIR",
      "title": "Update HTTP field registry",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/90",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-31T17:04:27Z",
      "updatedAt": "2023-10-31T18:11:06Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "56dd56d2b2e8a8ac341866cd74ce6323ddca04c4",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "tfpauly-patch-8",
      "headRefOid": "7d2e83bdc6e083d239c4ec4c7a46aa7913eec3ac",
      "closedAt": "2023-10-31T18:11:06Z",
      "mergedAt": "2023-10-31T18:11:06Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "afc9b983a35891530afe45bc35f1b7b5055b2bde"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85lvP1z",
          "commit": {
            "abbreviatedOid": "7d2e83b"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-31T17:29:16Z",
          "updatedAt": "2023-10-31T17:29:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 95,
      "id": "PR_kwDOEHrEP85hzNtW",
      "title": "IANA registries for parameter names and transform names",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/95",
      "state": "MERGED",
      "author": "mirjak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "fixes #94 \r\n\r\nThis PR creates two registries, however, not sure we really need the parameter names one?\r\n\r\nBoth registrations are proposed with Specification Requires Policy but I could also see reasons to actually go for IETF Review. Any views?\r\n\r\nFollowing the model in https://www.iana.org/assignments/http-parameters/http-parameters.xhtml both registries have a \"Description\" and \"Notes\" section, however, not sure we really need those.",
      "createdAt": "2023-12-12T14:36:33Z",
      "updatedAt": "2024-01-03T16:12:01Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "design-team",
      "baseRefOid": "d477ed7b78a5a89b19b9d92e3e5b864694fa299c",
      "headRepository": "mirjak/draft-ietf-masque-quic-proxy",
      "headRefName": "patch-1",
      "headRefOid": "84b3c98186ca3ccb79fd1e7abc837afd75f36007",
      "closedAt": "2024-01-03T16:12:01Z",
      "mergedAt": "2024-01-03T16:12:01Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "383b520d97d459f9765397ea3a64447e8e831d7b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85p9mnG",
          "commit": {
            "abbreviatedOid": "9f45823"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-12T15:18:56Z",
          "updatedAt": "2023-12-12T15:18:56Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "```suggestion\r\nin <[](https://www.iana.org/assignments/masque/masque.xhtml)>\r\n```",
              "createdAt": "2023-12-12T15:18:56Z",
              "updatedAt": "2023-12-12T15:18:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85p-wf3",
          "commit": {
            "abbreviatedOid": "86ab8eb"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-12T17:19:14Z",
          "updatedAt": "2023-12-12T17:20:15Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "These are parameters specifically to `proxy-quic-forwarding`, right? Perhaps we should call this all \"Proxy QUIC Forwarding Parameter Names\", etc?",
              "createdAt": "2023-12-12T17:19:14Z",
              "updatedAt": "2023-12-12T17:20:15Z"
            },
            {
              "originalPosition": 55,
              "body": "```suggestion\r\n| scramble       | AES-128 size-maintaining scramble of bytes  | This Document | Section {{scramble-transform}} |\r\n```",
              "createdAt": "2023-12-12T17:20:12Z",
              "updatedAt": "2023-12-12T17:20:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85rcMz5",
          "commit": {
            "abbreviatedOid": "6c15326"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-03T16:07:34Z",
          "updatedAt": "2024-01-03T16:07:35Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "```suggestion\r\n## Proxy QUIC Forwarding Parameter Names\r\n```",
              "createdAt": "2024-01-03T16:07:35Z",
              "updatedAt": "2024-01-03T16:07:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85rcPwU",
          "commit": {
            "abbreviatedOid": "6c15326"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-03T16:09:26Z",
          "updatedAt": "2024-01-03T16:09:26Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "```suggestion\r\nThis document establishes a new registry, \"Proxy QUIC Forwarding Parameter Names\",\r\nfor parameter names to use with the `Proxy-QUIC-Forwarding` header field,\r\n```",
              "createdAt": "2024-01-03T16:09:26Z",
              "updatedAt": "2024-01-03T16:09:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85rcP8i",
          "commit": {
            "abbreviatedOid": "6c15326"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-03T16:09:43Z",
          "updatedAt": "2024-01-03T16:09:43Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "```suggestion\r\n{: #iana-parameter-names-table title=\"Initial Proxy QUIC Forwarding Parameter Names\"}\r\n```",
              "createdAt": "2024-01-03T16:09:43Z",
              "updatedAt": "2024-01-03T16:09:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85rcRYT",
          "commit": {
            "abbreviatedOid": "84b3c98"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-03T16:11:48Z",
          "updatedAt": "2024-01-03T16:11:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 97,
      "id": "PR_kwDOEHrEP85jJ-ou",
      "title": "Handle versioning of scramble",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/97",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Design team"
      ],
      "body": "Closes #96",
      "createdAt": "2024-01-03T17:00:52Z",
      "updatedAt": "2024-01-10T16:25:16Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "design-team",
      "baseRefOid": "383b520d97d459f9765397ea3a64447e8e831d7b",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "tfpauly-patch-9",
      "headRefOid": "b28e37da25a8a8ba8a829deb5cad37af73b5c90f",
      "closedAt": "2024-01-10T16:25:16Z",
      "mergedAt": "2024-01-10T16:25:16Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "920e4801fef34e2b54d25caa4841beb95aac3dc7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85sGUAw",
          "commit": {
            "abbreviatedOid": "2815993"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-10T16:11:44Z",
          "updatedAt": "2024-01-10T16:11:45Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "```suggestion\r\n| scramble      | Reserved (will be used for final version)  | This Document | Section {{scramble-transform}} |\r\n```",
              "createdAt": "2024-01-10T16:11:44Z",
              "updatedAt": "2024-01-10T16:12:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85sGUVW",
          "commit": {
            "abbreviatedOid": "2815993"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-10T16:12:25Z",
          "updatedAt": "2024-01-10T16:12:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEHrEP85sGW_a",
          "commit": {
            "abbreviatedOid": "2815993"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-10T16:17:45Z",
          "updatedAt": "2024-01-10T16:17:45Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "```suggestion\r\n\"scramble-dt\". Once the design team PR is merged and a new draft is submitted,\r\nthe wire identifier will become \"scramble-XX\" where XX is the draft number.\r\nRegistrations in this registry are assigned using the\r\n```",
              "createdAt": "2024-01-10T16:17:45Z",
              "updatedAt": "2024-01-10T16:17:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85sGX11",
          "commit": {
            "abbreviatedOid": "95fe8f1"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-10T16:19:21Z",
          "updatedAt": "2024-01-10T16:19:21Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEHrEP85sGZ24",
          "commit": {
            "abbreviatedOid": "c20f968"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-10T16:23:23Z",
          "updatedAt": "2024-01-10T16:23:24Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "```suggestion\r\n\"scramble-dt\". Once the design team proposal is adopted and a new draft is submitted,\r\n```",
              "createdAt": "2024-01-10T16:23:24Z",
              "updatedAt": "2024-01-10T16:23:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 98,
      "id": "PR_kwDOEHrEP85jg5IU",
      "title": "draft text for security considerations",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/98",
      "state": "MERGED",
      "author": "ehaydenr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Design team"
      ],
      "body": "#93 ",
      "createdAt": "2024-01-08T20:23:13Z",
      "updatedAt": "2024-01-10T22:34:13Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "design-team",
      "baseRefOid": "383b520d97d459f9765397ea3a64447e8e831d7b",
      "headRepository": "ehaydenr/quic-proxy",
      "headRefName": "security-considerations",
      "headRefOid": "288832904cd4dea74d2c798b394ac49338162d2f",
      "closedAt": "2024-01-10T21:36:09Z",
      "mergedAt": "2024-01-10T21:36:09Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "7856a6290fafdd23a0e00fe5191fd4f17b66150c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85r5QKx",
          "commit": {
            "abbreviatedOid": "332e697"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Overall this is great, my comments are minor",
          "createdAt": "2024-01-08T23:01:52Z",
          "updatedAt": "2024-01-08T23:04:56Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "This isn't quite right because tunneled mode can use padding to mitigate size attacks. I'm not sure how best to tweak this sentence to incorporate that though",
              "createdAt": "2024-01-08T23:01:52Z",
              "updatedAt": "2024-01-08T23:04:56Z"
            },
            {
              "originalPosition": 37,
              "body": "Both tunneled and tunnelled are correct, but we should pick one",
              "createdAt": "2024-01-08T23:02:55Z",
              "updatedAt": "2024-01-08T23:04:56Z"
            },
            {
              "originalPosition": 48,
              "body": "```suggestion\r\nvulnerable to packet injection in the target-to-client direction. An attacker\r\n```",
              "createdAt": "2024-01-08T23:03:20Z",
              "updatedAt": "2024-01-08T23:04:56Z"
            },
            {
              "originalPosition": 53,
              "body": "```suggestion\r\nPacket injection with a known QUIC Connection ID can also happen in the\r\nclient-to-proxy direction, however, this only affects forwarded mode since tunneled\r\n```",
              "createdAt": "2024-01-08T23:03:49Z",
              "updatedAt": "2024-01-08T23:04:56Z"
            },
            {
              "originalPosition": 54,
              "body": "I think you mean integrity protection, not authentication?",
              "createdAt": "2024-01-08T23:04:20Z",
              "updatedAt": "2024-01-08T23:04:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85r5anY",
          "commit": {
            "abbreviatedOid": "332e697"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-08T23:59:54Z",
          "updatedAt": "2024-01-08T23:59:54Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "```suggestion\r\nare still vulnerable to size and timing attacks, without the addition of techniques that go beyond the analysis\r\nin this document, such as padding and adding chaff packets.\r\n```",
              "createdAt": "2024-01-08T23:59:54Z",
              "updatedAt": "2024-01-08T23:59:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85r5awZ",
          "commit": {
            "abbreviatedOid": "332e697"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-09T00:00:42Z",
          "updatedAt": "2024-01-09T00:00:42Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "The document uses `tunnelled` most today",
              "createdAt": "2024-01-09T00:00:42Z",
              "updatedAt": "2024-01-09T00:00:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85r-50F",
          "commit": {
            "abbreviatedOid": "332e697"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-09T17:23:37Z",
          "updatedAt": "2024-01-09T17:23:37Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "fixed everywhere, thanks!",
              "createdAt": "2024-01-09T17:23:37Z",
              "updatedAt": "2024-01-09T17:23:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85sGURK",
          "commit": {
            "abbreviatedOid": "352cf84"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-10T16:12:16Z",
          "updatedAt": "2024-01-10T16:12:16Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEHrEP85sGV6m",
          "commit": {
            "abbreviatedOid": "352cf84"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-10T16:15:36Z",
          "updatedAt": "2024-01-10T16:15:36Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "```suggestion\r\ntransform did provide integrity protection, attackers can inject replayed\r\n```",
              "createdAt": "2024-01-10T16:15:36Z",
              "updatedAt": "2024-01-10T16:15:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85sGWFq",
          "commit": {
            "abbreviatedOid": "352cf84"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": ":+1:",
          "createdAt": "2024-01-10T16:15:56Z",
          "updatedAt": "2024-01-10T16:21:26Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "```suggestion\r\nConnection ID is used for the corresponding burst on the proxy to client network path.\r\n```",
              "createdAt": "2024-01-10T16:15:56Z",
              "updatedAt": "2024-01-10T16:21:26Z"
            },
            {
              "originalPosition": 50,
              "body": "```suggestion\r\nthey are communicating with on each connection, and distinguish the packets sent to each target\r\nserver.  As a result, log-based correlation attacks against forwarded mode are expected to be\r\nhighly effective even when \"scramble\" is in use.\r\n```",
              "createdAt": "2024-01-10T16:21:07Z",
              "updatedAt": "2024-01-10T16:21:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85sGeIL",
          "commit": {
            "abbreviatedOid": "df7da92"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-10T16:31:43Z",
          "updatedAt": "2024-01-10T16:31:43Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "```suggestion\r\nin this document, such as padding and adding chaff packets.  Such techniques could be supported\r\nin a future packet transform, subject to additional security analysis.\r\n```",
              "createdAt": "2024-01-10T16:31:43Z",
              "updatedAt": "2024-01-10T16:31:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85sG92K",
          "commit": {
            "abbreviatedOid": "c554de4"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-10T17:36:14Z",
          "updatedAt": "2024-01-10T17:36:15Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "```suggestion\r\nin future packet transforms, subject to additional security analysis.\r\n```",
              "createdAt": "2024-01-10T17:36:15Z",
              "updatedAt": "2024-01-10T17:36:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85sG-YT",
          "commit": {
            "abbreviatedOid": "caeaf85"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-10T17:37:33Z",
          "updatedAt": "2024-01-10T17:37:34Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "```suggestion\r\nover the same client-to-proxy connection expose the number of target servers\r\n```",
              "createdAt": "2024-01-10T17:37:33Z",
              "updatedAt": "2024-01-10T17:37:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85sG-q4",
          "commit": {
            "abbreviatedOid": "0f65d08"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-10T17:38:16Z",
          "updatedAt": "2024-01-10T17:38:16Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "@bemasc what do you mean by \"log-based\"?",
              "createdAt": "2024-01-10T17:38:16Z",
              "updatedAt": "2024-01-10T17:38:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85sG-6i",
          "commit": {
            "abbreviatedOid": "51b2c54"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-10T17:38:53Z",
          "updatedAt": "2024-01-10T17:38:53Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "```suggestion\r\nConnection ID is used for the corresponding burst on the proxy-to-client network path.\r\n```",
              "createdAt": "2024-01-10T17:38:53Z",
              "updatedAt": "2024-01-10T17:38:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85sG_B8",
          "commit": {
            "abbreviatedOid": "51b2c54"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-10T17:39:11Z",
          "updatedAt": "2024-01-10T17:39:11Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "```suggestion\r\nUnlike tunnelled mode where packets are fully encapsulated in the client-to-proxy\r\nconnection, clients using forwarded mode to access multiple target servers\r\n```",
              "createdAt": "2024-01-10T17:39:11Z",
              "updatedAt": "2024-01-10T17:39:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85sHjHU",
          "commit": {
            "abbreviatedOid": "352cf84"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-10T19:04:11Z",
          "updatedAt": "2024-01-10T19:04:11Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "I meant \"based on a log of CIDs and VCIDs of a large number of packets observed entering and exiting the proxy\".",
              "createdAt": "2024-01-10T19:04:11Z",
              "updatedAt": "2024-01-10T19:04:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85sIubE",
          "commit": {
            "abbreviatedOid": "352cf84"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-10T21:36:04Z",
          "updatedAt": "2024-01-10T21:36:05Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "I think that comes down to the timing analysis, more or less. Tunnelled mode still can be one-to-one CIDs, and even if it isn't, it will generally be one-to-many, which still has pretty easy timing analysis for correlation.",
              "createdAt": "2024-01-10T21:36:04Z",
              "updatedAt": "2024-01-10T21:36:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85sJEMF",
          "commit": {
            "abbreviatedOid": "352cf84"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-10T22:34:13Z",
          "updatedAt": "2024-01-10T22:34:13Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "The lack of multiplexing, and the packet-for-packet guarantee, seem likely to make these attacks even easier.  I think that's worth highlighting for a deployment that is choosing between tunnelled and \"scramble\".",
              "createdAt": "2024-01-10T22:34:13Z",
              "updatedAt": "2024-01-10T22:34:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 99,
      "id": "PR_kwDOEHrEP85jvUde",
      "title": "Design team output",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/99",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Design team"
      ],
      "body": "Creating a PR for the output of the design team, to add a way to encrypt packets in forwarded mode.\r\n\r\n[Rendered view of this PR](https://ietf-wg-masque.github.io/draft-ietf-masque-quic-proxy/design-team/draft-ietf-masque-quic-proxy.html)\r\n[Rendered diff with main](https://author-tools.ietf.org/diff?url_1=https://ietf-wg-masque.github.io/draft-ietf-masque-quic-proxy/draft-ietf-masque-quic-proxy.txt&url_2=https://ietf-wg-masque.github.io/draft-ietf-masque-quic-proxy/design-team/draft-ietf-masque-quic-proxy.txt)",
      "createdAt": "2024-01-10T23:23:49Z",
      "updatedAt": "2024-05-07T21:13:40Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "e0421c5e08ce9406c11bdaa505c037559cd7fd6d",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "design-team",
      "headRefOid": "49847ff7204f41dbd899a3904b075cb6798d55b1",
      "closedAt": "2024-05-07T21:13:40Z",
      "mergedAt": "2024-05-07T21:13:40Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "9eed7307396c53a5d6113c9ba18250812c1d6053"
      },
      "comments": [
        {
          "author": "knekritz",
          "authorAssociation": "NONE",
          "body": "If I understand correctly, the scramble transform can be defeated by a single injected packet (ie with duplicated iv bytes, leading to key/iv reuse with aes-ctr). I think we should explicitly mention this in the security considerations, as this is both lower effort than most active attacks, and difficult to detect.",
          "createdAt": "2024-03-19T07:19:46Z",
          "updatedAt": "2024-03-19T07:19:46Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@knekritz That's mentioned here: https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/99/files#diff-15989da260773d143aa26dfcede63dff650a8d3c2f684cd01cc97adf9e9cf53cR1039-R1043.",
          "createdAt": "2024-03-19T07:24:16Z",
          "updatedAt": "2024-03-19T07:24:16Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85sQo_J",
          "commit": {
            "abbreviatedOid": "7856a62"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-11T18:45:35Z",
          "updatedAt": "2024-01-11T18:45:35Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "We probably also need to specify what happens if the accept-transform is not present or empty but forward is requested...?",
              "createdAt": "2024-01-11T18:45:35Z",
              "updatedAt": "2024-01-11T18:46:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85sQrSg",
          "commit": {
            "abbreviatedOid": "7856a62"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-11T18:49:07Z",
          "updatedAt": "2024-01-11T18:49:07Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "Shouldn't we say a bit more here? Like it also depends on the expected attacker abilities in the deployed scenario and the security requirements of the use case...?",
              "createdAt": "2024-01-11T18:49:07Z",
              "updatedAt": "2024-01-11T18:49:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85sQr7k",
          "commit": {
            "abbreviatedOid": "7856a62"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-11T18:49:59Z",
          "updatedAt": "2024-01-11T18:49:59Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "Or do we really need normative language here?",
              "createdAt": "2024-01-11T18:49:59Z",
              "updatedAt": "2024-01-11T18:49:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85sQxXL",
          "commit": {
            "abbreviatedOid": "7856a62"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-11T18:58:10Z",
          "updatedAt": "2024-01-11T18:58:11Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "```suggestion\r\nIf it supports QUIC packet proxying in forwarded mode, it sets the value to \"?1\"; otherwise,\r\nit sets it to \"?0\".\r\n```",
              "createdAt": "2024-01-11T18:58:10Z",
              "updatedAt": "2024-01-11T18:58:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85sQyYG",
          "commit": {
            "abbreviatedOid": "7856a62"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-11T18:59:38Z",
          "updatedAt": "2024-01-11T18:59:39Z",
          "comments": [
            {
              "originalPosition": 154,
              "body": "```suggestion\r\nthe scramble transform is in use, a global passive adversary cannot use the packet contents\r\nbefore and after the scramble transform is applied by the proxy\r\n```",
              "createdAt": "2024-01-11T18:59:39Z",
              "updatedAt": "2024-01-11T18:59:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85sQzUm",
          "commit": {
            "abbreviatedOid": "7856a62"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-11T19:01:06Z",
          "updatedAt": "2024-01-11T19:01:06Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "```suggestion\r\nWhen offering or selecting this transform, the client and server each\r\ngenerate the key that they will use to encrypt scrambled packets and MUST add it to the\r\nProxy-QUIC-Transform header in an `sf-binary` parameter named \"scramble-key\".\r\n```",
              "createdAt": "2024-01-11T19:01:06Z",
              "updatedAt": "2024-01-11T19:01:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85sQz3c",
          "commit": {
            "abbreviatedOid": "7856a62"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-11T19:01:57Z",
          "updatedAt": "2024-01-11T19:01:57Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "Also we need to specify what to do when the scramble-kay parameter is missing.",
              "createdAt": "2024-01-11T19:01:57Z",
              "updatedAt": "2024-01-11T19:01:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85sQ3HG",
          "commit": {
            "abbreviatedOid": "7856a62"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-11T19:06:52Z",
          "updatedAt": "2024-01-11T19:06:53Z",
          "comments": [
            {
              "originalPosition": 296,
              "body": "```suggestion\r\nthey are communicating with on each connection to passive attackers that can observe the client-to-proxy traffic.\r\n```",
              "createdAt": "2024-01-11T19:06:53Z",
              "updatedAt": "2024-01-15T14:17:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85sQy-2",
          "commit": {
            "abbreviatedOid": "7856a62"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-11T19:00:34Z",
          "updatedAt": "2024-01-11T19:15:10Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "```suggestion\r\n\"Proxy-QUIC-Forwarding\" is an Item Structured Header {{!RFC8941}}. Its\r\n```",
              "createdAt": "2024-01-11T19:00:34Z",
              "updatedAt": "2024-01-11T19:15:10Z"
            },
            {
              "originalPosition": 92,
              "body": "As specified, this parameter is simply mandatory.  We could certainly change that if we're willing to specify a default transform.  IIRC, we decided to leave the question of defaults to the WG.",
              "createdAt": "2024-01-11T19:02:41Z",
              "updatedAt": "2024-01-11T19:15:10Z"
            },
            {
              "originalPosition": 248,
              "body": "```suggestion\r\nof the Client Connection ID, and processed by the negotiated \"scramble\"\r\n```",
              "createdAt": "2024-01-11T19:07:29Z",
              "updatedAt": "2024-01-11T19:15:10Z"
            },
            {
              "originalPosition": 275,
              "body": "```suggestion\r\non one side of the proxy. The following sections highlight deanonymization risks with\r\n```",
              "createdAt": "2024-01-11T19:09:35Z",
              "updatedAt": "2024-01-11T19:15:10Z"
            },
            {
              "originalPosition": 296,
              "body": "```suggestion\r\nthey are communicating with on each connection.  This additional metadata\r\nrevealed on each packet simplifies size and timing attacks.\r\n```",
              "createdAt": "2024-01-11T19:13:50Z",
              "updatedAt": "2024-01-11T19:15:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85saK_a",
          "commit": {
            "abbreviatedOid": "7856a62"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-12T18:15:18Z",
          "updatedAt": "2024-01-12T18:15:18Z",
          "comments": [
            {
              "originalPosition": 296,
              "body": "Agreed, but s/than/that/",
              "createdAt": "2024-01-12T18:15:18Z",
              "updatedAt": "2024-01-12T18:15:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85slhO0",
          "commit": {
            "abbreviatedOid": "7856a62"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-15T14:17:14Z",
          "updatedAt": "2024-01-15T14:17:14Z",
          "comments": [
            {
              "originalPosition": 296,
              "body": "Updated comment. ",
              "createdAt": "2024-01-15T14:17:14Z",
              "updatedAt": "2024-01-15T14:17:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85s8SGf",
          "commit": {
            "abbreviatedOid": "7856a62"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-17T16:47:03Z",
          "updatedAt": "2024-01-17T16:53:51Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "```suggestion\r\n1. Any configuration information negotiated at startup.\r\n```",
              "createdAt": "2024-01-17T16:47:03Z",
              "updatedAt": "2024-01-17T16:53:51Z"
            },
            {
              "originalPosition": 123,
              "body": "We should define the terms \"upstream\" and \"downstream\" before using them",
              "createdAt": "2024-01-17T16:47:30Z",
              "updatedAt": "2024-01-17T16:53:51Z"
            },
            {
              "originalPosition": 122,
              "body": "Would it be clearer to rename this to encode and decode?",
              "createdAt": "2024-01-17T16:48:12Z",
              "updatedAt": "2024-01-17T16:53:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85tGYe0",
          "commit": {
            "abbreviatedOid": "7856a62"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-18T19:09:18Z",
          "updatedAt": "2024-01-18T19:09:18Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "Maybe \"send\" vs. \"receive\"?",
              "createdAt": "2024-01-18T19:09:18Z",
              "updatedAt": "2024-01-18T19:09:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85tGYwV",
          "commit": {
            "abbreviatedOid": "7856a62"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-18T19:10:05Z",
          "updatedAt": "2024-01-18T19:10:06Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "```suggestion\r\n1. The direction (client to proxy or proxy to client).\r\n```",
              "createdAt": "2024-01-18T19:10:05Z",
              "updatedAt": "2024-01-18T19:10:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85tyV3T",
          "commit": {
            "abbreviatedOid": "7856a62"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-24T16:52:20Z",
          "updatedAt": "2024-01-24T16:52:20Z",
          "comments": [
            {
              "originalPosition": 92,
              "body": "I think it's useful to say what a server does if it gets a header without the parameter.\r\n\r\n```suggestion\r\nin order of descending preference, separated by commas. If the proxy receives a\r\n\"Proxy-QUIC-Forwarding\" header without the \"accept-transform\" parameters, it\r\nMUST ignore the header and respond as if the client had not sent the\r\n\"Proxy-QUIC-Forwarding\" header.\r\n```",
              "createdAt": "2024-01-24T16:52:20Z",
              "updatedAt": "2024-01-24T16:52:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85tyWpg",
          "commit": {
            "abbreviatedOid": "da682e9"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-24T16:53:52Z",
          "updatedAt": "2024-01-24T16:53:52Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "```suggestion\r\n1. The direction (client-to-proxy or proxy-to-client).\r\n```",
              "createdAt": "2024-01-24T16:53:52Z",
              "updatedAt": "2024-01-24T16:53:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85tyXzU",
          "commit": {
            "abbreviatedOid": "aa099d2"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-24T16:56:12Z",
          "updatedAt": "2024-01-24T16:56:13Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "I think encode/decode is probably clearest.\r\n```suggestion\r\n1. The mode (encode or decode).\r\n```",
              "createdAt": "2024-01-24T16:56:13Z",
              "updatedAt": "2024-01-24T16:56:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85tyYQN",
          "commit": {
            "abbreviatedOid": "aa099d2"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-24T16:57:06Z",
          "updatedAt": "2024-01-24T16:57:07Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "```suggestion\r\nA packet transform is the procedure applied to encode packets as they are sent\r\non the link between the client and proxy, along with the inverse decode step applied\r\non receipt. Simple transforms can be modeled as a function as follows:\r\n```",
              "createdAt": "2024-01-24T16:57:07Z",
              "updatedAt": "2024-01-24T16:57:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85tyZH8",
          "commit": {
            "abbreviatedOid": "8557e02"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-24T16:58:56Z",
          "updatedAt": "2024-01-24T16:58:56Z",
          "comments": [
            {
              "originalPosition": 305,
              "body": "```suggestion\r\nthey are communicating with on each connection to passive attackers that can\r\nobserve the client-to-proxy traffic. This additional metadata revealed on each\r\npacket simplifies size and timing attacks.\r\n```",
              "createdAt": "2024-01-24T16:58:56Z",
              "updatedAt": "2024-01-24T16:58:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85tybJ2",
          "commit": {
            "abbreviatedOid": "20eb591"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-24T17:03:03Z",
          "updatedAt": "2024-01-24T17:03:04Z",
          "comments": [
            {
              "originalPosition": 175,
              "body": "```suggestion\r\nProxy-QUIC-Transform header in an `sf-binary` parameter named \"scramble-key\".\r\nIf either side receives a scramble transform without the \"scramble-key\" parameter,\r\nforwarding mode MUST be disabled.\r\n```",
              "createdAt": "2024-01-24T17:03:03Z",
              "updatedAt": "2024-01-24T17:03:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85tybkn",
          "commit": {
            "abbreviatedOid": "e171951"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-24T17:03:54Z",
          "updatedAt": "2024-01-24T17:03:55Z",
          "comments": [
            {
              "originalPosition": 154,
              "body": "```suggestion\r\nthe scramble transform is in use, a global passive adversary cannot simply compare the packet\r\ncontents on both sides of the proxy\r\n```",
              "createdAt": "2024-01-24T17:03:54Z",
              "updatedAt": "2024-01-24T17:03:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85tycmP",
          "commit": {
            "abbreviatedOid": "0447af5"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-24T17:06:01Z",
          "updatedAt": "2024-01-24T17:06:01Z",
          "comments": [
            {
              "originalPosition": 157,
              "body": "```suggestion\r\nUse of this transform is NOT RECOMMENDED if the scramble transform is supported\r\nby both the client and the proxy. Implementations MAY choose to not implement or\r\nsupport the \"null\" transform, depending on the use cases and privacy requirements of\r\nthe deployment.\r\n```",
              "createdAt": "2024-01-24T17:06:01Z",
              "updatedAt": "2024-01-24T17:06:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85tycqc",
          "commit": {
            "abbreviatedOid": "0447af5"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-24T17:06:09Z",
          "updatedAt": "2024-01-24T17:06:10Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "Updated to explain a bit more\r\n",
              "createdAt": "2024-01-24T17:06:09Z",
              "updatedAt": "2024-01-24T17:06:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85tyfky",
          "commit": {
            "abbreviatedOid": "0447af5"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-24T17:12:21Z",
          "updatedAt": "2024-01-24T17:12:21Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEHrEP85ty_tr",
          "commit": {
            "abbreviatedOid": "b4ef816"
          },
          "author": "mirjak",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-24T18:17:19Z",
          "updatedAt": "2024-01-24T18:17:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEHrEP85ufOac",
          "commit": {
            "abbreviatedOid": "b4ef816"
          },
          "author": "afressancourt",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-31T13:02:51Z",
          "updatedAt": "2024-01-31T13:39:18Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Here, shouldn't we map a stream to a mode (proxying / forwarding)? Then we can say that if a given stream is associated to the forwarding mode, then a single packet transform must be mapped to this stream.",
              "createdAt": "2024-01-31T13:02:52Z",
              "updatedAt": "2024-01-31T13:39:18Z"
            },
            {
              "originalPosition": 123,
              "body": "both versions work for me (with \"-\" and without)",
              "createdAt": "2024-01-31T13:21:45Z",
              "updatedAt": "2024-01-31T13:39:18Z"
            },
            {
              "originalPosition": 102,
              "body": "In the light of an issue filled by Martin Thomson, I agree that the \"null\" transform can be named \"identity transform\" to adopt a similar naming as in mathematics and cryptography. ",
              "createdAt": "2024-01-31T13:23:52Z",
              "updatedAt": "2024-01-31T13:39:18Z"
            },
            {
              "originalPosition": 104,
              "body": "I am in favor of making both transforms mandatory to implement. The null / identity transform is straightforward to implement as soon as a proxy supports forwarded mode, and I think making the scramble transform mandatory allows clients willing to use a proxy using the forwarded mode to benefit from a minimal security level. \r\n\r\nA side question that this question triggered: Are we willing to provide a mechanisms to negotiate transform between the client and proxy? ",
              "createdAt": "2024-01-31T13:28:16Z",
              "updatedAt": "2024-01-31T13:39:18Z"
            },
            {
              "originalPosition": 113,
              "body": "If we agree that the scramble method is mandatory to implement, then, why should we keep the null / identity transform? ",
              "createdAt": "2024-01-31T13:33:10Z",
              "updatedAt": "2024-01-31T13:39:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85uhFKx",
          "commit": {
            "abbreviatedOid": "7a09db3"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-31T15:55:04Z",
          "updatedAt": "2024-01-31T15:55:04Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Technically, forwarding mode is always additional to proxying mode.  The long header packets have to be sent in proxying mode anyway, so proxying mode is available and could be used for some short header packets as well.",
              "createdAt": "2024-01-31T15:55:04Z",
              "updatedAt": "2024-01-31T15:55:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85uhGXu",
          "commit": {
            "abbreviatedOid": "7a09db3"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-31T15:57:06Z",
          "updatedAt": "2024-01-31T15:57:07Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "Mandatory for whom?  I find the idea of making them both mandatory for both clients and proxies to be slightly strange.  Perhaps you are thinking of making them both mandatory for proxies, so that clients can choose to offer only one?",
              "createdAt": "2024-01-31T15:57:07Z",
              "updatedAt": "2024-01-31T15:57:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85uhG65",
          "commit": {
            "abbreviatedOid": "7a09db3"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-31T15:58:05Z",
          "updatedAt": "2024-01-31T15:58:06Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "I can certainly imagine that we say \"scramble\" is MTI for proxies, but clients can choose whether they want the extra protection.",
              "createdAt": "2024-01-31T15:58:05Z",
              "updatedAt": "2024-01-31T15:58:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85uhcxW",
          "commit": {
            "abbreviatedOid": "7a09db3"
          },
          "author": "afressancourt",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-31T16:30:12Z",
          "updatedAt": "2024-01-31T16:30:12Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Agreed, then implicitly, mapping to \"forwarding\" means that long header packets are proxyed, and short header packets are forwarded.",
              "createdAt": "2024-01-31T16:30:12Z",
              "updatedAt": "2024-01-31T16:30:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85uhewv",
          "commit": {
            "abbreviatedOid": "7a09db3"
          },
          "author": "afressancourt",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-31T16:34:00Z",
          "updatedAt": "2024-01-31T16:34:01Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "If we let clients the choice not to use the additional protection, then I suggest making scramble and null/identity MTI by the proxies, and recommend that clients use scramble or alternative method of their choice to protect their communication.",
              "createdAt": "2024-01-31T16:34:00Z",
              "updatedAt": "2024-01-31T16:34:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 102,
      "id": "PR_kwDOEHrEP85m3_ZF",
      "title": "Nits",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/102",
      "state": "MERGED",
      "author": "ike-kunze",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-14T15:35:23Z",
      "updatedAt": "2024-02-14T19:38:53Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "4bbbef92bf0b008f459adf38c676c88b447896d5",
      "headRepository": "ike-kunze/draft-ietf-masque-quic-proxy",
      "headRefName": "main",
      "headRefOid": "002b3ac3186faf31e62c2990e664abd3284105a4",
      "closedAt": "2024-02-14T19:38:53Z",
      "mergedAt": "2024-02-14T19:38:53Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "546015127b2c39b59c46d06cfa83cdf91c12af23"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85wH2TY",
          "commit": {
            "abbreviatedOid": "002b3ac"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-14T19:38:43Z",
          "updatedAt": "2024-02-14T19:38:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 104,
      "id": "PR_kwDOEHrEP85nU8JH",
      "title": "Proxy-Chosen Virtual Client Connection ID",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/104",
      "state": "MERGED",
      "author": "ehaydenr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As described in #88, loop attacks are possible when clients pick the virtual connection ID. This change moves the responsibility of generating a Virtual Client Connection ID to the proxy and requires the proxy to generate unpredictable virtual connection IDs.\r\n\r\nUnfortunately, this change complicates the capsule exchange. Specifically, the proxy cannot send forwarded mode packets in the Target->Client direction until it knows that the client is ready to receive them. Previously, when the client chose the vcid, we could require that the client not share the vcid unless it's ready to receive with it. Now that the proxy chooses the client vcid, we need the client to signal it's ready to receive forwarded mode packets. To accomplish this, ACK_CLIENT_VCID is introduced.\r\n\r\nThe ACK_CLIENT_VCID capsule solves the rule-readiness problem and maintains that the client can supply a Stateless Reset Token for resetting the client<->target tunnel.",
      "createdAt": "2024-02-19T20:26:30Z",
      "updatedAt": "2024-06-25T09:22:05Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "76f52893939f780610f982a91619136fd6f64ac0",
      "headRepository": "ehaydenr/quic-proxy",
      "headRefName": "proxy-chosen-vccid",
      "headRefOid": "a60363cdcb6934d29857a089d2eaec1d392e90e7",
      "closedAt": "2024-06-20T16:59:21Z",
      "mergedAt": "2024-06-20T16:59:21Z",
      "mergedBy": "ehaydenr",
      "mergeCommit": {
        "oid": "d211eee0166626408fb5f24b3b61acd5ceebb327"
      },
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "If the virtual client CID is chosen by the proxy, doesn't that mean that the client can no longer multiplex multiple connections on the same socket?",
          "createdAt": "2024-02-28T23:36:17Z",
          "updatedAt": "2024-02-28T23:36:17Z"
        },
        {
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "body": "> If the virtual client CID is chosen by the proxy, doesn't that mean that the client can no longer multiplex multiple connections on the same socket?\r\n\r\nI don't think so. The difference here is that the client has to create a demultiplexing rule with a value that the proxy chooses as opposed to one it chose itself. And the proxy can't send forwarded mode packets until the client signals that the rule is created.\r\n\r\nMaybe I'm missing something, can you elaborate?",
          "createdAt": "2024-02-29T15:30:25Z",
          "updatedAt": "2024-02-29T15:30:25Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "In general the mindset of QUIC CIDs is that they're picked by the receiver. That allows among other things the receiver to pick their CID length (a length 1 might be sufficient for a client that's only multiplexing two connections, but a server multiplexing hundreds would want more bytes). If you let someone else pick the CIDs, you could end up with a conflict on the client if it's talking to two proxies and the first proxy picks `CID=12345678` and the other picks `CID=1234567890`. One potential solution is to require a sufficient length that makes conflicts statistically unlikely, but the min length depends on how much multiplexing the client wants, so now maybe we need a way to encode that length?",
          "createdAt": "2024-02-29T18:09:58Z",
          "updatedAt": "2024-02-29T18:09:58Z"
        },
        {
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "body": "@DavidSchinazi what do you think about 98b876ef2ff61d02ec91722bd754c7e49ad696ad? ",
          "createdAt": "2024-03-27T16:36:15Z",
          "updatedAt": "2024-03-27T16:36:15Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I like that. We'll probably want to add some implementation considerations that\r\n* tell proxies that they need to select these CIDs randomly (maybe even MUST?)\r\n* tell clients that if they're multiplexing they need to pick a client connection ID length that makes conflicts unlikely if the proxy picks a random number for them\r\n\r\nbut in general this should work",
          "createdAt": "2024-04-01T23:43:36Z",
          "updatedAt": "2024-04-01T23:43:36Z"
        },
        {
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "body": "@DavidSchinazi, how does the language added in 4a2dc2164b69149ee54b2c76678d6791847907c0 sound?",
          "createdAt": "2024-04-29T23:14:58Z",
          "updatedAt": "2024-04-29T23:14:58Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "NONE",
          "body": "I have two concerns with this approach:\r\n1. Unless I'm missing something, this design assumes that there's no CID-based routing happening inside the client's network. I don't feel comfortable hard-coding this assumption into the design here.\r\n2. Similar to @DavidSchinazi, I'm concerned about the CID length here. My QUIC implementation assumes that all CIDs have the same (configurable) length. When a new packet arrives, I read `n` CID bytes, and find the respective QUIC connection by doing a map lookup. This doesn't work anymore if the proxy gives me a CID that has a different length. I'd either have to build some kind of prefix-trie, or do (up to `20-n`) map lookups. Given that the CID lookup already shows up in CPU profiles during high-bandwidth transfers, both of these options seem suboptimal. Things get even more complicated if an implementation decides to encode the CID length into the CID itself.",
          "createdAt": "2024-05-04T23:58:51Z",
          "updatedAt": "2024-05-04T23:58:51Z"
        },
        {
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "body": "@marten-seemann, to address your second point, one option could be to change this from a SHOULD to a MUST\r\n> To reduce the likelihood of connection ID conflicts, the proxy SHOULD choose a\r\n Virtual Client Connection ID that is at least as long as the Client Connection\r\n\r\nYour first point is well taken. For what it's worth, this requirement mirrors the requirement for the proxy - it must receive QUIC packets (with CIDs it did not choose) from the target and demultiplex them.\r\n\r\nAs mentioned at 119, I see three options for addressing the loop issue:\r\n1. Prohibit VIP sharing\r\n2. Eliminate target port sharing\r\n3. Proxy-chosen Virtual Client CIDs (this PR)\r\n\r\nWhile certainly not perfect, I think this option is the best of those three. Do you disagree? Do you see a another alternative?",
          "createdAt": "2024-05-06T15:27:24Z",
          "updatedAt": "2024-05-06T15:27:24Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "> I have two concerns with this approach:\r\n> \r\n> 1. Unless I'm missing something, this design assumes that there's no CID-based routing happening inside the client's network. I don't feel comfortable hard-coding this assumption into the design here.\r\n\r\nThis is already a property of the design, before this PR, unless I'm missing something. Proxies are not able to choose the client CID that the target writes into packets, except for an ability to veto ones that collide. There is no ability to propose a routable connection ID for use on the target-facing interface.\r\n\r\n",
          "createdAt": "2024-05-06T16:28:47Z",
          "updatedAt": "2024-05-06T16:28:47Z"
        },
        {
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinduke, if I'm understanding @marten-seemann correctly, I think he's referring to the fact that, with this change, the client can no longer choose the virtual client connection IDs that it receives with in forwarding mode. I do agree with you that the proxy has never been able to influence the _real_ client connection IDs beyond rejecting collisions - and this PR doesn't change that.",
          "createdAt": "2024-05-07T20:21:21Z",
          "updatedAt": "2024-05-07T20:21:21Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "> @martinduke, if I'm understanding @marten-seemann correctly, I think he's referring to the fact that, with this change, the client can no longer choose the virtual client connection IDs that it receives with in forwarding mode. I do agree with you that the proxy has never been able to influence the _real_ client connection IDs beyond rejecting collisions - and this PR doesn't change that.\r\n\r\nI agree with your statement of the facts. But my point is that we've already negated the idea of connection-ID based load balancing on the client side. Since QUIC (modulo MPQUIC) doesn't allow changes to server address anyway, this is not much of a problem.",
          "createdAt": "2024-05-08T15:45:21Z",
          "updatedAt": "2024-05-08T15:45:21Z"
        },
        {
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "body": "@marten-seemann, thoughts?",
          "createdAt": "2024-05-10T15:59:43Z",
          "updatedAt": "2024-05-10T15:59:43Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "NONE",
          "body": "Sorry for the late response, I'll get back to this later today or tomorrow.",
          "createdAt": "2024-05-20T04:04:06Z",
          "updatedAt": "2024-05-20T04:04:06Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "NONE",
          "body": "> 2\\. Similar to @DavidSchinazi, I'm concerned about the CID length here. My QUIC implementation assumes that all CIDs have the same (configurable) length. When a new packet arrives, I read `n` CID bytes, and find the respective QUIC connection by doing a map lookup. This doesn't work anymore if the proxy gives me a CID that has a different length. I'd either have to build some kind of prefix-trie, or do (up to `20-n`) map lookups. Given that the CID lookup already shows up in CPU profiles during high-bandwidth transfers, both of these options seem suboptimal. Things get even more complicated if an implementation decides to encode the CID length into the CID itself.\r\n\r\nI spent some more time thinking about this point, and I'm wondering if I'm missing something here. Compared to a simple map lookup, looking up a variable-length CID is way slower. I [implemented](https://github.com/marten-seemann/cid-lookup/blob/master/trie.go) a prefix trie with (up to) 20 levels, and its performance is terrible. At 100k CIDs, a CID lookup takes up to 40x longer:\r\n```\r\nBenchmarkTrieLookup/4_byte_CIDs-16              20221346                64.73 ns/op\r\nBenchmarkTrieLookup/8_byte_CIDs-16               5931970               207.9 ns/op\r\nBenchmarkTrieLookup/15_byte_CIDs-16              2255654               523.1 ns/op\r\nBenchmarkTrieLookup/20_byte_CIDs-16              1402430               805.1 ns/op\r\nBenchmarkMapLookup/4_byte_CIDs-16               88730054                13.92 ns/op\r\nBenchmarkMapLookup/8_byte_CIDs-16               91244919                13.14 ns/op\r\nBenchmarkMapLookup/15_byte_CIDs-16              85435095                13.84 ns/op\r\nBenchmarkMapLookup/20_byte_CIDs-16              41338683                29.12 ns/op\r\n```\r\n\r\nIn these cases, it would be faster to do a map lookup for all 20 possible CID lengths, until a match is found. \r\n\r\nAdmittedly, this problem exists on the proxy side already, but now we're moving it to the client as well. There are probably faster algorithms than a prefix trie (prefix b-trees), but I'd be curious to learn what kind of data structure people are planning to use for this in practice.",
          "createdAt": "2024-05-21T10:58:21Z",
          "updatedAt": "2024-05-21T10:58:21Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "NONE",
          "body": "I'm not sure if this is a nice solution, but an alternative could be using a bloom filter. I described the idea in more detail in https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/issues/108.",
          "createdAt": "2024-05-21T13:33:06Z",
          "updatedAt": "2024-05-21T13:33:06Z"
        },
        {
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "body": "@marten-seemann, one way of avoiding variable length lookups is to use a minimum client cid size and reject conflicts. Let's say you want to use N-byte CIDs. You would send a REGISTER_CLIENT_CID capsule with your N-byte CID and receive a virtual client connection ID back that's N+M bytes long. For the purposes of connection lookup, just use the first N bytes. If the first N bytes conflicts with some other connection, don't proceed with forwarding mode or send another REGISTER_CLIENT_CID capsule to solicit a new virtual client connection ID. ",
          "createdAt": "2024-05-21T15:50:40Z",
          "updatedAt": "2024-05-21T15:50:40Z"
        },
        {
          "author": "afressancourt",
          "authorAssociation": "NONE",
          "body": "Would it be possible to let the client choose between the method initially described in the draft and the mechanism proposed by @ehaydenr ? \r\nIn the signaling, if the REGISTER_CLIEND_ID contains only a Client Connection ID, then we are letting the proxy propose the virtual Client CID, and if the REGISTER_CLIEND_ID contains both a Client Connection ID and a virtual Client Connection ID, the proxy tries to accommodate this request, and sends an error message if it is not possible to deal with a client-set virtual Client Connection ID ?  ",
          "createdAt": "2024-05-21T15:53:41Z",
          "updatedAt": "2024-05-21T15:53:41Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "> Would it be possible to let the client choose between the method initially described in the draft and the mechanism proposed by @ehaydenr ? In the signaling, if the REGISTER_CLIEND_ID contains only a Client Connection ID, then we are letting the proxy propose the virtual Client CID, and if the REGISTER_CLIEND_ID contains both a Client Connection ID and a virtual Client Connection ID, the proxy tries to accommodate this request, and sends an error message if it is not possible to deal with a client-set virtual Client Connection ID ?\r\n\r\nIf I'm not mistaken, if the proxy allows the client to choose the connection ID, it is open to the attack that is the reason for this PR.",
          "createdAt": "2024-05-25T16:53:25Z",
          "updatedAt": "2024-05-25T16:53:25Z"
        },
        {
          "author": "afressancourt",
          "authorAssociation": "NONE",
          "body": "> If I'm not mistaken, if the proxy allows the client to choose the connection ID, it is open to the attack that is the reason for this PR.\r\n\r\nI understand the wish to mitigate loop attacks, but at the same time it complicates the connection setup with one additional message. Besides, we can argue that not answering the ACK_CLIENT_ID sent by the proxy can be used as an attack vector if clients coordinate to sent a high number of REGISTER_CLIENT_CID to the same proxy. \r\n\r\nLetting the client choose whether he wants to let the proxy choose its virtual connection ID would allow to either ease the capsule exchange at connection setup, or fallback in a mode which protects the proxy against loop attacks.\r\n",
          "createdAt": "2024-05-29T09:30:26Z",
          "updatedAt": "2024-05-29T09:30:26Z"
        },
        {
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "body": "> I understand the wish to mitigate loop attacks, but at the same time it complicates the connection setup with one additional message.\r\n\r\nI would argue the additional message is cheap since it requires no additional round trip.\r\n\r\n> Besides, we can argue that not answering the ACK_CLIENT_ID sent by the proxy can be used as an attack vector if clients coordinate to sent a high number of REGISTER_CLIENT_CID to the same proxy.\r\n\r\nThe proxy can reject the CID registration with the corresponding CLOSE_CLIENT_CID/CLOSE_TARGET_CID capsule. For adding guidance here, I created #109 \r\n\r\n> Letting the client choose whether he wants to let the proxy choose its virtual connection ID would allow to either ease the capsule exchange at connection setup, or fallback in a mode which protects the proxy against loop attacks.\r\n\r\nAre you suggesting we keep the capsule exchange as-is and for deployments that wish to mitigate loop attacks, they simply don't implement forwarding mode?",
          "createdAt": "2024-06-11T14:12:57Z",
          "updatedAt": "2024-06-11T14:12:57Z"
        },
        {
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "body": "@marten-seemann , does my comment about skipping variable length lookups address your concern?",
          "createdAt": "2024-06-11T14:14:14Z",
          "updatedAt": "2024-06-11T14:14:14Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "NONE",
          "body": "> @marten-seemann, one way of avoiding variable length lookups is to use a minimum client cid size and reject conflicts. Let's say you want to use N-byte CIDs. You would send a REGISTER_CLIENT_CID capsule with your N-byte CID and receive a virtual client connection ID back that's N+M bytes long. For the purposes of connection lookup, just use the first N bytes. If the first N bytes conflicts with some other connection, don't proceed with forwarding mode or send another REGISTER_CLIENT_CID capsule to solicit a new virtual client connection ID.\r\n\r\nThis makes sense to me. It assumes that there's not too much structure to CIDs issued (e.g. if the proxy's CID allocation strategy would be to use an N byte prefix, this method wouldn't work), but I think that's guaranteed by the fact that CIDs MUST be unlinkable to an on-path observer.",
          "createdAt": "2024-06-20T10:58:31Z",
          "updatedAt": "2024-06-20T10:58:31Z"
        },
        {
          "author": "afressancourt",
          "authorAssociation": "NONE",
          "body": "> > I understand the wish to mitigate loop attacks, but at the same time it complicates the connection setup with one additional message.\r\n> \r\n> I would argue the additional message is cheap since it requires no additional round trip.\r\n\r\nIf you can send the ACK_CLIEN_VCID together with the first bytes of data, then, I agree, you \"only\" loose the overhead of the ACK message. \r\n\r\n> > Letting the client choose whether he wants to let the proxy choose its virtual connection ID would allow to either ease the capsule exchange at connection setup, or fallback in a mode which protects the proxy against loop attacks.\r\n> \r\n> Are you suggesting we keep the capsule exchange as-is and for deployments that wish to mitigate loop attacks, they simply don't implement forwarding mode?\r\n\r\nNot exactly. I had in mind a mechanism in which the client starts with sending a REGISTER_CLIENT_ID with either a VCCID or not in it (or a bit stating the VCCID is proposed but can be overridden). \r\nIf the proxy receives a REGISTER_CLIENT_ID with either no VCCID or an overriddable VCCID, then:\r\n- It can propose a VCCID in the ACK_CLIENT_ID, which will be acked itself by the ACK_CLIENT_VCID. \r\n- Otherwise, we are in a state in which the client does want to use its VCCID, so then either the proxy acks this sending a ACK_CLIENT_ID or it refuses the connection with the corresponding CLOSE_CLIENT_CID/CLOSE_TARGET_CID capsule. \r\n\r\n",
          "createdAt": "2024-06-25T09:22:04Z",
          "updatedAt": "2024-06-25T09:22:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85xqRQC",
          "commit": {
            "abbreviatedOid": "c8cd162"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-28T17:52:13Z",
          "updatedAt": "2024-02-28T17:52:13Z",
          "comments": [
            {
              "originalPosition": 467,
              "body": "Thanks for updating the values!",
              "createdAt": "2024-02-28T17:52:13Z",
              "updatedAt": "2024-02-28T17:52:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP855J7Km",
          "commit": {
            "abbreviatedOid": "4a2dc21"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for the latest updates, I think this is good",
          "createdAt": "2024-04-30T22:09:39Z",
          "updatedAt": "2024-04-30T22:09:39Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEHrEP855YGJ8",
          "commit": {
            "abbreviatedOid": "4a2dc21"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-02T17:13:06Z",
          "updatedAt": "2024-05-02T17:13:26Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nthe client or to guarantee no conflicts among all proxies sharing an IP address\r\n```",
              "createdAt": "2024-05-02T17:13:07Z",
              "updatedAt": "2024-05-02T17:13:26Z"
            },
            {
              "originalPosition": 483,
              "body": "```suggestion\r\n```",
              "createdAt": "2024-05-02T17:13:18Z",
              "updatedAt": "2024-05-02T17:13:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP855YKqK",
          "commit": {
            "abbreviatedOid": "a60363c"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-02T17:20:22Z",
          "updatedAt": "2024-05-02T17:20:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 105,
      "id": "PR_kwDOEHrEP85pjTFT",
      "title": "null -> identity",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/105",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Design team"
      ],
      "body": "Closes #101",
      "createdAt": "2024-03-13T20:44:16Z",
      "updatedAt": "2024-03-17T02:41:39Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "design-team",
      "baseRefOid": "b4ef816df5b71100d04fedcb9bd9c0e81f702325",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "tfpauly-patch-10",
      "headRefOid": "d5854806c6aaef176748ebb175ed59e559842629",
      "closedAt": "2024-03-17T02:41:38Z",
      "mergedAt": "2024-03-17T02:41:38Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "32905167471ab049d4237cdf6010f66c97465a24"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85zWaHK",
          "commit": {
            "abbreviatedOid": "d585480"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-13T21:31:25Z",
          "updatedAt": "2024-03-13T21:31:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEHrEP85zttcz",
          "commit": {
            "abbreviatedOid": "d585480"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-17T02:37:58Z",
          "updatedAt": "2024-03-17T02:37:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 106,
      "id": "PR_kwDOEHrEP85pjZmo",
      "title": "Expand on active attack differences",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/106",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Design team"
      ],
      "body": "Closes #100",
      "createdAt": "2024-03-13T21:04:42Z",
      "updatedAt": "2024-05-07T21:12:53Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "design-team",
      "baseRefOid": "b4ef816df5b71100d04fedcb9bd9c0e81f702325",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "tfpauly-patch-11",
      "headRefOid": "9d2c8474431d942d08a94c90932d5cb149903f52",
      "closedAt": "2024-05-07T21:12:52Z",
      "mergedAt": "2024-05-07T21:12:52Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "49847ff7204f41dbd899a3904b075cb6798d55b1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85zWacM",
          "commit": {
            "abbreviatedOid": "9d2c847"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-13T21:32:35Z",
          "updatedAt": "2024-03-13T21:32:35Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEHrEP85zttex",
          "commit": {
            "abbreviatedOid": "9d2c847"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-17T02:39:29Z",
          "updatedAt": "2024-03-17T02:39:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 107,
      "id": "PR_kwDOEHrEP85py-ea",
      "title": "Fix capsule registration",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/107",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on IANA review",
      "createdAt": "2024-03-15T20:37:46Z",
      "updatedAt": "2024-03-17T02:43:26Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "546015127b2c39b59c46d06cfa83cdf91c12af23",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "tfpauly-patch-12",
      "headRefOid": "6a4a23169aff193568fc86bdcc8a0d077f9df36b",
      "closedAt": "2024-03-17T02:43:26Z",
      "mergedAt": "2024-03-17T02:43:26Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "b1b091c03e617ce5b47e0a43728605eebdfccaec"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85zriV3",
          "commit": {
            "abbreviatedOid": "4830f4b"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-15T23:14:45Z",
          "updatedAt": "2024-03-15T23:14:45Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEHrEP85zttfv",
          "commit": {
            "abbreviatedOid": "4830f4b"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-17T02:40:10Z",
          "updatedAt": "2024-03-17T02:41:32Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "```suggestion\r\n: provisional (permanent when this document is published)\r\n```",
              "createdAt": "2024-03-17T02:40:10Z",
              "updatedAt": "2024-03-17T02:41:32Z"
            }
          ]
        }
      ]
    },
    {
      "number": 110,
      "id": "PR_kwDOEHrEP850GBWn",
      "title": "Editorial updates to abstract and intro",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/110",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2024-07-01T16:40:37Z",
      "updatedAt": "2024-07-03T16:32:39Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "d211eee0166626408fb5f24b3b61acd5ceebb327",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "tfp/intro-editorial",
      "headRefOid": "19c2fa6969348569602e7899bf9bf10aff58941a",
      "closedAt": "2024-07-03T16:32:38Z",
      "mergedAt": "2024-07-03T16:32:38Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "15ad6173de02e162369b95709051e77a213355b8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP86AjahI",
          "commit": {
            "abbreviatedOid": "e241c00"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-03T15:24:58Z",
          "updatedAt": "2024-07-03T15:26:52Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "```suggestion\r\npackets in the QUIC connection between the client and target are sent with dedicated\r\n```",
              "createdAt": "2024-07-03T15:24:58Z",
              "updatedAt": "2024-07-03T15:26:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP86Aj5pJ",
          "commit": {
            "abbreviatedOid": "19c2fa6"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-03T16:25:17Z",
          "updatedAt": "2024-07-03T16:25:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 111,
      "id": "PR_kwDOEHrEP850Wmnt",
      "title": "Full editorial pass",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/111",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Major editorial pass to re-structure the document for clarity, flow, etc. All of the old content is there, but moved around, and this tries to explain things better in the overview section.\r\n\r\nRendered version:\r\nhttps://ietf-wg-masque.github.io/draft-ietf-masque-quic-proxy/tfp/full-editorial/draft-ietf-masque-quic-proxy.html",
      "createdAt": "2024-07-03T17:25:35Z",
      "updatedAt": "2024-07-08T02:44:14Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "15ad6173de02e162369b95709051e77a213355b8",
      "headRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "headRefName": "tfp/full-editorial",
      "headRefOid": "0ca78f02fb49af33be9ed6191ec0a6c0cf794d1d",
      "closedAt": "2024-07-08T02:44:14Z",
      "mergedAt": "2024-07-08T02:44:13Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "e1a2cc969cbba66329c26cd827e68c20f8ac0260"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP86AlQT8",
          "commit": {
            "abbreviatedOid": "7f6612b"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-03T19:46:56Z",
          "updatedAt": "2024-07-03T19:46:56Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "It seems like we're jumping between a few different conventions for CIDs and I'm wondering if there's an opportunity for more consistency.\r\n\r\nIn the \"Example of sharing a proxy-to-target 4-tuple\" diagram prior to this, I see the following for the client<->target connection:\r\n- 4 of the same letter (the client's letter) followed by the same 4 numbers for client CID\r\n- Those same 4 letters followed by those 4 numbers all incremented by one\r\n\r\nIn this diagram, we have to show CIDs for three different connections which requires 6 different CIDs. The convention switches to doing 4 letters followed by 4 numbers vs. those same 4 numbers followed by four letters.  I think having a distinct pattern for each of these that's consistent across diagrams might be useful.\r\n\r\nI think the CCCC0000, 0000CCCC CID pair pattern may be the least distracting. Each time there's a new client, go to the next letter in the alphabet. Each time a single client needs another CID pair, increment the number. For this diagram, that would mean instead of AAAABBBB we would have CCCC2222",
              "createdAt": "2024-07-03T19:46:56Z",
              "updatedAt": "2024-07-03T19:46:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP86AlQ6P",
          "commit": {
            "abbreviatedOid": "7f6612b"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-03T19:47:56Z",
          "updatedAt": "2024-07-03T19:47:56Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "```suggestion\r\npackets sent by a target, the proxy needs to be able to observe the client\r\n```",
              "createdAt": "2024-07-03T19:47:56Z",
              "updatedAt": "2024-07-03T19:47:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP86AlUtE",
          "commit": {
            "abbreviatedOid": "7f6612b"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-03T19:54:00Z",
          "updatedAt": "2024-07-03T19:54:00Z",
          "comments": [
            {
              "originalPosition": 186,
              "body": "```suggestion\r\nto the proxy. Since these packets are generated using the target CID,\r\nload balancers may not have the necessary information to route packets to the correct proxy. The target VCID\r\n```",
              "createdAt": "2024-07-03T19:54:00Z",
              "updatedAt": "2024-07-03T19:54:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP86AlgwF",
          "commit": {
            "abbreviatedOid": "7f6612b"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-03T20:13:47Z",
          "updatedAt": "2024-07-03T20:13:47Z",
          "comments": [
            {
              "originalPosition": 290,
              "body": "This numbered list all starts with `1.`",
              "createdAt": "2024-07-03T20:13:47Z",
              "updatedAt": "2024-07-03T20:13:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP86AljXM",
          "commit": {
            "abbreviatedOid": "7f6612b"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-03T20:16:59Z",
          "updatedAt": "2024-07-03T20:16:59Z",
          "comments": [
            {
              "originalPosition": 325,
              "body": "The steps are nearly identical between the two modes - should we consolidate?",
              "createdAt": "2024-07-03T20:16:59Z",
              "updatedAt": "2024-07-03T20:17:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP86Allco",
          "commit": {
            "abbreviatedOid": "7f6612b"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-03T20:19:39Z",
          "updatedAt": "2024-07-03T20:19:39Z",
          "comments": [
            {
              "originalPosition": 452,
              "body": "```suggestion\r\nto let proxies know when Connection IDs on the client-to-target\r\nQUIC connection are changing. Proxies send capsules to acknowledge or\r\n```",
              "createdAt": "2024-07-03T20:19:39Z",
              "updatedAt": "2024-07-03T20:19:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP86Alt7V",
          "commit": {
            "abbreviatedOid": "7f6612b"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-03T20:35:28Z",
          "updatedAt": "2024-07-03T20:35:28Z",
          "comments": [
            {
              "originalPosition": 290,
              "body": "Yes that's how markdown numbered lists work, it's weird",
              "createdAt": "2024-07-03T20:35:28Z",
              "updatedAt": "2024-07-03T20:35:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP86A3vW5",
          "commit": {
            "abbreviatedOid": "7f6612b"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-08T02:38:43Z",
          "updatedAt": "2024-07-08T02:38:44Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "Updated!",
              "createdAt": "2024-07-08T02:38:43Z",
              "updatedAt": "2024-07-08T02:38:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP86A3vvh",
          "commit": {
            "abbreviatedOid": "7f6612b"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-08T02:41:08Z",
          "updatedAt": "2024-07-08T02:41:08Z",
          "comments": [
            {
              "originalPosition": 325,
              "body": "They're close, but there are differences in almost all steps for VCID vs no VCID",
              "createdAt": "2024-07-08T02:41:08Z",
              "updatedAt": "2024-07-08T02:41:08Z"
            }
          ]
        }
      ]
    },
    {
      "number": 117,
      "id": "PR_kwDOEHrEP859SnH3",
      "title": "Require client VCID to be at least as long as real client CID ",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/117",
      "state": "MERGED",
      "author": "ehaydenr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "closes #112 ",
      "createdAt": "2024-10-01T18:16:40Z",
      "updatedAt": "2024-10-02T20:09:18Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "e1a2cc969cbba66329c26cd827e68c20f8ac0260",
      "headRepository": "ehaydenr/quic-proxy",
      "headRefName": "cidlength",
      "headRefOid": "ee2c8cb8aa6494a424a08b7778f781cd923e0721",
      "closedAt": "2024-10-02T18:36:25Z",
      "mergedAt": "2024-10-02T18:36:25Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "c3752cfb4f1b27f922de68cdccf7c9ed79aa9192"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP86Ls8Fn",
          "commit": {
            "abbreviatedOid": "ee2c8cb"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-02T18:35:47Z",
          "updatedAt": "2024-10-02T18:35:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 118,
      "id": "PR_kwDOEHrEP859htcL",
      "title": "MAX_CONNECTION_IDS capsule",
      "url": "https://github.com/ietf-wg-masque/draft-ietf-masque-quic-proxy/pull/118",
      "state": "MERGED",
      "author": "ehaydenr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "closes #109 ",
      "createdAt": "2024-10-03T17:04:35Z",
      "updatedAt": "2024-10-19T03:07:18Z",
      "baseRepository": "ietf-wg-masque/draft-ietf-masque-quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "c3752cfb4f1b27f922de68cdccf7c9ed79aa9192",
      "headRepository": "ehaydenr/quic-proxy",
      "headRefName": "limits",
      "headRefOid": "a3e5faa4b50ed626e4f0b252180033abc6e39218",
      "closedAt": "2024-10-19T03:07:18Z",
      "mergedAt": "2024-10-19T03:07:18Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "1281079b341b0a8ef6e46a868e3a0275260768a1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP86L16rA",
          "commit": {
            "abbreviatedOid": "210a191"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-03T17:06:17Z",
          "updatedAt": "2024-10-03T17:06:17Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Not sure what stream reset code is most appropriate here \ud83e\udd14 ",
              "createdAt": "2024-10-03T17:06:17Z",
              "updatedAt": "2024-10-03T17:06:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP86NGqyB",
          "commit": {
            "abbreviatedOid": "210a191"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T18:10:17Z",
          "updatedAt": "2024-10-14T18:17:23Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "[H3_DATAGRAM_ERROR](https://www.rfc-editor.org/rfc/rfc9297#name-http-3-error-code)",
              "createdAt": "2024-10-14T18:10:17Z",
              "updatedAt": "2024-10-14T18:17:24Z"
            },
            {
              "originalPosition": 66,
              "body": "Do we need this field to be in the capsule? QUIC uses sequence numbers because packet reordering can cause reordering of connection ID frames. Here, on the other hand, we're on the capsule stream and that's ordered, so we can know the sequence number implicitly. I'd suggest removing this field to keep the implementation simpler.",
              "createdAt": "2024-10-14T18:12:07Z",
              "updatedAt": "2024-10-14T18:17:23Z"
            },
            {
              "originalPosition": 210,
              "body": "Should we add some guidance for clients as to what they should do if they run out of registrations?",
              "createdAt": "2024-10-14T18:15:16Z",
              "updatedAt": "2024-10-14T18:17:24Z"
            },
            {
              "originalPosition": 165,
              "body": "Pro-tip: in previous drafts I would write here `see {{iana}} for the value of the capsule type` so that we only need to modify a single value when we rev the draft",
              "createdAt": "2024-10-14T18:17:08Z",
              "updatedAt": "2024-10-14T18:17:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP86NT3tI",
          "commit": {
            "abbreviatedOid": "210a191"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-15T22:18:19Z",
          "updatedAt": "2024-10-15T22:18:19Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Perhaps the is _most_ appropriate, but it feels a little odd to me since the description is \"Datagram or Capsule Protocol parse error\". We're not failing to parse the capsule protocol, we're just unhappy with a value that happened to be delivered over a capsule.",
              "createdAt": "2024-10-15T22:18:19Z",
              "updatedAt": "2024-10-15T22:18:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP86NT4UH",
          "commit": {
            "abbreviatedOid": "210a191"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-15T22:20:43Z",
          "updatedAt": "2024-10-15T22:20:44Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "It's not needed, no. I don't have a strong opinion, but the advantage I see is it may make it easier to debug when client and server have a different understanding of what the count is. Considering that, please confirm you'd rather it be omitted and I'll update.",
              "createdAt": "2024-10-15T22:20:43Z",
              "updatedAt": "2024-10-15T22:20:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP86NT7F0",
          "commit": {
            "abbreviatedOid": "210a191"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-15T22:31:41Z",
          "updatedAt": "2024-10-15T22:31:41Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "I'd love to avoid having the sequence number as an extra field, just to reduce the number of things we're adding to the wire format. I get that there's a bit more state to keep, but this is a reliable stream.",
              "createdAt": "2024-10-15T22:31:41Z",
              "updatedAt": "2024-10-15T22:31:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP86NUDvh",
          "commit": {
            "abbreviatedOid": "210a191"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-15T23:10:04Z",
          "updatedAt": "2024-10-15T23:10:04Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "If the client just sent a fin on the client-to-proxy HTTP stream, that wouldn't give the proxy indication that something bad happened which is unfortunate. If we went with a reset, what's the most appropriate? H3_GENERAL_PROTOCOL_ERROR? \ud83e\udd14 ",
              "createdAt": "2024-10-15T23:10:04Z",
              "updatedAt": "2024-10-15T23:10:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP86NUEqm",
          "commit": {
            "abbreviatedOid": "210a191"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-15T23:14:58Z",
          "updatedAt": "2024-10-15T23:16:49Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Yeah but that's what we've done with other capsules, here's from [connect-ip](https://www.rfc-editor.org/rfc/rfc9484#section-4.7.2-8):\r\n\r\n> If any of the capsule fields are malformed upon reception, the receiver of the capsule MUST follow the error-handling procedure defined in [Section 3.3](https://rfc-editor.org/rfc/rfc9297#section-3.3) of [[HTTP-DGRAM](https://www.rfc-editor.org/rfc/rfc9484#RFC9297)].",
              "createdAt": "2024-10-15T23:14:59Z",
              "updatedAt": "2024-10-16T17:18:45Z"
            },
            {
              "originalPosition": 66,
              "body": "My gut feeling is that as an implementer I would keep track of the last sequence number anyway, and manually validate that the peer is sending them in correct order. So removing the field means less code",
              "createdAt": "2024-10-15T23:15:46Z",
              "updatedAt": "2024-10-15T23:16:49Z"
            },
            {
              "originalPosition": 210,
              "body": "Is that the guidance? Or should it be that the client just can't migrate any more? Happy to move this to a separate issue if you prefer",
              "createdAt": "2024-10-15T23:16:41Z",
              "updatedAt": "2024-10-15T23:16:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP86NUHGI",
          "commit": {
            "abbreviatedOid": "210a191"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-15T23:27:33Z",
          "updatedAt": "2024-10-15T23:27:34Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "Migration is only relevant when you're doing forwarding mode. Limiting CID registration is still useful when there's no forwarding because the proxy may want to limit the number of CIDs considered for port reuse",
              "createdAt": "2024-10-15T23:27:34Z",
              "updatedAt": "2024-10-15T23:27:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP86NUKs5",
          "commit": {
            "abbreviatedOid": "210a191"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-15T23:46:19Z",
          "updatedAt": "2024-10-15T23:46:19Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "Oh right I had it backwards. If the client runs out of CIDs in this way, it's the CIDs on the target-to-proxy leg right? So the consequence is that the client can't send new connection IDs to the target, but the connection could keep working?",
              "createdAt": "2024-10-15T23:46:19Z",
              "updatedAt": "2024-10-15T23:46:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP86Ncxft",
          "commit": {
            "abbreviatedOid": "210a191"
          },
          "author": "ehaydenr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-16T16:57:16Z",
          "updatedAt": "2024-10-16T16:57:16Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "If the target sends NEW_CONNECTION_ID with SequenceNumber=5 with RetirePriorTo=5, the client cannot send anything to the target unless it can send a REGISTER_TARGET_CID capsule to the proxy. I _think_ the target->client direction may be OK",
              "createdAt": "2024-10-16T16:57:16Z",
              "updatedAt": "2024-10-16T16:57:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP86Nc9hQ",
          "commit": {
            "abbreviatedOid": "210a191"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-16T17:17:14Z",
          "updatedAt": "2024-10-16T17:17:14Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "I see. OK then I think it's worth it to explain this scenario and tell the client that they will need to abort the connection if after some timeout they're still blocked in this state",
              "createdAt": "2024-10-16T17:17:14Z",
              "updatedAt": "2024-10-16T17:17:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP86NpM2A",
          "commit": {
            "abbreviatedOid": "0f98259"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2024-10-17T22:01:39Z",
          "updatedAt": "2024-10-17T22:01:39Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEHrEP86Nz7Y8",
          "commit": {
            "abbreviatedOid": "0f98259"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-19T03:02:48Z",
          "updatedAt": "2024-10-19T03:05:27Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "```suggestion\r\nnumber of active registrations. The first registration (of either client CID or target CID)\r\nhas sequence number 0, and subsequent registrations increment the sequence number\r\nby 1.\r\n```",
              "createdAt": "2024-10-19T03:02:48Z",
              "updatedAt": "2024-10-19T03:05:27Z"
            },
            {
              "originalPosition": 180,
              "body": "```suggestion\r\nClients that cannot register new connection IDs within a reasonable time due to\r\n```",
              "createdAt": "2024-10-19T03:04:14Z",
              "updatedAt": "2024-10-19T03:05:27Z"
            }
          ]
        }
      ]
    }
  ]
}