{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2022-11-06T00:17:18.621848+00:00",
  "repo": "tfpauly/quic-proxy",
  "labels": [
    {
      "name": "Ready for Text",
      "description": "",
      "color": "006b75"
    },
    {
      "name": "Discuss",
      "description": "",
      "color": "b60205"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWU2NTAyNTM5NjQ=",
      "title": "Consider packet replay/injection attacks",
      "url": "https://github.com/tfpauly/quic-proxy/issues/1",
      "state": "OPEN",
      "author": "tfpauly",
      "authorAssociation": "OWNER",
      "assignees": [
        "tfpauly",
        "chris-wood"
      ],
      "labels": [],
      "body": "When forwarding for a given CID, the proxy can very simply process a packet without doing any decryption. However, this means the packet may not be valid (it could be a replay, or a packet injected by someone spoofing the IP addresses and CID).\r\n\r\nSince the proxy is acting effectively as a router, this *might* be acceptable. However:\r\n- When the target/origin receives bogus or duplicate QUIC packets, it may be forced to rate-limit traffic from the proxy that forwarded the bad traffic\r\n- The proxy is being made to do work of forwarding packets. If that is more expensive than something that could be done simply to validate the packet (signed hash of the packet, say), then it may be preferable to do some validation.",
      "createdAt": "2020-07-02T23:30:43Z",
      "updatedAt": "2020-07-02T23:30:43Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU2NjIxODU0Nzg=",
      "title": "Include details about proxy connection ID mappings",
      "url": "https://github.com/tfpauly/quic-proxy/issues/3",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "From @DavidSchinazi \r\n\r\nThe issue about connection ID lengths should be addressed: since the end-server decides its own connection IDs, the client and proxy have no control over Server-Connection-Id. If the client sends non-tunneled short header packets, the server won't be able to figure out the connection ID length. The server could try all possible values, but either way I think this should be mentioned in the draft. In particular, the end of the Load Balancer seems to ignore this problem - the proxy's load balancer won't be collaborating with the end-server so I think this is broken\r\n\r\nBeyond this, we can talk about how the proxy can try to re-use a socket between itself and the target, but that it needs to detect cases when a Connection ID cannot be distinguished (due to overlap in part, or insufficient length), and either create a new socket, or fail the request.",
      "createdAt": "2020-07-20T19:35:42Z",
      "updatedAt": "2020-10-14T18:25:36Z",
      "closedAt": "2020-10-14T18:25:35Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure I follow how using a new socket helps here. If the end-server decides to use a 1-byte server connection ID, and the client is using the non-tunneled mode, then the client will send a short header with that 1-byte CID to the main proxy address/port (probably port 443), it won't send to the proxy's ephemeral socket.",
          "createdAt": "2020-07-20T19:39:42Z",
          "updatedAt": "2020-07-20T19:39:42Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Also should cover:\r\n\"the Connection ID MUST be unique across all other clients\" - I think what you meant is: \"Client connection ID mappings have to be unique to allow deterministic forwarding, and therefore servers MUST reject CONNECT-QUIC requests that contain a Client-Connection ID that is already in use\" or something like that. That said, thinking about it more, I'm not sure what I just wrote is correct. Why do we need client connection IDs to be unique?",
          "createdAt": "2020-07-20T19:40:18Z",
          "updatedAt": "2020-07-20T19:40:18Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that we can close this issue in favor of #21 and #22. I tried to explain my thoughts there better than I had in the email that led to opening this issue...",
          "createdAt": "2020-10-14T03:12:30Z",
          "updatedAt": "2020-10-14T03:12:30Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Sounds good to me!",
          "createdAt": "2020-10-14T18:25:35Z",
          "updatedAt": "2020-10-14T18:25:35Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU2NjIxODY1MDM=",
      "title": "Discuss cases when QUIC is blocked",
      "url": "https://github.com/tfpauly/quic-proxy/issues/4",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-20T19:36:50Z",
      "updatedAt": "2020-10-16T18:57:29Z",
      "closedAt": "2020-10-16T18:57:29Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "I think this is no longer an issue now that we're an extension of CONNECT-UDP, and define that we just don't echo the headers if we're not over H3",
          "createdAt": "2020-10-16T18:57:29Z",
          "updatedAt": "2020-10-16T18:57:29Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU3MTIyOTA5MDc=",
      "title": "Non HTTP/3 proxies handling of the method",
      "url": "https://github.com/tfpauly/quic-proxy/issues/5",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Ready for Text"
      ],
      "body": "The spec says:\r\n\r\n> The CONNECT-QUIC method as defined in this document can only be supported by an HTTP/3 proxy. Use of CONNECT-QUIC with older HTTP versions is undefined and MUST be rejected.\r\n\r\nBut RFC7231 says: \r\n   > When a request method is received\r\n   that is unrecognized or not implemented by an origin server, the\r\n   origin server SHOULD respond with the 501 (Not Implemented) status\r\n   code.\r\n\r\nJust checking the two statements are compatible.",
      "createdAt": "2020-09-30T21:24:09Z",
      "updatedAt": "2020-10-09T16:57:51Z",
      "closedAt": "2020-10-09T16:57:51Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Yeah, we should just have the 501 behavior",
          "createdAt": "2020-10-08T16:05:00Z",
          "updatedAt": "2020-10-08T16:05:00Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWU3MTIyOTYwMDA=",
      "title": "Message bodies",
      "url": "https://github.com/tfpauly/quic-proxy/issues/6",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Ready for Text"
      ],
      "body": "The spec says:\r\n\r\n> Body payloads within CONNECT-QUIC requests are undefined, and SHOULD be treated as malformed.\r\n\r\nbut https://tools.ietf.org/html/draft-ietf-httpbis-semantics-11#section-8.4.2 says\r\n\r\n>    Since message parsing (Section 6 of [Messaging]) needs to be\r\n   independent of method semantics (aside from responses to HEAD),\r\n   definitions of new methods cannot change the parsing algorithm or\r\n   prohibit the presence of a message body on either the request or the\r\n   response message.  Definitions of new methods can specify that only a\r\n   zero-length message body is allowed by requiring a Content-Length\r\n   header field with a value of \"0\".\r\n\r\nYou might get a question from the HTTP police.",
      "createdAt": "2020-09-30T21:33:46Z",
      "updatedAt": "2020-10-09T16:57:51Z",
      "closedAt": "2020-10-09T16:57:51Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Yeah, we should require Content-Length 0.",
          "createdAt": "2020-10-08T16:06:39Z",
          "updatedAt": "2020-10-08T16:06:39Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWU3MTIzMDM1NDI=",
      "title": "What does a proxy do with short packets unrelated to a ID?",
      "url": "https://github.com/tfpauly/quic-proxy/issues/7",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Ready for Text"
      ],
      "body": "The Spec says\r\n\r\n> Packets forwarded by sending directly to the proxy's IP address and port MUST wait for a successful response to the CONNECT-QUIC request. This ensures that the proxy knows how to forward a given packet.\r\n\r\n> Clients sending QUIC Long Header packets MUST tunnel them within DATAGRAM frames to avoid exposing unnecessary connection metadata. QUIC Short Header packets, on the other hand, can send directly to the proxy (without any tunnelling or encapsulation) once the proxy has sent a successful response for the Server Connection ID.\r\n\r\nThis all makes sense but it's a little light on information about what the proxy should do with packets that are sent to it before the CONNECT-QUIC response. There's two scenarios I picture:\r\n\r\n1) completely unknown short packets. Probably just drop them on the floor?\r\n2) short packets for known IDs (request received) but before the server has sent the response. Probably just drop them on the floor?",
      "createdAt": "2020-09-30T21:48:43Z",
      "updatedAt": "2020-10-09T16:57:51Z",
      "closedAt": "2020-10-09T16:57:51Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "I think the proxy should drop any packets that it hasn't sent a response for. The client can also do DATAGRAM tunneling until it gets the response.",
          "createdAt": "2020-10-08T21:37:26Z",
          "updatedAt": "2020-10-08T21:37:26Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWU3MTIzMDYzNzc=",
      "title": "Handling multiple headers of the same type per request?",
      "url": "https://github.com/tfpauly/quic-proxy/issues/8",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There's some clear requirements on minimum headers\r\n\r\n> Validating that the request include one of either the Client-Connection-Id and the Server-Connection-Id header, along with a Datagram-Flow-Id header. Requests absent any connection ID header MUST be rejected.\r\n\r\nWhat about a proxy that receives multiple headers of the same type, e.g something like\r\n\r\n```\r\nHEADERS\r\n:method = CONNECT-QUIC\r\n:authority = target.example.com:443\r\nclient-connection-id = :MTIzNA==:, :MTIzNB==: \r\ndatagram-flow-id = 1\r\n```\r\n",
      "createdAt": "2020-09-30T21:54:36Z",
      "updatedAt": "2020-10-09T16:57:51Z",
      "closedAt": "2020-10-09T16:57:51Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "My confusion may in part be related to how the headers are presented. In connect-udp they say\r\n\r\n```\r\n   \"Datagram-Flow-Id\" is a Item Structured Header [STRUCT-HDR].  Its\r\n   value MUST be an Integer.\r\n```",
          "createdAt": "2020-09-30T22:20:36Z",
          "updatedAt": "2020-09-30T22:20:36Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Isn't that covered by this?\r\n\r\n```\r\nThe \"Datagram-Flow-ID\" header is an Integer Structured Field {{!I-D.ietf-httpbis-header-structure}}\r\ncontaining the QUIC datagram flow ID to use for tunnelling packets {{!I-D.schinazi-quic-h3-datagram}}\r\n{{!I-D.ietf-quic-datagram}}. The ABNF is:\r\n\r\n~~~\r\n  Datagram-Flow-Id = sf-integer\r\n~~~\r\n```",
          "createdAt": "2020-10-08T21:41:59Z",
          "updatedAt": "2020-10-08T21:41:59Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah I think we just need to state that the headers defined here are `Item` Structured Fields that must be integer.",
          "createdAt": "2020-10-08T22:10:02Z",
          "updatedAt": "2020-10-08T22:10:02Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWU3MTIzMTAxNTI=",
      "title": "Mapping lifetime and stream states",
      "url": "https://github.com/tfpauly/quic-proxy/issues/10",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Ready for Text"
      ],
      "body": "The spec says:\r\n\r\n> A client that no longer wants a given Connection ID to be forwarded by the proxy, for either direction, MUST reset the stream.\r\n\r\nWhile https://tools.ietf.org/html/draft-ietf-quic-transport-31#section-2.4 says:\r\n\r\n```\r\nOn the sending part of a stream, an application protocol can:\r\n\r\n   *  write data, understanding when stream flow control credit\r\n      (Section 4.1) has successfully been reserved to send the written\r\n      data;\r\n\r\n   *  end the stream (clean termination), resulting in a STREAM frame\r\n      (Section 19.8) with the FIN bit set; and\r\n\r\n   *  reset the stream (abrupt termination), resulting in a RESET_STREAM\r\n      frame (Section 19.4) if the stream was not already in a terminal\r\n      state.\r\n\r\n   On the receiving part of a stream, an application protocol can:\r\n\r\n   *  read data; and\r\n\r\n   *  abort reading of the stream and request closure, possibly\r\n      resulting in a STOP_SENDING frame (Section 19.5).\r\n```\r\n\r\nHTTP/3 approaches this by saying\r\n\r\n```\r\n   Implementations SHOULD cancel requests by abruptly terminating any\r\n   directions of a stream that are still open.  This means resetting the\r\n   sending parts of streams and aborting reading on receiving parts of\r\n   streams; see Section 2.4 of [QUIC-TRANSPORT].\r\n```\r\n\r\nWould it be clearer to lean on HTTP/3 for the CONNECT-UDP client behavior, or is something specific intended with the current text?",
      "createdAt": "2020-09-30T22:02:00Z",
      "updatedAt": "2020-10-09T16:57:52Z",
      "closedAt": "2020-10-09T16:57:52Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Yeah, let's just say it cancels the HTTP/3 request.",
          "createdAt": "2020-10-08T21:50:09Z",
          "updatedAt": "2020-10-08T21:50:09Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "MDU6SXNzdWU3MTIzMTEyODk=",
      "title": "Flow ID example values are wrong?",
      "url": "https://github.com/tfpauly/quic-proxy/issues/11",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Ready for Text"
      ],
      "body": "The spec uses `datagram-flow-id = 1`. \r\n\r\nBut https://tools.ietf.org/html/draft-schinazi-quic-h3-datagram-04#section-3 says\r\n\r\n> Even flow identifiers are client-initiated, while odd flow\r\n   identifiers are server-initiated.",
      "createdAt": "2020-09-30T22:04:16Z",
      "updatedAt": "2020-10-09T16:57:52Z",
      "closedAt": "2020-10-09T16:57:52Z",
      "comments": []
    },
    {
      "number": 12,
      "id": "MDU6SXNzdWU3MTIzMTQxMjg=",
      "title": "Is it an error to tunnel short packets?",
      "url": "https://github.com/tfpauly/quic-proxy/issues/12",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Ready for Text"
      ],
      "body": "I can guess at the answer, but is it an error to send short packets in DATAGRAMS using a valid flow ID?",
      "createdAt": "2020-09-30T22:10:18Z",
      "updatedAt": "2020-10-09T16:57:52Z",
      "closedAt": "2020-10-09T16:57:52Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "It's not an error, no. If an endpoint wants to do that, it can. I'll add text to clarify this.",
          "createdAt": "2020-10-08T16:10:46Z",
          "updatedAt": "2020-10-08T16:10:46Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "MDU6SXNzdWU3MTIzMTU4Mjc=",
      "title": "Is proxy handling of un-tunneled Long packets an unenforceable MUST?",
      "url": "https://github.com/tfpauly/quic-proxy/issues/13",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Discuss"
      ],
      "body": "The client requirement is clear but is this enforcable at the proxy? Could you explicitly mark Initials intended for CONNECT-UDP, so that a proxy can spot them and enforce?",
      "createdAt": "2020-09-30T22:13:51Z",
      "updatedAt": "2020-10-09T16:57:52Z",
      "closedAt": "2020-10-09T16:57:52Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "I assume that the proxy could, if it wanted to enforce this, ensure that it never forwarded packets with the long header bit set. Does that work?",
          "createdAt": "2020-10-08T21:33:16Z",
          "updatedAt": "2020-10-08T21:33:16Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWU3MTI5NjkxODA=",
      "title": "Does the proxy echo IDs in the response",
      "url": "https://github.com/tfpauly/quic-proxy/issues/14",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I might have missed this. In h3 datagram, datagram-flow-id is echoed in the response. In connect-quic, should the IDs be echoed?",
      "createdAt": "2020-10-01T15:50:37Z",
      "updatedAt": "2020-10-08T21:36:06Z",
      "closedAt": "2020-10-08T21:36:06Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "```\r\nThis response MUST also echo any Client-Connection-Id, Server-Connection-Id, and\r\nDatagram-Flow-Id headers included in the request.\r\n```\r\nSeems to be there already =)",
          "createdAt": "2020-10-08T21:36:06Z",
          "updatedAt": "2020-10-08T21:36:06Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWU3MTYwMjU5MDM=",
      "title": "Idle timeouts and forwarded packets",
      "url": "https://github.com/tfpauly/quic-proxy/issues/15",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Ready for Text"
      ],
      "body": "How do forwarded packets play with the proxy<->client QUIC connection idle timeout behaviour https://tools.ietf.org/html/draft-ietf-quic-transport-31#section-10.1? Does a client need to keepalive the QUIC connection (e.g. PING) in addition to sending packets to be forwarded. It would seem easier for those packets to somehow reset the timer. If that's the intention the spec should say something.",
      "createdAt": "2020-10-06T21:13:17Z",
      "updatedAt": "2020-10-09T16:57:52Z",
      "closedAt": "2020-10-09T16:57:52Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "I think that the forwarded packets should indeed reset the timer. I view it similarly to the idle state that the kernel keeps for IPsec SAs to let an IKE engine know if it should tear down.\r\n\r\nAny issue with saying we should have the timer be kept alive by forwarded packets?",
          "createdAt": "2020-10-08T19:05:49Z",
          "updatedAt": "2020-10-08T19:05:49Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "No issue with it resetting a timer. But I've not thought through all the edge cases. Does it apply in both directions or do we want to reset only on client->proxy packets?",
          "createdAt": "2020-10-08T19:08:41Z",
          "updatedAt": "2020-10-08T19:08:41Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "the reason I ask is because if the client goes away, a large response could keep the connection alive indefinitely. Reseting on client->proxy would naturally reflect the client Acks (and this active relationship) to the origin.",
          "createdAt": "2020-10-08T19:12:34Z",
          "updatedAt": "2020-10-08T19:12:34Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Yeah, having this be kept alive based on client -> proxy sounds right.",
          "createdAt": "2020-10-08T21:16:14Z",
          "updatedAt": "2020-10-08T21:16:14Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "MDU6SXNzdWU3MTgwOTEzODQ=",
      "title": "Proxy handling of Connection ID resuse",
      "url": "https://github.com/tfpauly/quic-proxy/issues/17",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "So the spec says:\r\n\r\n> For any non-zero-length Client Connection ID, the Connection ID MUST be unique\r\nacross all other clients.\r\n\r\nWhat does a proxy do if it detects this is not the case? The logical thing seems to be to fail fast, reject the 2nd CONNECT-QUIC that attempts to reuse an ID already taken. Not sure of a status code - 409 maybe?\r\n\r\n",
      "createdAt": "2020-10-09T12:04:22Z",
      "updatedAt": "2020-10-16T18:56:50Z",
      "closedAt": "2020-10-16T18:56:49Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Yeah, I was thinking it would reject any reused ID.",
          "createdAt": "2020-10-09T23:37:45Z",
          "updatedAt": "2020-10-09T23:37:45Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Addressed by #24",
          "createdAt": "2020-10-16T18:56:49Z",
          "updatedAt": "2020-10-16T18:56:49Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "MDU6SXNzdWU3MTgwOTMzNTU=",
      "title": "Proxy behaviour when both ends use 0-length Connection IDs",
      "url": "https://github.com/tfpauly/quic-proxy/issues/18",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is one of \"what if\" curveball questions, sorry.\r\n\r\nBut what if both sides want to use 0-length? When forwarding Short packets, the proxy has to resort to IP:port based forwarding in both directions? ",
      "createdAt": "2020-10-09T12:07:55Z",
      "updatedAt": "2020-10-16T18:55:23Z",
      "closedAt": "2020-10-16T18:55:23Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Yes, if both sides use 0-length, the forwarding must reduce to IP-port mappings. We should add a nice table of how to handle these cases =)",
          "createdAt": "2020-10-09T23:36:35Z",
          "updatedAt": "2020-10-09T23:36:35Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Should be addressed by #24 ",
          "createdAt": "2020-10-16T18:55:23Z",
          "updatedAt": "2020-10-16T18:55:23Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWU3MjEwODE5MzE=",
      "title": "Reusing DATAGRAM Flow IDs",
      "url": "https://github.com/tfpauly/quic-proxy/issues/20",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the Example section, the spec reuses the same Flow ID for two separate CONNECT-QUIC requests. That seems like a reasonable choice to me, but the spec should explicitly call out that this is allowed, and that the proxy should validate that upon receiving a new CONNECT-UDP request that reuses a flow ID, the authority must match the authority of the first CONNECT-QUIC request that used the same flow ID.",
      "createdAt": "2020-10-14T02:25:22Z",
      "updatedAt": "2020-10-16T18:56:02Z",
      "closedAt": "2020-10-16T18:56:02Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Agreed, good to clarify.",
          "createdAt": "2020-10-14T18:26:13Z",
          "updatedAt": "2020-10-14T18:26:13Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Addressed by #24",
          "createdAt": "2020-10-16T18:56:02Z",
          "updatedAt": "2020-10-16T18:56:02Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "MDU6SXNzdWU3MjEwODUxMTY=",
      "title": "Mapping details don't seem right",
      "url": "https://github.com/tfpauly/quic-proxy/issues/21",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The only details about how mappings work seem to be this part of the \"Proxy Response Behavior\" section:\r\n> Creating a mapping entry for the QUIC Connection ID in the given direction (client or target server) associated with the client's IP address and UDP port. For any non-zero-length Client Connection ID, the Connection ID MUST be unique across all other clients.\r\n\r\nThat's not right. You need at least the following mappings:\r\n- from flow ID to target IP/port (for tunneling)\r\n- from Server Connection ID to target IP/port (for forwarding)\r\n- from target IP/port to (QUIC connection, flow ID) (for tunneling)\r\n- from target IP/port to client IP/port (for forwarding)",
      "createdAt": "2020-10-14T02:34:11Z",
      "updatedAt": "2020-10-16T18:55:43Z",
      "closedAt": "2020-10-16T18:55:42Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Addressed by #24",
          "createdAt": "2020-10-16T18:55:42Z",
          "updatedAt": "2020-10-16T18:55:42Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "MDU6SXNzdWU3MjEwODc4MDA=",
      "title": "Is the concept of a \"Client Connection ID\" needed?",
      "url": "https://github.com/tfpauly/quic-proxy/issues/22",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The document mentions the concept of a \"Client Connection ID\", but I'm not sure they serve any purpose.\r\n\r\nFor example:\r\n> Clients SHOULD establish mappings for any Client Connection ID values it provides to the destination target. Failure to do so will prevent the target from initiating connection migration probes along new paths.\r\n\r\nWhat is the Client Connection ID mapped *to*? (see #21 about clarifying that)\r\n\r\nIf you create one UDP socket per CONNECT-QUIC request, then you don't need the concept of a Client Connection ID. The server knows how to route packets simply based on the UDP socket they came in on.\r\n\r\nThe draft mentions validating that a Client Connection ID has been properly registered before allowing its use, but I don't see what benefit that provides.\r\n\r\nI feel like this concept might have been inherited from [the original MASQUE QUIC Proxying](https://tools.ietf.org/html/draft-schinazi-masque-protocol-01#section-3.3) but there it was needed to allow the MASQUE server to only use one UDP port, which isn't a requirement here. Am I missing something?",
      "createdAt": "2020-10-14T02:41:57Z",
      "updatedAt": "2020-10-16T18:56:23Z",
      "closedAt": "2020-10-16T18:56:23Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Addressed by #24",
          "createdAt": "2020-10-16T18:56:23Z",
          "updatedAt": "2020-10-16T18:56:23Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "MDU6SXNzdWU3MjEwOTU2MzI=",
      "title": "Forwarding mode cannot work reliably as currently defined",
      "url": "https://github.com/tfpauly/quic-proxy/issues/23",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Forwarding mode works by having the proxy demultiplex incoming packets by looking at the Destination Connection ID field in short headers: if it's a registered \"Server Connection ID\", it gets forwarded to the target; otherwise, it gets processed as a QUIC packet intended for the proxy itself.\r\n\r\nUnfortunately, Server Connection IDs are not under the control of the proxy, they're under the control of the target(s). So that means that there can easily be conflicts. The fact that short header packets do not carry the connection ID length complicates this further: any connection being a prefix of another one also constitutes a conflict. In the worse case scenario, a single target using zero-length connection IDs would conflict with all other Server Connection IDs.\r\n\r\nIn #17 and #18, a proposed solution is to reject CONNECT-QUIC requests whose Server Connection IDs conflict with existing mappings. This would mean that this protocol would be completely unable to handle a set of targets, which would be unfortunate.\r\n\r\nHowever, we could solve this issue by making the forwarding mode negotiable. Here's a straw man: the client adds a `Forwarding-Mode: 0/1` header to its request to tell the proxy whether it wants forwarding mode for this request or not, and the proxy replies with the same header to indicate whether forwarding mode is allowed for this request. That way, if the server detects a conflict, it gracefully falls back to tunneled mode and everything still works. (Bonus 1: this also allows us to support proxies behind load balancers, they just need to disable forwarding) (Bonus 2: this also allows us to support the [MASQUE Obfuscation](https://tools.ietf.org/html/draft-schinazi-masque-obfuscation-03) use-case by letting the client disable forwarding)",
      "createdAt": "2020-10-14T03:04:19Z",
      "updatedAt": "2020-10-16T18:55:52Z",
      "closedAt": "2020-10-16T18:55:51Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Yeah, I was expecting that a forwarding mapping failing would mean we'd have to fall back to tunneled mode anyhow. I'll specify this more clearly, as it is the intent.",
          "createdAt": "2020-10-14T18:33:25Z",
          "updatedAt": "2020-10-14T18:33:25Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Addressed by #24",
          "createdAt": "2020-10-16T18:55:51Z",
          "updatedAt": "2020-10-16T18:55:51Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWU3MjMzOTgzNzc=",
      "title": "Improve stream lifecycle description",
      "url": "https://github.com/tfpauly/quic-proxy/issues/26",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "WRT the Removing Mapping State section\r\n\r\n>This section reads a little weird. I'll make a spin off issueo work on improvements for talking about request stream lifecycle; it should also cover the similar stuff described in H3's CONNECT section like what frames are valid.\r\n\r\n_Originally posted by @LPardue in https://github.com/tfpauly/quic-proxy/pull/24#r505857928_ ",
      "createdAt": "2020-10-16T17:20:33Z",
      "updatedAt": "2020-10-16T21:14:07Z",
      "closedAt": "2020-10-16T21:14:07Z",
      "comments": []
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWU3MjM0MTA2MzU=",
      "title": "Mention something about versions",
      "url": "https://github.com/tfpauly/quic-proxy/issues/27",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I was surprised to see nothing mentioned about versions. Do you picture an HTTP/3 MASQUE server (so QUIC v1) being able to forward packets for other versions of QUIC?",
      "createdAt": "2020-10-16T17:37:12Z",
      "updatedAt": "2020-10-16T21:14:07Z",
      "closedAt": "2020-10-16T21:14:07Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that, when looking at proxied connections and packets, the proxy only ever uses the concept of Connection ID, and it only looks at QUIC header fields that are part of the invariants. So everything should just work with all versions of QUIC. But at the same time, we have requirements on client behavior (when to send NEW_CONNECTION_ID) that are specific to QUICv1. So we may want to add a paragraph that explains that this should work with all versions but the requirements are described in terms of QUICv1",
          "createdAt": "2020-10-16T18:07:57Z",
          "updatedAt": "2020-10-16T18:07:57Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "A short statement about invariants would work for me.",
          "createdAt": "2020-10-16T18:10:42Z",
          "updatedAt": "2020-10-16T18:10:42Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "MDU6SXNzdWU3NDIwMDU0MzY=",
      "title": "Provide advice about initial MSS of QUIC connections to proxies",
      "url": "https://github.com/tfpauly/quic-proxy/issues/33",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "OWNER",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Ready for Text"
      ],
      "body": "Rather that just using 1200 bytes, QUIC connections to proxies should add extra bytes to account for proxied QUIC connections that will themselves send initial packets of 1200 bytes that will need to fit in DATAGRAM frames.",
      "createdAt": "2020-11-12T23:33:07Z",
      "updatedAt": "2021-04-13T18:54:48Z",
      "closedAt": "2021-04-13T18:54:48Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Can you elaborate please? Where would extra bytes be added?",
          "createdAt": "2020-11-12T23:49:03Z",
          "updatedAt": "2020-11-12T23:49:03Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Say you know you want to proxy QUIC over QUIC. You know that your proxied QUIC connection will need to send a QUIC initial of 1200 bytes. This means you need to be able to send at least 1200-byte DATAGRAM frames.\r\n\r\nIf the QUIC connection to the proxy starts with an MSS of 1200 bytes, you either need to ramp up your effective MSS enough to handle larger frames (such as via path MTU discovery, or just bumping it up optimistically), or you choose a slightly larger initial packet size. Choosing a larger packet size also has the nice benefit of ensuring that the path can actually handle your traffic without risking finding out later it won't work.\r\n\r\nI'm saying we should have text around this topic, and it seems simple to recommend that clients choose a slightly larger initial packet size to the proxy.",
          "createdAt": "2020-11-12T23:52:26Z",
          "updatedAt": "2020-11-12T23:52:26Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, I understand. Our implementation uses a MSS of 1350 and falls back to TCP if that doesn't go through. Adding text to suggest that or PMTUD sounds good to me.",
          "createdAt": "2020-11-13T00:39:29Z",
          "updatedAt": "2020-11-13T00:39:29Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "MDU6SXNzdWU3NDY2NjUyOTk=",
      "title": "Detecting Connection mapping conflicts",
      "url": "https://github.com/tfpauly/quic-proxy/issues/34",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Ready for Text"
      ],
      "body": "Section 2.4 \r\n\r\n\"The proxy treats two mappings as being in conflict when a conflict is detected for all elements on the left side of the mapping diagrams above.\"\r\n\r\nI think diagrams makes it uncertain what is referred to here. I assume it is the mapping statements in Section 2.1-2.3. \r\n\r\nI think this statement is missing to detect conflicts for the case related to proxy reuse request that are not QUIC flows. Thus two rules are missing. A server-socket that doesn't have any connection-IDs bound to it can't be reused as this is in non-QUIC mode. Secondly, any attempt to reuse a server-socket that has one or more connection-IDs bound to it must not be reused by a connection-ID less request. \r\n\r\nI think maybe a table in this section would be clearer for which values to check to ensure that mapping is okay. \r\n\r\n\r\n\r\n",
      "createdAt": "2020-11-19T15:06:11Z",
      "updatedAt": "2021-04-13T18:52:19Z",
      "closedAt": "2021-04-13T18:52:19Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Sure, I think the \"no-connection-ID\" case can fold into an empty connection ID, but we can describe that. That would make the rules work as is.",
          "createdAt": "2020-11-19T20:36:31Z",
          "updatedAt": "2020-11-19T20:36:31Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "@tfpauly that can probably be made to work but the case do need consideration as a CONNECT-UDP request without client-connection-ID need to behave as it gotten client-connection-ID=0. I don't think you can \"upgrade\" a existing connection to forwarding mode, if the first CONNECT-UDP request didn't include a client-connection-id. ",
          "createdAt": "2020-11-20T05:26:40Z",
          "updatedAt": "2020-11-20T05:26:40Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Yes, I think we should specify that no connection ID is equivalent to setting 0 as the connection ID\u2014it means no socket reuse and prohibits forwarding later.",
          "createdAt": "2020-11-20T07:00:00Z",
          "updatedAt": "2020-11-20T07:00:00Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWU3NDY2ODYwNTU=",
      "title": "Poor guidance on rejecting short CIDs ",
      "url": "https://github.com/tfpauly/quic-proxy/issues/35",
      "state": "OPEN",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Detecting Conflict section (2.4) states:\r\n\r\n\"Since very short Connection IDs are more likely to lead to conflicts, particularly zero-length Connection IDs, a proxy MAY choose to reject all requests for very short Connection IDs as conflicts, in anticipation of future conflicts.\"\r\n\r\nSo I think there need to be a framing question for the below. Is the goal here to have multiple different clients with connection-ID to reuse a common server-socket. So that all clients behind a particular MASQUE server wanting to reach popular-service UDP-port=443 will use the same server socket? \r\n\r\nIf that is the case then I can partially understand the MAY to avoid causing clients with long CIDs getting its different CID using different 5-tuples towards the target.\r\n\r\nHow much analysis have you done for what consequences that will result. Having multiple non-coordinated traffic flows share the same 5-tuple will make it very much like a tunnel flow, however this one will most likely be directed to a server. Will that have any strange affect on load-balancing, denial of service mitigation. I see that a bot behind a particular MASQUE service could attempting to share 5-tuple with other clients and use that to DoS those other flows by triggering DoS mitigations for this flow. \r\n\r\nAlso, are you really meaning reject, or simply detect the collision and give the client a new server-socket?\r\n\r\nIf multiple MASQUE client's are not sharing the server-socket then I think this is an unnecessary recommendation that causes issues without any benefit. \r\n\r\nSo the client that attempt to map multiple QUIC CIDs, that might even be the same QUIC connection, to a particular server-socket will likely do this by being aware of this. Thus it will coordinate so that it doesn't conflict. Even if they are uncoordinated there are no point of rejecting a working mapping because it might result in failure later. If the mapping fails, then the proxy simply creates a new server-socket and give it to the client. Rejecting the mapping prior to a conflict occurring and thus using more resource unnecessarily. \r\n\r\nIn the case of totally uncoordinated QUIC connection where one use short CIDs and the other long ones, then I think if there are any considerations to avoid issues for this, that should fall on the client rather than the server to not attempt to map these two connections to the same server-side socket. This collision algorithm is simple and can be run by the client also for those resource it requests.  \r\n",
      "createdAt": "2020-11-19T15:30:45Z",
      "updatedAt": "2020-11-19T20:39:20Z",
      "closedAt": null,
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "An addition here is that maybe there is a need to tease this apart for what occurs on the client-proxy 5-tuple and what happens on the proxy-target 5-tuple. I was very much only thinking of  the later when I wrote the above. \r\n\r\nFor the client-proxy I think we should discuss if there are need for additional client-proxy 5-tuples (different client side UDP ports) to deal with the conflicts from completely uncoordinated CID usage to enable forwarding of these packets? That would require the ports to established and likely some path probing to be done, so possibly a conflict would require additional QUIC connection establishment to the proxy? ",
          "createdAt": "2020-11-19T15:53:17Z",
          "updatedAt": "2020-11-19T15:53:17Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Connection ID awareness doesn't force a server to reuse a UDP socket, but it allows it.\r\n\r\nDepending on the proxy configuration, if it knows it needs to always optimize for forwarding mode, the proxy MAY choose to reject clients that are requesting zero-length CIDs, because it shows that they might be misconfigured and will interfere with the forwarding operation.\r\n\r\nI think the key point here is that the clients are always aware they are proxying, and thus are able to choose good CID lengths; this isn't entirely uncoordinated.",
          "createdAt": "2020-11-19T20:39:20Z",
          "updatedAt": "2020-11-19T20:39:20Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "MDU6SXNzdWU3NDY3MDc1NjE=",
      "title": "Proxy Response Behavior use of server",
      "url": "https://github.com/tfpauly/quic-proxy/issues/36",
      "state": "OPEN",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This section needs a clean up in terminology. It uses \"server-facing socket\" which propably should be changed to \"target-facing socket\". \r\n\r\n",
      "createdAt": "2020-11-19T15:56:48Z",
      "updatedAt": "2020-11-19T20:40:18Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "It could be \"target-facing\", yes, but the end-to-end QUIC connection is thought of in terms of Client and Server, too. ",
          "createdAt": "2020-11-19T20:40:18Z",
          "updatedAt": "2020-11-19T20:40:18Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWU3NDY3MTkyMDg=",
      "title": "Example unclear about long headers",
      "url": "https://github.com/tfpauly/quic-proxy/issues/37",
      "state": "OPEN",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The example states:\r\n\r\n\r\n   When the proxy receives a response from target.example.com:443 that\r\n   has 0x31323334 as the Destination Connection ID, the proxy will\r\n   forward that packet to the client on DATAGRAM flow ID 2.\r\n\r\nAnd the later:\r\n\r\n   Upon receiving the response, the client starts sending Short Header\r\n   packets with a Destination Connection ID of 0x61626364 directly to\r\n   the proxy (not tunnelled), and these are forwarded directly to the\r\n   target by the proxy.  Similarly, Short Header packets from the target\r\n   with a Destination Connection ID of 0x31323334 are forwarded directly\r\n   to the client.\r\n\r\nSo the first paragraph I think it is correct as far as long header packets are received. However, will not short header packets from the target arriving at the proxy be forwarded to the client, even if the second request never happened. Thus, the implied connection to the response in the last sentence of the second paragraph is misleading.\r\n",
      "createdAt": "2020-11-19T16:10:16Z",
      "updatedAt": "2020-11-19T20:41:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Forwarding mode does rely on the second request being accepted, to allow the server to choose whether or not to forward. This doesn't support only forwarding in one direction, which we deemed to not be a useful feature.",
          "createdAt": "2020-11-19T20:41:50Z",
          "updatedAt": "2020-11-19T20:41:50Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "MDU6SXNzdWU3NDY3MjU2NjE=",
      "title": "Security Consideration and shared server-sockets between clients",
      "url": "https://github.com/tfpauly/quic-proxy/issues/38",
      "state": "OPEN",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Lets pull out one issue from #35 that likely need separate treatment.\r\n\r\nSo the security consideration says: \r\n\r\n   Since proxies that forward QUIC packets do not perform any\r\n   cryptographic integrity check, it is possible that these packets are\r\n   either malformed, replays, or otherwise malicious.  This may result\r\n   in proxy targets rate limiting or decreasing the reputation of a\r\n   given proxy.\r\n\r\nSo this is indicating that you agree that forwarded traffic may misbehave and cause reactions in the network. Based on this I think any reuse of 5-tuples between the proxy and the target between multiple clients results in that one MASQUE client and its users could affect the flow of another MASQUE client through its traffic beyond traffic volume. I think that should most definitely be discussed, and I think this is to dangerous and should be recommended against. \r\n\r\nI further think client's need to have some control over re-use of target facing proxy-socket. This as a MASQUE client that represent multiple different users, for example some type of gateway from a network may not have trust in that all its users are good behaving citizens and thus one users traffic should not have fatesharing with another. ",
      "createdAt": "2020-11-19T16:18:04Z",
      "updatedAt": "2020-11-19T20:44:06Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Which I see the concerns, I think we should describe them rather than prohibit anything. If the target is well-known, such as another proxy if we are doing multiple proxy hops, then the concerns about reuse may not apply.",
          "createdAt": "2020-11-19T20:44:05Z",
          "updatedAt": "2020-11-19T20:44:05Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "MDU6SXNzdWU3NDY3MzIyMjc=",
      "title": "Signalling for rate-limits for a client?",
      "url": "https://github.com/tfpauly/quic-proxy/issues/39",
      "state": "OPEN",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The draft do discuss the aspect that the proxy may rate limit a client. Should there actually be explicit signalling of these rates to the client. \r\n\r\nI also assume these parameters are on client level and thus apply across the different UDP flows. ",
      "createdAt": "2020-11-19T16:25:42Z",
      "updatedAt": "2020-11-20T06:58:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "The rate-limiting here is referring to the number of CONNECT or CONNECT-UDP requests the proxy allows for a given client. This would translate into delayed or rejected requests, as a normal HTTP proxy behavior.",
          "createdAt": "2020-11-19T20:45:42Z",
          "updatedAt": "2020-11-19T20:45:42Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah. I think there is nothing special to do here, implementations or deployments can leverage HTTP layer mechanisms if they care. (A big advantage of MASQUE!)",
          "createdAt": "2020-11-19T22:36:17Z",
          "updatedAt": "2020-11-19T22:37:00Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "No, I meant any limits in bits or number of packets. ",
          "createdAt": "2020-11-20T05:10:40Z",
          "updatedAt": "2020-11-20T05:10:40Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Unless something like this already exists for CONNECT in HTTP/1.1 or HTTP/2 I don't know that we need to do anything. ",
          "createdAt": "2020-11-20T05:23:41Z",
          "updatedAt": "2020-11-20T05:23:41Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "@gloinul I think having strict limits on the number of packets or bytes that go through a proxy connection could be enforced by a proxy closing a given CONNECT request stream if it violates a policy. If you want explicit signaling about expected rates or datagram flow control, that'd need to be another separate extension.",
          "createdAt": "2020-11-20T06:58:53Z",
          "updatedAt": "2020-11-20T06:58:53Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "MDU6SXNzdWU3ODYzNDI1Njk=",
      "title": "Clarify that a server-facing socket used for QUIC CIDs should not be shared with non-QUIC flows",
      "url": "https://github.com/tfpauly/quic-proxy/issues/40",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "If a server-facing socket on a CONNECT-UDP proxy is being shared for multiple proxied QUIC connections, and demuxing by CID, it cannot easily/safely share the socket with other CONNECT-UDP connections that do not indicate a QUIC CID. This is implicit in the text, but not stated directly.\r\n\r\nA corollary of this is that any packet received on a shared socket that doesn't match a known CID must be dropped.",
      "createdAt": "2021-01-14T21:09:49Z",
      "updatedAt": "2021-04-13T18:52:35Z",
      "closedAt": "2021-04-13T18:52:35Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed.",
          "createdAt": "2021-01-14T21:13:23Z",
          "updatedAt": "2021-01-14T21:13:23Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "MDU6SXNzdWU4MjMyNzc4MzA=",
      "title": "Discuss connection migration",
      "url": "https://github.com/tfpauly/quic-proxy/issues/41",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Connection migration events on a proxy should make it control the pacing of packets being forwarded on a new path until the path is validated. This is necessary to avoid having the target blast a huge amount of data onto a new path that may have different congestion characteristics, or may not have a real client there at all.",
      "createdAt": "2021-03-05T17:23:01Z",
      "updatedAt": "2021-04-13T18:52:09Z",
      "closedAt": "2021-04-13T18:52:09Z",
      "comments": []
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWU4MjkzMjM2OTc=",
      "title": "Discuss loop attack prevention",
      "url": "https://github.com/tfpauly/quic-proxy/issues/42",
      "state": "OPEN",
      "author": "tfpauly",
      "authorAssociation": "OWNER",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "If a proxy does not enforce the uniqueness of mappings from client-to-proxy connections and server CIDs to server-facing sockets, it is possible for a client to induce packet loops through the proxies. We should discuss this and explain in security considerations why this is critical to avoid.\r\n\r\nI think this also means we should make the mapping requirement in Section 2.2 more stringent to be unique not only for the client-facing socket, but also the client QUIC connection.",
      "createdAt": "2021-03-11T16:40:36Z",
      "updatedAt": "2021-03-17T15:44:52Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "We should also add text to ensure that proxies MUST validate the source IP address of incoming packets when checking the CID mapping - that way a node can't cause a loop without being in the loop itself (which defeats the amplification purpose of creating a loop).",
          "createdAt": "2021-03-11T17:07:57Z",
          "updatedAt": "2021-03-11T17:07:57Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Great point!",
          "createdAt": "2021-03-11T19:21:00Z",
          "updatedAt": "2021-03-11T19:21:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "It's probably worth clarifying -- beyond what's already there -- that sockets mean 5 tuples here, and maybe even removing the word socket altogether. That seems like an implementation detail. And I can definitely imagine implementations binding to * as their socket and determining the 5 tuple only upon reading a packet.",
          "createdAt": "2021-03-17T01:25:59Z",
          "updatedAt": "2021-03-17T01:25:59Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Agree with Chris, perhaps the term \"socket\" in the draft is more confusing than just using \"5-tuple\"? Many people think of a socket as a non-connected socket.",
          "createdAt": "2021-03-17T02:27:33Z",
          "updatedAt": "2021-03-17T02:27:33Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Yeah, we can call it a 5-tuple, or just a tuple. My main concern is how easy to understand the terms \"client-facing 5-tuple\" and \"server-facing 5-tuple\" are.",
          "createdAt": "2021-03-17T15:44:52Z",
          "updatedAt": "2021-03-17T15:44:52Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "MDU6SXNzdWU4NDY3NjY3MDg=",
      "title": "DNS resolution and reuse",
      "url": "https://github.com/tfpauly/quic-proxy/issues/43",
      "state": "OPEN",
      "author": "MikeBishop",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "When the client makes an initial CONNECT-UDP request to speak to an origin, if it specifies a DNS hostname, the proxy will do a DNS lookup.  Because of DNS load balancing, we know that the results might be a subset of all possible addresses for that host.  If there are multiple possible IPs in the response, the proxy will pick one.  All well and good.\r\n\r\nOn subsequent CONNECT-UDPs to establish additional forwarding rules, the client/proxy together need to ensure that the same destination IP address is used.  Seems like there are two possible directions for that:\r\n\r\n- Client needs to learn, in the response to the first CONNECT-UDP, which IP address the server selected and do all future CONNECT-UDP requests intended for that host with an explicit IP address.\r\n- Server needs to remember what IP address it selected for a given client/hostname pairing as part of the connection state so long as any forwarding rules are active.\r\n\r\nThe first seems more flexible but requires machinery that doesn't currently exist in this draft.  It also has the advantage that the client could change proxies simply by asking a different proxy to contact that IP address.\r\n\r\nRegardless, there should be discussion in this draft about this potential issue.",
      "createdAt": "2021-03-31T14:24:23Z",
      "updatedAt": "2021-03-31T16:59:27Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "> On subsequent CONNECT-UDPs to establish additional forwarding rules, the client/proxy together need to ensure that the same destination IP address is used.\r\n\r\nWhy is that? Let's assume you have a client that wants to open multiple QUIC connections to a given host and UDP port. Even when CONNECT-UDP isn't in use, there is no guarantee that those two connections will use the same IP. Why would CONNECT-UDP need this requirement?",
          "createdAt": "2021-03-31T15:03:36Z",
          "updatedAt": "2021-03-31T15:03:36Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "NONE",
          "body": "Because the multiple CONNECT-UDP streams in this document (QUIC forwarding) represent a single QUIC connection, not multiple.  I agree that vanilla CONNECT-UDP in the adopted draft does not imply this requirement.",
          "createdAt": "2021-03-31T15:40:02Z",
          "updatedAt": "2021-03-31T15:40:02Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh my bad, I thought this issue was on the CONNECT-UDP draft. I agree that the QUIC-aware extension to CONNECT-UDP needs to handle this.",
          "createdAt": "2021-03-31T16:59:27Z",
          "updatedAt": "2021-03-31T16:59:27Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "MDU6SXNzdWU5NDIyNTQ5OTU=",
      "title": "Stateless Reset handling",
      "url": "https://github.com/tfpauly/quic-proxy/issues/48",
      "state": "OPEN",
      "author": "MikeBishop",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The draft doesn't currently discuss Stateless Resets at all.\r\n\r\nWhen using vanilla CONNECT-UDP, each client has a dedicated origin-facing port.  If the origin sends a Stateless Reset, it will be forwarded naively, parsed by the client, and the client will close the stream as it is no longer needed.  (Or the client could start a new connection using the same tunnel; doesn't matter to the proxy.)\r\n\r\nWhen using forwarding mode, the proxy will reject Stateless Reset packets as they do not match any open request's registered CIDs.  The client doesn't learn that the connection has failed and will continue to send packets, which the origin will continue to reject, until the connection eventually times out.\r\n\r\nShould we consider having the client provide Stateless Reset tokens to the server alongside the CIDs?  In that case, the proxy could either correctly relay Stateless Reset packets or convert them to stream error(s) for the affected CID.",
      "createdAt": "2021-07-12T16:57:18Z",
      "updatedAt": "2021-07-12T16:57:18Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 53,
      "id": "I_kwDOEHrEP8484khM",
      "title": "terminology: change \"server\" to \"target\"",
      "url": "https://github.com/tfpauly/quic-proxy/issues/53",
      "state": "CLOSED",
      "author": "ehaydenr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Under terminology we have \"Client\", \"Proxy\", and \"Target\" defined, but for sockets and connection IDs, \"server\" is used instead of \"target\". The term \"server\" can be ambiguous - it's not immediately obvious whether it's referring to the proxy or the target.\r\n\r\nConsider making it more specific:\r\nServer-facing socket -> Target-facing socket\r\nServer Connection ID -> Target Connection ID\r\nREGISTER_SERVER_CID -> REGISTER_TARGET_CID\r\nACK_SERVER_CID -> ACK_TARGET_CID\r\nCLOSE_SERVER_CID -> CLOSE_TARGET_CID",
      "createdAt": "2021-10-08T21:07:17Z",
      "updatedAt": "2021-10-11T18:08:35Z",
      "closedAt": "2021-10-11T18:08:35Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "@DavidSchinazi what do you think for this bikeshed?",
          "createdAt": "2021-10-08T21:29:03Z",
          "updatedAt": "2021-10-08T21:29:03Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think renaming from server to target would makes this clearer. The notion of a \"target CID\" does sound weird, but I think internal consistency is more important so going with target sounds best",
          "createdAt": "2021-10-11T17:26:21Z",
          "updatedAt": "2021-10-11T17:26:21Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "This might sound like a troll but I mean it sincerely\r\n\r\nREGISTER_SERVER_CID -> REGISTER_TARGET_SERVER_CID\r\n...\r\n\r\nno one will ever get confused by that, and the name length doesn't affect the wire format",
          "createdAt": "2021-10-11T17:37:28Z",
          "updatedAt": "2021-10-11T17:37:28Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I like REGISTER_TARGET_SERVER_CID, whether or not it's a troll",
          "createdAt": "2021-10-11T17:46:16Z",
          "updatedAt": "2021-10-11T17:46:16Z"
        }
      ]
    },
    {
      "number": 54,
      "id": "I_kwDOEHrEP8485-1V",
      "title": "QUIC-LB and proxies",
      "url": "https://github.com/tfpauly/quic-proxy/issues/54",
      "state": "CLOSED",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Thanks for considering the implications of QUIC-LB in this draft.\r\n\r\nYour recommendation might be too draconian. Note that QUIC-LB only adds value in case of address migration. I see a few different solutions depending on use case if the proxies have to be load balanced:\r\n\r\n1. If proxy and server can coordinate, multiple tier LBs are already addressed in the quic-lb draft; clear sailing here, as you've written\r\n\r\n2. The proxy can simply send disable-migration and then use 4-tuple load balancing. Then the CID doesn't matter to the proxy. In this case the client MUST not change the destination CID in forwarded packets. If it needs to migrate, it can open a new 0RTT connection to the proxy and can even use the same inner connection.\r\n\r\nUnfortunately, this breaks migration for tunneled connections in these deployments as well.\r\n\r\n3. There could be a \"proxy-behind-lb\" response header. If present, and the client must migrate, all subsequent client packets MUST use tunneled mode until one of them is acked. The proxy LB is 4-tuple based if it has observed the 4-tuple before; otherwise, it uses the CID (i.e. it assumes the packet is tunnel mode). I suspect most Quic-LB devices will keep 4-tuple state in this manner anyway, though it isn't required.\r\n\r\nThe idea here is that the tunneled packets allow the LB to learn to associate the 4 tuple with the correct proxy, informed by the outer CID, before reverting to forwarding mode.\r\n",
      "createdAt": "2021-10-09T23:29:44Z",
      "updatedAt": "2022-10-31T20:30:47Z",
      "closedAt": "2022-10-31T20:30:47Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "#60 and #62 added virtual CID support in the proxy, which should address support for QUIC-LB. @martinduke please a file a new issue if you see more that would need to be done!",
          "createdAt": "2022-10-31T15:50:33Z",
          "updatedAt": "2022-10-31T15:50:33Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "Yes, this is a clever solution to the core issue. I will file a new issue for further complaints.",
          "createdAt": "2022-10-31T20:30:47Z",
          "updatedAt": "2022-10-31T20:30:47Z"
        }
      ]
    },
    {
      "number": 56,
      "id": "I_kwDOEHrEP85Dob8c",
      "title": "Links no longer working regarding the \"connect\" WG",
      "url": "https://github.com/tfpauly/quic-proxy/issues/56",
      "state": "CLOSED",
      "author": "starrify",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "(Sorry in advance for this potentially stupid ticket. :sweat_smile:)\r\n\r\nI happen to notice that these three links are not working: \r\nhttps://github.com/tfpauly/quic-proxy/blob/ad94640114f279624009dc17873953d7fde42f42/CONTRIBUTING.md?plain=1#L20-L31\r\n\r\nIt looks a little bit weird because there seems to be no working group called \"connect\" from [the current list](https://datatracker.ietf.org/wg/) and [the historical list](https://datatracker.ietf.org/group/concluded/).",
      "createdAt": "2022-02-12T21:55:37Z",
      "updatedAt": "2022-02-12T22:17:50Z",
      "closedAt": "2022-02-12T22:17:49Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Weird, I think some automated setup did that wrong! I'll fix it.",
          "createdAt": "2022-02-12T22:16:49Z",
          "updatedAt": "2022-02-12T22:16:49Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Fixed to point to masque.",
          "createdAt": "2022-02-12T22:17:49Z",
          "updatedAt": "2022-02-12T22:17:49Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "I_kwDOEHrEP85L8SDb",
      "title": "Happy Eyeballs?",
      "url": "https://github.com/tfpauly/quic-proxy/issues/59",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "CONNECT-UDP can't perform Happy Eyeballs because UDP doesn't have an equivalent of the TCP SYN-ACK. However, QUIC has such an equivalent. This extension could recommend performing Happy Eyeballs when target_host is a DNS host name.",
      "createdAt": "2022-06-16T21:21:40Z",
      "updatedAt": "2022-06-21T19:09:33Z",
      "closedAt": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "How would that work, the proxy duplicating the Client initial over a v4 and a v6 path? That doesn't sound good",
          "createdAt": "2022-06-16T21:44:36Z",
          "updatedAt": "2022-06-16T21:44:36Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": " Have to agree with @LPardue here. I don't see how this can work. A UDP Proxy can clearly run happy eyeball and race the quick connection between the masque client and the masque server (proxy) over IPv4 and IPv6 and in this case it would be the MASQUE used HTTP establishment that is raced. For the end-to-end connection that is being tunnelled, that require the application above the QUIC connection(s) to perform happy eyeballs. If you want to enable this, then you need to have the end-to-end application open two QUIC connection over the same proxy and race these and thus indicate a preference for IPv4 or IPv6 when doing the request for proxying. \r\n \r\n I don't believe in the proxy duplicating what it thinks is a QUIC handshake packet for the E2E quic connection and send it over both IPv4 and IPv6 for domains that have both A and AAAA DNS records. If you one would do that and then select which to use based on the response. Then first you are impacting when the response can be sent. So any attempt in this direction would need an extension and explicit signalling about it. ",
          "createdAt": "2022-06-20T09:09:52Z",
          "updatedAt": "2022-06-20T09:09:52Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Yeah, the client would need to be involved in order to run proper happy eyeballs, I think.\r\n\r\nThe proxy could certainly learn for commonly accessed targets that a particular address actually doesn't work \u2014 like if the DNS entry had IPv6 addresses, but never responded, for future requests the proxy could prefer IPv4.",
          "createdAt": "2022-06-21T16:07:05Z",
          "updatedAt": "2022-06-21T16:07:12Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Proxy heuristics seem fine but then that seems common to any type of HTTP CONNECT proxy. Is there anything special to say here? ",
          "createdAt": "2022-06-21T16:29:04Z",
          "updatedAt": "2022-06-21T16:29:04Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "I'm not sure there's something specific to say here, no, but David may have ideas.",
          "createdAt": "2022-06-21T16:47:32Z",
          "updatedAt": "2022-06-21T16:47:32Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "(For the sake of simplicity, I'm assuming there's only one v4 address and one v6 address below, but this generalizes)\r\n\r\nMy initial thought was to have the proxy send the INITIAL to both the v4 and v6 target addresses (staggered as in HEv2, not all at once) and then pick the first target address that replies as its target, and forward the reply to the client. If the proxy receives a reply from the other address, there are two scenarios:\r\n1. the second reply has packet number 0: this means that it came from a different target server - the proxy drops the reply and generates a fake INITIAL CONNECTION_CLOSE and sends it to the second target address to tell that server to give up\r\n2. the second reply has packet number > 0: this means that it was the same target server as the first reply - the proxy forwards the reply to the client and picks the best target address as its future target address to send to\r\n\r\nOf course we'd need something a bit more smart to handle packet loss but I think the general idea would work.\r\n\r\nIf folks think this is too complicated I'm happy to take that to an extension, but since we haven't adopted this yet I thought it might be worth thinking about since we're not delaying progress.",
          "createdAt": "2022-06-21T17:02:07Z",
          "updatedAt": "2022-06-21T17:02:07Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "My concerns stem from implications of reuse of connection IDs and tokens, e.g.\r\n\r\n> An endpoint MUST NOT reuse a connection ID when sending from more than one local address -- for example, when initiating connection migration\r\n\r\nMaybe we could make this more of explicit behaviour? E.g. the client gives a proxy multiple SCIDS to use for this and then just returns packets with the selected one",
          "createdAt": "2022-06-21T18:30:36Z",
          "updatedAt": "2022-06-21T18:30:36Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "That MUST NOT is post-handshake though. The client not allowed to switch its SCID during the handshake (except to the one the server gives it)",
          "createdAt": "2022-06-21T18:33:01Z",
          "updatedAt": "2022-06-21T18:33:01Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, but duplication of CiDS in initial across paths could still provide some form of linkability? \r\n\r\nDo clients already do this kind of happy eyeballs copying behaviour without any proxy in the mix?",
          "createdAt": "2022-06-21T18:37:02Z",
          "updatedAt": "2022-06-21T18:37:02Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "> Right, but duplication of CiDS in initial across paths could still provide some form of linkability?\r\n\r\nYou'd be linking the public IPv4 and IPv6 addresses of the proxy together. I don't think the proxy cares.\r\n\r\n> Do clients already do this kind of happy eyeballs copying behaviour without any proxy in the mix?\r\n\r\nOur client does Happy Eyeballs across protocols in the sense that it tries QUIC on the first address and if that's sad it falls back to TCP, but that's because our client only does h3. But if I were to implement a QUIC-only client today I would create two separate QUIC connections so there wouldn't be duplication of initials. You could definitely do that through the proxy, but you'd save on CPU costs and latency by doing it from the proxy with duplication. Definitely a tradeoff.",
          "createdAt": "2022-06-21T18:57:29Z",
          "updatedAt": "2022-06-21T18:57:29Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah agree it's a tradeoff. \r\n\r\nThinking aloud.\r\nIt seems like in an era of HTTPS records, happy eyeballs for QUIC could be useful for non-proxy clients. And guidance on how to close an uneeded connection seems useful. The decision whether to duplicate Initials could be part of guidance around tradeoffs. A proxy could then take that and use it. A CONNECT-UDP proxy that snoops could even employ the approach ypu outline ",
          "createdAt": "2022-06-21T19:09:33Z",
          "updatedAt": "2022-06-21T19:09:33Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "I_kwDOEHrEP85RqzVn",
      "title": "Consider virtual CIDs for traffic from target to client",
      "url": "https://github.com/tfpauly/quic-proxy/issues/61",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "To improve CID privacy when migrating, etc, and to have more parallelism between client-to-target and target-to-client, we should look at having virtual CIDs for both directions.",
      "createdAt": "2022-09-12T16:22:10Z",
      "updatedAt": "2022-10-18T21:36:19Z",
      "closedAt": "2022-10-18T21:36:19Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "@ehaydenr ",
          "createdAt": "2022-09-12T16:22:38Z",
          "updatedAt": "2022-09-12T16:22:38Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "I_kwDOEHrEP85URc--",
      "title": "Consistency between \"forwarded\" and \"forwarding\" modes",
      "url": "https://github.com/tfpauly/quic-proxy/issues/63",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "OWNER",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "Ready for Text"
      ],
      "body": "",
      "createdAt": "2022-10-18T21:22:00Z",
      "updatedAt": "2022-10-19T03:23:02Z",
      "closedAt": "2022-10-19T03:23:02Z",
      "comments": []
    },
    {
      "number": 65,
      "id": "I_kwDOEHrEP85UzBmh",
      "title": "Capsules and Port Reuse",
      "url": "https://github.com/tfpauly/quic-proxy/issues/65",
      "state": "OPEN",
      "author": "ehaydenr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "With the introduction of capsules, a proxy receives request headers and client connection id separately. In order to reuse ports, a proxy must know the client connection id when selecting a socket so that it can properly demultiplex when receiving on that target-facing socket. We should clarify what clients and proxies should do to increase the likelihood of proxies being able to reuse target-facing ports.",
      "createdAt": "2022-10-25T15:31:06Z",
      "updatedAt": "2022-10-25T15:31:06Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 67,
      "id": "I_kwDOEHrEP85VQyVt",
      "title": "Example could use a few 1RTT packets",
      "url": "https://github.com/tfpauly/quic-proxy/issues/67",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This is a minor editorial point, but it might be worthwhile to show a few 1-RTT packets in Section 6.\r\n\r\nIn particular:\r\n\r\nbefore the REGISTER_TARGET_CID exchange, server->client packets are in forwarding mode but client->server is still funneled.\r\n\r\nafter the exchange, everything is in forwarding mode.",
      "createdAt": "2022-10-31T20:37:19Z",
      "updatedAt": "2022-10-31T20:37:19Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 68,
      "id": "I_kwDOEHrEP85VQ-L2",
      "title": "CID Registration doesn't consider uncooperative servers",
      "url": "https://github.com/tfpauly/quic-proxy/issues/68",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I'm really happy with the virtual CID concept, and I think it will work well with the happy path. IIUC there is a 1-to-1 mapping of connection IDs to virtual connection IDs and vice versa. Thus the proxy has a very simple job of substituting one for the other.\r\n\r\nHowever, there are some target behaviors where migration won't work all that well:\r\n\r\n1) The target has disabled migration but the proxy allows it. When the client migrates, it wants to use a new (virtual) target connection ID but the new target connection ID might not be routed correctly.\r\n\r\n2) The target is not issuing new connection IDs. Again, the client would like to use a new target virtual CID but obviously can't use a new target CID.\r\n\r\n3) The client changes the connection ID in use, but the target doesn't observe migration (proxy IP address is the same) so it declines to use a new client connection ID (I believe this is allowed in RFC 9000). Thus proxy->client packets will use the old virtual client CID and remain linkable.\r\n\r\nHaving thought about it for a moment, the answer is probably to decouple the \"actual\" CIDs and the virtual ones. I think this means lots of different capsules.\r\n\r\nREGISTER_VIRTUAL_CLIENT_CID: adds to a pool of CIDs that the proxy can choose from. When the client changes address, the proxy MUST choose a new CID from this pool (this requirement is already sorta there because the proxy can't use the same CID on two paths).\r\n\r\nREGISTER_CLIENT_CID: As the target will not experience a migration, it's not clear to me why a client would ever send a NEW_CONNECTION_ID frame. But if it chooses to, the proxy has to know that incoming packets with that CID correspond to this stream.\r\n\r\n[Perhaps \"retire\" versions of this capsule are also necessary?]\r\n\r\nREQUEST_VIRTUAL_TARGET_CID: Regardless of whether or not the actual target CID is changing, the client needs new proxy CIDs in case the client->proxy connection migrates. This must be acked with a routable CID.\r\n\r\n[again, maybe there has to be a proxy-sent capsule that retires these? A long lived connection might need to discard old QUIC-LB CIDs if the keys have rotated, etc]\r\n\r\nUPDATE_TARGET_CID: I believe the proxy only needs one target CID at a time, which it applies to all outgoing packets in forwarding mode. The only reason the client should start using a new target CID is if the old one is being retired. This is not a migration and doesn't need probes, etc. \r\n\r\n(this Issue does not consider Multipath QUIC, which has its own set of concerns.)\r\n\r\n\r\n\r\n",
      "createdAt": "2022-10-31T21:19:01Z",
      "updatedAt": "2022-10-31T21:41:23Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "I should also add that I think this decoupling has good privacy properties. In general, there will be many clients connected to the proxy with many outgoing connections to a variety of destinations. If a client migrates to a new address, and there is no change at all in the CIDs between proxy and target, that leaks very little info about what that client is connected to.",
          "createdAt": "2022-10-31T21:41:23Z",
          "updatedAt": "2022-10-31T21:41:23Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "I_kwDOEHrEP85VRCdq",
      "title": "Are there potentially no ACKs? What then?",
      "url": "https://github.com/tfpauly/quic-proxy/issues/69",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Forwarding mode, of course, doesn't have packet numbers for the outer connection. If there's nothing else going over the outer connection, it is therefore impractical for the proxy to send ACKs. So what are the implications for congestion control, idle timeouts, and so on?\r\n\r\nFrequent ACKs in response to QUIC packets are pretty fundamental to congestion control, timeouts, and perhaps other transport layer mechanisms, and we ought to think through the implications of fully relying on the inner connection for all of those functions.\r\n\r\n",
      "createdAt": "2022-10-31T21:36:48Z",
      "updatedAt": "2022-11-01T03:58:48Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "That's a good point, if we're exclusively using forwarding mode the outer QUIC connection could succumb to an idle timeout. It's pretty easy to avoid that by periodically sending PING frames, I'd suggest we mention this to warn implementers.",
          "createdAt": "2022-10-31T23:02:28Z",
          "updatedAt": "2022-10-31T23:02:28Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Yeah in practice we have periodic pings to the proxy that\u2019s in forwarding mode. ",
          "createdAt": "2022-11-01T03:58:48Z",
          "updatedAt": "2022-11-01T03:58:48Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "I_kwDOEHrEP85VRE9n",
      "title": "ECN",
      "url": "https://github.com/tfpauly/quic-proxy/issues/70",
      "state": "OPEN",
      "author": "martinduke",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In this context, it's probably worthwhile to specify the ECN behavior more precisely. ISTM the proxy should copy the ECN bits when forwarding even though the IP header is being replaced.",
      "createdAt": "2022-10-31T21:47:21Z",
      "updatedAt": "2022-10-31T21:47:21Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 71,
      "id": "I_kwDOEHrEP85ViWw5",
      "title": "Contradictory guidance on when it's acceptable to send capsule",
      "url": "https://github.com/tfpauly/quic-proxy/issues/71",
      "state": "CLOSED",
      "author": "ehaydenr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This seems contradictory\r\n > If the client does not receive this header in responses, the client SHALL assume that the proxy\r\ndoes not understand how to parse Connection ID capsules, and MUST NOT send any\r\nConnection ID capsules.\r\n\r\nFollowed by\r\n>Note that the initial REGISTER_CLIENT_CID capsule MAY be sent prior to receiving an\r\nHTTP response from the proxy.\r\n\r\nClients wishing to send capsules along with request headers cannot do so without violating the requirement that the server responded with the Proxy-QUIC-Forwarding header. Since CONNECT-UDP implementations MUST be able to parse capsules (and ignore capsules they do not understand), I think it's safe to remove the \"MUST NOT send any Connection ID capsules\".",
      "createdAt": "2022-11-03T18:04:19Z",
      "updatedAt": "2022-11-04T16:36:27Z",
      "closedAt": "2022-11-04T16:36:27Z",
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 2,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ2NTY2Njkz",
      "title": "Clarify a few things.",
      "url": "https://github.com/tfpauly/quic-proxy/pull/2",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Some of which was discussed offline.",
      "createdAt": "2020-07-09T01:37:50Z",
      "updatedAt": "2020-07-09T02:17:17Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "0b71cb0fabec72a3420daefa7d0052382f1b7c59",
      "headRepository": null,
      "headRefName": "caw/edits",
      "headRefOid": "dab617684d1f67a2db487ca23af7316106fce70a",
      "closedAt": "2020-07-09T02:17:17Z",
      "mergedAt": "2020-07-09T02:17:16Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "8115bc3ba5fd3a69395914c2d31a5f5d3425d9dd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MjQ1Mzgy",
          "commit": {
            "abbreviatedOid": "dab6176"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-09T02:17:11Z",
          "updatedAt": "2020-07-09T02:17:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 9,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1ODEwOTEy",
      "title": "HTTP/3 has no END_HEADERS",
      "url": "https://github.com/tfpauly/quic-proxy/pull/9",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-09-30T21:55:58Z",
      "updatedAt": "2020-10-02T13:53:48Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "2e9c5ea7030685b37147d942e6f55814265c21e6",
      "headRepository": "tfpauly/quic-proxy",
      "headRefName": "no-end-headers",
      "headRefOid": "953cf1943182113278bfde8aba240a38be7ab847",
      "closedAt": "2020-10-02T13:53:48Z",
      "mergedAt": "2020-10-02T13:53:48Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "240038eab12d5c81fa38651038cc59685141876d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMTU1NTE4",
          "commit": {
            "abbreviatedOid": "953cf19"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-02T13:53:44Z",
          "updatedAt": "2020-10-02T13:53:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 16,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAwMjE4MTgw",
      "title": "Address Lucas's comments",
      "url": "https://github.com/tfpauly/quic-proxy/pull/16",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "OWNER",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Closes #5, Closes #6, Closes #7, Closes #8, Closes #10, Closes #11, Closes #12, Closes #13, and Closes #15.",
      "createdAt": "2020-10-08T22:12:08Z",
      "updatedAt": "2020-10-09T16:57:52Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "240038eab12d5c81fa38651038cc59685141876d",
      "headRepository": "tfpauly/quic-proxy",
      "headRefName": "tfp/lucas-comments",
      "headRefOid": "1e218f5c523a70098594d2307918c731b3b7ae4b",
      "closedAt": "2020-10-09T16:57:52Z",
      "mergedAt": "2020-10-09T16:57:51Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "7f4994b44c3959f0fc7a7dd9f37ef02f6f3e8260"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1NjA1OTc3",
          "commit": {
            "abbreviatedOid": "1e218f5"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "These look great thanks.",
          "createdAt": "2020-10-09T11:58:37Z",
          "updatedAt": "2020-10-09T11:58:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 19,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAzMDYyMDEy",
      "title": "Fix typoes and CONNECT-UDP reference",
      "url": "https://github.com/tfpauly/quic-proxy/pull/19",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-14T02:21:16Z",
      "updatedAt": "2020-10-15T17:09:30Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "7f4994b44c3959f0fc7a7dd9f37ef02f6f3e8260",
      "headRepository": "tfpauly/quic-proxy",
      "headRefName": "typoes20201013",
      "headRefOid": "58b3176c0dbaf6756dda9efe5b61f7fce77d52dd",
      "closedAt": "2020-10-15T17:09:30Z",
      "mergedAt": "2020-10-15T17:09:30Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "8d6ecdd699ec778fc40056a264f3f946ffce005d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NTk1Mjg5",
          "commit": {
            "abbreviatedOid": "58b3176"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-15T17:09:25Z",
          "updatedAt": "2020-10-15T17:09:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 24,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA0MjU4MjM5",
      "title": "Define proxy mapping state more rigorously",
      "url": "https://github.com/tfpauly/quic-proxy/pull/24",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "OWNER",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Addressing #23, #22, #21, #20",
      "createdAt": "2020-10-15T17:18:07Z",
      "updatedAt": "2020-10-16T18:10:58Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "48709d612f77ed7cd6d64ca7aea72f576da69ad3",
      "headRepository": "tfpauly/quic-proxy",
      "headRefName": "tfp/mappings",
      "headRefOid": "0fe8032e3ef999f80a33883c0145fa895651a944",
      "closedAt": "2020-10-16T18:10:58Z",
      "mergedAt": "2020-10-16T18:10:58Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "f8c8ffe11a236bebe0959d263c8bdb7b618f7be6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NzQyMzE5",
          "commit": {
            "abbreviatedOid": "55b42be"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This is super helpful. Thanks. \r\n\r\nI've got suggestions for nits. But also there's some things I think could be improvements.",
          "createdAt": "2020-10-15T20:02:55Z",
          "updatedAt": "2020-10-15T21:16:14Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "HTTP/3 DATAGRAM frames?",
              "createdAt": "2020-10-15T20:02:55Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 78,
              "body": "```suggestion\r\nserver-facing socket for every proxied QUIC connection. The mapping is critical for any case where server-facing\r\n```",
              "createdAt": "2020-10-15T20:09:47Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 49,
              "body": "At first, my marginal editorial suggestion was to move this sentence to the start of the section. But then I questioned myself whether the sentence is a notable comment or a complete description. The same applies to all 3 sections. I'll leave it to your discretion on what to do.",
              "createdAt": "2020-10-15T20:13:11Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 93,
              "body": "\r\n```suggestion\r\nA clients sends new CONNECT-QUIC requests when it wants to start\r\n```\r\n\r\nor \"a new\"",
              "createdAt": "2020-10-15T20:14:35Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 118,
              "body": "```suggestion\r\n## New Proxied Connection Setup\r\n```",
              "createdAt": "2020-10-15T20:18:00Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 126,
              "body": "This para seems a bit repetitive but is useful because it makes it clear what is required in this instance of the request. We can editorialize later.",
              "createdAt": "2020-10-15T20:25:40Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 140,
              "body": "As an alternative, does this read more clearly?\r\n\r\n```suggestion\r\nexpected to cooperate with proxies in selecting Client Connection IDs. A proxy\r\ndetects a conflict when it is not able to create a unique mapping using the Client Connection ID. \r\nIt can reject requests that would cause a conflict and indicate this to the client by replying with a\r\n409 (Conflict) status. In order to avoid conflicts, clients SHOULD select Connection IDs of at least\r\n8 bytes in length with unpredictable values.\r\n```",
              "createdAt": "2020-10-15T20:37:56Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 142,
              "body": "```suggestion\r\nA client also MUST NOT select a Client Connection ID that matches the ID used for the QUIC\r\nconnection to the proxy, as this inherently creates\r\n```",
              "createdAt": "2020-10-15T20:41:03Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 195,
              "body": "I could have missed it but this seems to be the first mention of rejection due to a Connection ID that is too short",
              "createdAt": "2020-10-15T20:48:13Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 199,
              "body": "```suggestion\r\n## Adding New Client Connection IDs\r\n```",
              "createdAt": "2020-10-15T20:48:31Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 202,
              "body": "to the proxy or the target? This gets confusing with the next paragraph.",
              "createdAt": "2020-10-15T20:49:42Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 206,
              "body": "```suggestion\r\nNEW_CONNECTION_ID frame once a successful response is received.\r\n```",
              "createdAt": "2020-10-15T20:50:08Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 208,
              "body": "```suggestion\r\n## Sending With Forwarded Mode\r\n```",
              "createdAt": "2020-10-15T20:50:53Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 218,
              "body": "This reads a little loose. It would help to say something like \"if a client Server-Connection-ID-containing request is rejected, for example with a 409 (Conflict) response, it MUST NOT forward...\"\r\n\r\nPerhaps more broadly, coming up with some terser terms for Client-Connection-ID-containing request and Server-Connection-ID-containing request could help this document...",
              "createdAt": "2020-10-15T20:55:59Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 227,
              "body": "```suggestion\r\n## Receiving With Forwarded Mode\r\n```",
              "createdAt": "2020-10-15T20:56:54Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 242,
              "body": "See earlier comment about more terse terms. We could then tighten this up to say soemthing \"The proxy MUST validate that the CONNECT-QUIC request is either type X or Y...\"",
              "createdAt": "2020-10-15T21:02:14Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 306,
              "body": "This section reads a little weird. I'll make a spin off issueo work on improvements for talking about request stream lifecycle; it should also cover the similar stuff described in H3's CONNECT section like what frames are valid.",
              "createdAt": "2020-10-15T21:14:56Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODE3ODM3",
          "commit": {
            "abbreviatedOid": "55b42be"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T21:20:14Z",
          "updatedAt": "2020-10-15T21:20:15Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "```suggestion\r\n- Datagram flow, which is a flow of HTTP/3 DATAGRAMs specific to a single client QUIC connection to the proxy.\r\n```",
              "createdAt": "2020-10-15T21:20:14Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODQ5NTM0",
          "commit": {
            "abbreviatedOid": "f88d64d"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T22:22:38Z",
          "updatedAt": "2020-10-15T22:22:39Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "I just tried arranging it the other way, but I think it was less clear. It flows right now as:\r\n- Text description of the mapping requirement\r\n- Diagram of the mapping\r\n- Explanation for what the mapping means",
              "createdAt": "2020-10-15T22:22:39Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODUwMDY2",
          "commit": {
            "abbreviatedOid": "f88d64d"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T22:23:48Z",
          "updatedAt": "2020-10-15T22:23:49Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Yeah that works for me.",
              "createdAt": "2020-10-15T22:23:49Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODUwNTEw",
          "commit": {
            "abbreviatedOid": "f88d64d"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T22:24:47Z",
          "updatedAt": "2020-10-15T22:24:47Z",
          "comments": [
            {
              "originalPosition": 242,
              "body": "Yeah, I think I may leave that for a later editorial cleanup. I am hesitant to add too much jargon yet.",
              "createdAt": "2020-10-15T22:24:47Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODUwODIx",
          "commit": {
            "abbreviatedOid": "f88d64d"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T22:25:27Z",
          "updatedAt": "2020-10-15T22:25:27Z",
          "comments": [
            {
              "originalPosition": 306,
              "body": "Sounds good, new issue welcome (and text welcome too!)",
              "createdAt": "2020-10-15T22:25:27Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODUxMDAw",
          "commit": {
            "abbreviatedOid": "7121f75"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T22:25:50Z",
          "updatedAt": "2020-10-15T22:25:51Z",
          "comments": [
            {
              "originalPosition": 218,
              "body": "Fixed this up!",
              "createdAt": "2020-10-15T22:25:51Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODM0NTg4",
          "commit": {
            "abbreviatedOid": "f88d64d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for writing this, it really addresses a lot of things! Sorry about the mountain of comments, many are editorial but some are design issues that we'd need to address if we want to resolve the 4 issues",
          "createdAt": "2020-10-15T21:51:22Z",
          "updatedAt": "2020-10-15T22:34:43Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "To be slightly pedantic it's not a UDP address:\r\n```suggestion\r\nbeing used by proxied connections, along with the UDP sockets (IP addresses and ports)\r\n```",
              "createdAt": "2020-10-15T21:51:22Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nallows the proxy to reuse server-facing sockets for multiple connections and support the forwarding\r\n```",
              "createdAt": "2020-10-15T21:53:48Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nA QUIC Connection ID identifies the receiver of a packet, and is chosen by the receiver.\r\n```",
              "createdAt": "2020-10-15T21:54:14Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 28,
              "body": "```suggestion\r\n- Datagram flow ID, which represents a flow of HTTP/3 DATAGRAMs specific to a single client QUIC connection to the proxy.\r\n```",
              "createdAt": "2020-10-15T21:54:45Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 29,
              "body": "```suggestion\r\n- Client-facing socket, which is the 4-tuple of UDP addresses and ports used to communicate between the client and the proxy.\r\n```",
              "createdAt": "2020-10-15T21:55:32Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 30,
              "body": "```suggestion\r\n- Server-facing socket, which is the 4-tuple of UDP addresses and ports used to communicate between the proxy and the target.\r\n```",
              "createdAt": "2020-10-15T21:55:44Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nThere are three required unidirectional mappings, described below.\r\n```",
              "createdAt": "2020-10-15T21:56:55Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 12,
              "body": "We should clarify that this is the full 4-tuple, you need the local ports too.",
              "createdAt": "2020-10-15T21:57:42Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 38,
              "body": "This is a little hard to reason about. How about instead explicitly map from (QuicConnection, flowID) tuple?",
              "createdAt": "2020-10-15T21:59:38Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 48,
              "body": "Well technically the client could send a packet with a flow ID that's unknown to the server",
              "createdAt": "2020-10-15T22:02:16Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 29,
              "body": "Our implementation doesn't use connected sockets on the server - each QUIC server has a single client-facing non-connected UDP socket. Maybe just mentioning somewhere that this spec uses \"socket\" as a way to refer to a 4-tuple and that it can be implemented a variety of ways",
              "createdAt": "2020-10-15T22:04:18Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 70,
              "body": "I don't think that's right, the mapping should be to a QUIC connection, not a client-facing socket - because multiple QUIC connections can share a client-facing socket",
              "createdAt": "2020-10-15T22:06:28Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 78,
              "body": "I'm not sure we've defined the term \"proxied QUIC connection\" anywhere. I ask because that's a concept that the proxy doesn't really have access to - the proxy can't distinguish between \"two CIDs belonging to one connection\" vs \"two connections\" if only short headers are involved",
              "createdAt": "2020-10-15T22:09:02Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 101,
              "body": "```suggestion\r\npseudo-header identifying the target. All requests for the same QUIC\r\n```",
              "createdAt": "2020-10-15T22:10:09Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 102,
              "body": "Why is this a SHOULD and not a MUST? It's required for correctness",
              "createdAt": "2020-10-15T22:11:25Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 103,
              "body": "We should address the discrepancy between authority and server-facing 4-tuple, they're not quite the same because DNS can return multiple results so we need to mention that the proxy has to save the authority in the mappings and reuse the DNS result from the first time around. (I'm also realizing the proxy really shouldn't perform happy eyeballs here because that would make things way more complicated)",
              "createdAt": "2020-10-15T22:13:14Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 123,
              "body": "```suggestion\r\nThe first request the clients makes MUST contain the authority pseudo-header and the\r\n```",
              "createdAt": "2020-10-15T22:16:58Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 138,
              "body": "We should define the term of \"conflict\" before using it. It particular, one CID being a prefix of another is a \"conflict\" for the purposes of this draft.",
              "createdAt": "2020-10-15T22:19:21Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 217,
              "body": "This is ambiguous: the server could decide to reject the request because it doesn't like the authority (e.g. if the client sends \"localhost\" as the authority, the proxy really ought to refuse to proxy there). Another example is DNS failure. I think that we need a way to convey the scenario where \"the proxy agrees to proxy to this authority and has opened a target-facing socket, but cannot use forwarding mode due to a conflict\".",
              "createdAt": "2020-10-15T22:25:43Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 229,
              "body": "As discussed in #23, it would be great to allow clients to disable forwarding mode",
              "createdAt": "2020-10-15T22:27:07Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 244,
              "body": "```suggestion\r\nif the requested datagram flow ID has already been used on that client-to-proxy QUIC connection\r\n```",
              "createdAt": "2020-10-15T22:28:02Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 255,
              "body": "I would phrase this as \"avoiding conflict\" instead of \"unique\" because conflicts here aren't only about equality",
              "createdAt": "2020-10-15T22:31:05Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODU3MjA5",
          "commit": {
            "abbreviatedOid": "7121f75"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T22:40:05Z",
          "updatedAt": "2020-10-15T22:40:05Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "So, my thought here was that a client _could_ decide to be sneaky and represent what is one connection between the client and the target as two subsequent flows to proxy, which could make it \"migrate\". It'd be some paranoid privacy thing, but I could see a reason it would be illegal as long as the client followed the rest of the rules.",
              "createdAt": "2020-10-15T22:40:05Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODU4MDM2",
          "commit": {
            "abbreviatedOid": "7121f75"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T22:41:56Z",
          "updatedAt": "2020-10-15T22:41:57Z",
          "comments": [
            {
              "originalPosition": 202,
              "body": "```suggestion\r\nA client can add new Connection IDs to a proxied QUIC connection by sending\r\na NEW_CONNECTION_ID frame to the target.\r\n```",
              "createdAt": "2020-10-15T22:41:56Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODU4NjI3",
          "commit": {
            "abbreviatedOid": "7121f75"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T22:43:21Z",
          "updatedAt": "2020-10-15T22:43:22Z",
          "comments": [
            {
              "originalPosition": 229,
              "body": "So my thought here is that disabling forwarding is essentially just using CONNECT-UDP (which is fine). My question is if that is a separate method, like CONNECT-UDP, or if it is a CONNECT-QUIC request that has a flow ID and authority but no connection ID.",
              "createdAt": "2020-10-15T22:43:21Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODU4ODM4",
          "commit": {
            "abbreviatedOid": "7121f75"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T22:43:54Z",
          "updatedAt": "2020-10-15T22:43:54Z",
          "comments": [
            {
              "originalPosition": 244,
              "body": "```suggestion\r\nif the requested datagram flow ID has already been used on that client <-> proxy QUIC connection\r\n```",
              "createdAt": "2020-10-15T22:43:54Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODU5MDkw",
          "commit": {
            "abbreviatedOid": "7121f75"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T22:44:31Z",
          "updatedAt": "2020-10-15T22:44:31Z",
          "comments": [
            {
              "originalPosition": 255,
              "body": "```suggestion\r\nClient Connection ID and the selected server-facing socket does not create a conflict, the proxy creates\r\n```",
              "createdAt": "2020-10-15T22:44:31Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODU5NDMz",
          "commit": {
            "abbreviatedOid": "7121f75"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T22:45:09Z",
          "updatedAt": "2020-10-15T22:45:10Z",
          "comments": [
            {
              "originalPosition": 268,
              "body": "```suggestion\r\nand the client-facing socket on which the request was received does not create a conflict, the proxy\r\n```",
              "createdAt": "2020-10-15T22:45:09Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODcyNjEz",
          "commit": {
            "abbreviatedOid": "e6a7f5b"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:18:21Z",
          "updatedAt": "2020-10-15T23:18:21Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Clarified",
              "createdAt": "2020-10-15T23:18:21Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODcyNjk3",
          "commit": {
            "abbreviatedOid": "e6a7f5b"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:18:32Z",
          "updatedAt": "2020-10-15T23:18:32Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Updated the mapping to that!",
              "createdAt": "2020-10-15T23:18:32Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODczNDA0",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:20:26Z",
          "updatedAt": "2020-10-15T23:20:26Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Clarified the text to be about this particular flow ID",
              "createdAt": "2020-10-15T23:20:26Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODczOTE3",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:21:48Z",
          "updatedAt": "2020-10-15T23:21:48Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Updated the mappings. I think there are still two mappings\u00a0\u2014 one to the QUIC Connection + Datagram Flow ID, and one to the client-facing socket (for forwarding).",
              "createdAt": "2020-10-15T23:21:48Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODc0MDgz",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:22:20Z",
          "updatedAt": "2020-10-15T23:22:20Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Added a note about what the term \"socket\" means for this document.",
              "createdAt": "2020-10-15T23:22:20Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODc0NDU1",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:23:27Z",
          "updatedAt": "2020-10-15T23:23:27Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Changed this to refer to the datagram flow ID, which is what it actually knows.",
              "createdAt": "2020-10-15T23:23:27Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODc0NjE0",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:23:54Z",
          "updatedAt": "2020-10-15T23:23:54Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "Added a paragraph about this in the proxy behavior section, since it really belongs there (the client doesn't really care)",
              "createdAt": "2020-10-15T23:23:54Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODc0NzEz",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:24:10Z",
          "updatedAt": "2020-10-15T23:24:10Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "Added a section early on (in state requirements) about what conflicts mean.",
              "createdAt": "2020-10-15T23:24:10Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODc1OTI2",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:27:15Z",
          "updatedAt": "2020-10-15T23:27:15Z",
          "comments": [
            {
              "originalPosition": 217,
              "body": "Requests that include Server-Connection-Id are only about opening up forwarding paths, not creating new upstream connections. Thus, I think the correct response here is to not forward, whatever the particular error code; assuming that you already were able to open up a tunneling path with the earlier request.",
              "createdAt": "2020-10-15T23:27:15Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODgwMTg2",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:33:50Z",
          "updatedAt": "2020-10-15T23:33:50Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Good point, agreed.",
              "createdAt": "2020-10-15T23:33:50Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODgwNTIz",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:34:19Z",
          "updatedAt": "2020-10-15T23:34:19Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Thanks, I like that.",
              "createdAt": "2020-10-15T23:34:19Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODgyNTUw",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:37:18Z",
          "updatedAt": "2020-10-15T23:37:18Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "That makes sense for the flow ID, but not for the authority - perhaps we say MUST be sent to the same authority and SHOULD be sent to the same Datagram-Flow-Id?",
              "createdAt": "2020-10-15T23:37:18Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODg0MDc1",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:39:30Z",
          "updatedAt": "2020-10-15T23:39:30Z",
          "comments": [
            {
              "originalPosition": 269,
              "body": "```suggestion\r\nIf a proxy reuses server-facing sockets, it SHOULD store which authorities (which could be a domain name or IP address literal)\r\n```",
              "createdAt": "2020-10-15T23:39:30Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODg0MzAw",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:39:49Z",
          "updatedAt": "2020-10-15T23:39:50Z",
          "comments": [
            {
              "originalPosition": 271,
              "body": "```suggestion\r\nnew DNS query and potentially choosing a different server IP address which could map to a different server.\r\n```",
              "createdAt": "2020-10-15T23:39:49Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODg0Nzg3",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:40:29Z",
          "updatedAt": "2020-10-15T23:40:29Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "Agreed, that's a better spot for it - I'll create new comments over there.",
              "createdAt": "2020-10-15T23:40:29Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODg1NzA2",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:41:54Z",
          "updatedAt": "2020-10-15T23:43:34Z",
          "comments": [
            {
              "originalPosition": 272,
              "body": "I'd suggest adding some text about how the server needs to resolve domain name authorities to IP addresses in the first place, we have text for reusing sockets but this might warrant its own paragraph",
              "createdAt": "2020-10-15T23:41:54Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 138,
              "body": "New text LGTM",
              "createdAt": "2020-10-15T23:43:34Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODg4OTE0",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:46:00Z",
          "updatedAt": "2020-10-15T23:46:01Z",
          "comments": [
            {
              "originalPosition": 217,
              "body": "I think this complicates the design - I'd rather think about any request being able to open up any mapping or socket - and I'd rather not use 4xx to indicate partial success - there are probably implementations out there that close the stream if the response isn't 2xx.",
              "createdAt": "2020-10-15T23:46:01Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODkxMDEx",
          "commit": {
            "abbreviatedOid": "ca0e58d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T23:49:10Z",
          "updatedAt": "2020-10-15T23:49:10Z",
          "comments": [
            {
              "originalPosition": 229,
              "body": "I think there's value in using CONNECT-QUIC without forwarding: one is allowing the proxy to only need one socket, another is if we decide to later add short header connection ID compression to CONNECT-QUIC",
              "createdAt": "2020-10-15T23:49:10Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5OTIyNTk2",
          "commit": {
            "abbreviatedOid": "803c908"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T00:21:42Z",
          "updatedAt": "2020-10-16T00:21:43Z",
          "comments": [
            {
              "originalPosition": 272,
              "body": "Added some text on this above!",
              "createdAt": "2020-10-16T00:21:42Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5OTIzMDY5",
          "commit": {
            "abbreviatedOid": "803c908"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T00:22:04Z",
          "updatedAt": "2020-10-16T00:22:04Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "Removed that bit\u2014it's now explained in the \"conflicts\" section.",
              "createdAt": "2020-10-16T00:22:04Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNTk2NTU3",
          "commit": {
            "abbreviatedOid": "adbec76"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T15:51:49Z",
          "updatedAt": "2020-10-16T15:51:49Z",
          "comments": [
            {
              "originalPosition": 229,
              "body": "Okay, updated text to allow either side to opt out of forwarding!",
              "createdAt": "2020-10-16T15:51:49Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNTk3MzEz",
          "commit": {
            "abbreviatedOid": "adbec76"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T15:52:49Z",
          "updatedAt": "2020-10-16T15:52:50Z",
          "comments": [
            {
              "originalPosition": 217,
              "body": "Updated the text to clarify this. The stream will indeed be closed and failed with any 4xx response (that just doesn't invalidate a separate stream that requested non-forwarding proxying to the same authority).",
              "createdAt": "2020-10-16T15:52:50Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjU0NTgz",
          "commit": {
            "abbreviatedOid": "adbec76"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T17:10:44Z",
          "updatedAt": "2020-10-16T17:19:21Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "```suggestion\r\nA client sends new CONNECT-QUIC requests when it wants to start\r\n```",
              "createdAt": "2020-10-16T17:10:44Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNjgzMjIw",
          "commit": {
            "abbreviatedOid": "adbec76"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for the discussion and edits! Approved modulo a few small suggestions",
          "createdAt": "2020-10-16T17:48:03Z",
          "updatedAt": "2020-10-16T18:03:48Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nBoth clients and proxies can unilaterally choose to disable forwarded mode for any client <-> target connection.\r\n```",
              "createdAt": "2020-10-16T17:48:03Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 91,
              "body": "```suggestion\r\nThese mappings guarantee that any QUIC packet sent from a target to the proxy can be sent to the correct client,\r\nin either tunelled or forwarded mode. Note that this mapping becomes trivial if the proxy always opens a new\r\n```",
              "createdAt": "2020-10-16T17:51:18Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 199,
              "body": "```suggestion\r\n409 (Conflict) status. In order to avoid conflicts, clients SHOULD select Client Connection IDs of at least\r\n```",
              "createdAt": "2020-10-16T17:54:05Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 215,
              "body": "```suggestion\r\nSpecifically, this can occur if the Client Connection ID causes a conflict and the proxy\r\n```",
              "createdAt": "2020-10-16T17:54:40Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 234,
              "body": "```suggestion\r\nID, the client MUST send a CONNECT-QUIC request with the Client-Connection-Id header to the proxy, and only send the\r\n```",
              "createdAt": "2020-10-16T17:55:46Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 241,
              "body": "```suggestion\r\nheader to request the ability to forward packets. The client MUST wait for a successful (2xx)\r\n```",
              "createdAt": "2020-10-16T17:56:56Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            },
            {
              "originalPosition": 269,
              "body": "```suggestion\r\nA proxy MUST NOT forward packets from the target to the client until after the client has\r\nsent at least one packet in forwarded mode. Once this occurs, the proxy MAY use forwarded\r\n```",
              "createdAt": "2020-10-16T17:58:50Z",
              "updatedAt": "2020-10-16T18:10:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 25,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA0MzkwMTc0",
      "title": "Explain guarantees provided by CONNECT-QUIC",
      "url": "https://github.com/tfpauly/quic-proxy/pull/25",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "OWNER",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Explanatory text to explain goals and limitations",
      "createdAt": "2020-10-15T21:11:14Z",
      "updatedAt": "2020-10-16T15:47:14Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "8d6ecdd699ec778fc40056a264f3f946ffce005d",
      "headRepository": "tfpauly/quic-proxy",
      "headRefName": "tfp/guarantees",
      "headRefOid": "519aefffab18c265962aed2fb37f2e6e68f6b423",
      "closedAt": "2020-10-16T15:47:14Z",
      "mergedAt": "2020-10-16T15:47:14Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "48709d612f77ed7cd6d64ca7aea72f576da69ad3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODI2NjYy",
          "commit": {
            "abbreviatedOid": "519aeff"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2020-10-15T21:36:08Z",
          "updatedAt": "2020-10-15T21:36:08Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODMzNTU1",
          "commit": {
            "abbreviatedOid": "519aeff"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-15T21:49:15Z",
          "updatedAt": "2020-10-15T21:49:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 28,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA1MDE5NTg5",
      "title": "Redefine as an extension of CONNECT-UDP",
      "url": "https://github.com/tfpauly/quic-proxy/pull/28",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "OWNER",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Switch over from CONNECT-QUIC to be an extension to CONNECT-UDP. Also rename the document. I'd like to publish a version after this!",
      "createdAt": "2020-10-16T18:16:03Z",
      "updatedAt": "2020-10-16T18:52:22Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "f8c8ffe11a236bebe0959d263c8bdb7b618f7be6",
      "headRepository": "tfpauly/quic-proxy",
      "headRefName": "tfp/extension",
      "headRefOid": "3be87ad8a92e1ebff1cdffb1c4a268af626b0473",
      "closedAt": "2020-10-16T18:52:22Z",
      "mergedAt": "2020-10-16T18:52:22Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "44d633141ef9f0e6fb48acb34c749f4a0ddc12ef"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzA3NTM1",
          "commit": {
            "abbreviatedOid": "7be1f02"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-16T18:25:27Z",
          "updatedAt": "2020-10-16T18:36:31Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Since you \ud83d\udc4d the idea \ud83d\ude07\r\n```suggestion\r\n\r\n -\r\n    ins: \"D. Schinazi\"\r\n    name: \"David Schinazi\"\r\n    organization: \"Google LLC\"\r\n    street: \"1600 Amphitheatre Parkway\"\r\n    city: \"Mountain View, California 94043\"\r\n    country: \"United States of America\"\r\n    email: dschinazi.ietf@gmail.com\r\n\r\n```",
              "createdAt": "2020-10-16T18:25:27Z",
              "updatedAt": "2020-10-16T18:51:36Z"
            },
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nThe CONNECT-UDP HTTP method {{!CONNECT-UDP=I-D.ietf-masque-connect-udp}} defines a way to send\r\n```",
              "createdAt": "2020-10-16T18:28:10Z",
              "updatedAt": "2020-10-16T18:51:36Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nand a target server. This can be used to proxy QUIC connections {{!QUIC=I-D.ietf-quic-transport}},\r\n```",
              "createdAt": "2020-10-16T18:28:21Z",
              "updatedAt": "2020-10-16T18:51:36Z"
            },
            {
              "originalPosition": 96,
              "body": "```suggestion\r\nand responses. All other requirements defined for CONNECT-UDP {{CONNECT-UDP}}\r\n```",
              "createdAt": "2020-10-16T18:29:48Z",
              "updatedAt": "2020-10-16T18:51:36Z"
            },
            {
              "originalPosition": 112,
              "body": "```suggestion\r\nLike the Datagram-Flow-Id header {{CONNECT-UDP}}, the Client-Connection-Id and\r\n```",
              "createdAt": "2020-10-16T18:30:16Z",
              "updatedAt": "2020-10-16T18:51:36Z"
            },
            {
              "originalPosition": 114,
              "body": "```suggestion\r\nsupport HTTP/3 datagrams {{!H3DGRAM=I-D.schinazi-quic-h3-datagram}}, or it does not support the extension defined\r\n```",
              "createdAt": "2020-10-16T18:31:14Z",
              "updatedAt": "2020-10-16T18:51:36Z"
            },
            {
              "originalPosition": 115,
              "body": "HTTP doesn't suggest to blindly echo headers, so I don't think the proxy is technically removing the header.\r\n```suggestion\r\nin this document, it MUST NOT send the Client-Connection-Id and Server-Connection-Id headers on any\r\n```",
              "createdAt": "2020-10-16T18:32:31Z",
              "updatedAt": "2020-10-16T18:51:36Z"
            },
            {
              "originalPosition": 293,
              "body": "Assuming you take the suggestion at the top \ud83d\ude07,\r\n```suggestion\r\nThanks to Lucas Pardue, Ryan Hamilton, and Mirja K\u00fchlewind for their inputs\r\n```",
              "createdAt": "2020-10-16T18:34:15Z",
              "updatedAt": "2020-10-16T18:51:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzE5ODAx",
          "commit": {
            "abbreviatedOid": "7be1f02"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T18:45:19Z",
          "updatedAt": "2020-10-16T18:45:19Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This title is fine but I can predict there might be a slight risk of confusion (i.e. \"can't you already do that?\"). An alternative could be \"QUIC-aware proxying using CONNECT-UDP\"",
              "createdAt": "2020-10-16T18:45:19Z",
              "updatedAt": "2020-10-16T18:51:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzIxNTcz",
          "commit": {
            "abbreviatedOid": "bedec04"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T18:48:15Z",
          "updatedAt": "2020-10-16T18:48:15Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I second this!",
              "createdAt": "2020-10-16T18:48:15Z",
              "updatedAt": "2020-10-16T18:51:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzIxOTAz",
          "commit": {
            "abbreviatedOid": "bedec04"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T18:48:44Z",
          "updatedAt": "2020-10-16T18:48:44Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Sounds good to me!",
              "createdAt": "2020-10-16T18:48:44Z",
              "updatedAt": "2020-10-16T18:51:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzIzMjI0",
          "commit": {
            "abbreviatedOid": "bedec04"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T18:50:54Z",
          "updatedAt": "2020-10-16T18:50:55Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "cool. It also conveniently avoids any assertions of optimized or efficient :D",
              "createdAt": "2020-10-16T18:50:54Z",
              "updatedAt": "2020-10-16T18:51:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzIzOTg0",
          "commit": {
            "abbreviatedOid": "3be87ad"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T18:52:02Z",
          "updatedAt": "2020-10-16T18:52:03Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "=) Updated",
              "createdAt": "2020-10-16T18:52:02Z",
              "updatedAt": "2020-10-16T18:52:03Z"
            }
          ]
        }
      ]
    },
    {
      "number": 29,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA1MDkxMTQ3",
      "title": "Various cleanups",
      "url": "https://github.com/tfpauly/quic-proxy/pull/29",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR is mostly editorial, but it also adds a little text to close Lucas' two issues.\r\n\r\nCloses #26, closes #27.",
      "createdAt": "2020-10-16T20:38:32Z",
      "updatedAt": "2020-10-16T21:14:08Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "44d633141ef9f0e6fb48acb34c749f4a0ddc12ef",
      "headRepository": "tfpauly/quic-proxy",
      "headRefName": "one_more_pr",
      "headRefOid": "248e57ad5f58ce3e8756e24bca8a3064acfe3244",
      "closedAt": "2020-10-16T21:14:08Z",
      "mergedAt": "2020-10-16T21:14:07Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "66eda61d40a4b97d34cbfc27d345301c3cf500b2"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "The linebreak changes make this impossible to review on my phone, laptop packed away for the night sorry.",
          "createdAt": "2020-10-16T21:00:19Z",
          "updatedAt": "2020-10-16T21:00:19Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry about that @LPardue ",
          "createdAt": "2020-10-16T21:04:28Z",
          "updatedAt": "2020-10-16T21:04:28Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "No problem, just don't block on me if you want to merge and publish.",
          "createdAt": "2020-10-16T21:12:32Z",
          "updatedAt": "2020-10-16T21:12:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzg4Nzc5",
          "commit": {
            "abbreviatedOid": "c9d7d2a"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Approved pending nits!",
          "createdAt": "2020-10-16T20:47:11Z",
          "updatedAt": "2020-10-16T20:58:11Z",
          "comments": [
            {
              "originalPosition": 815,
              "body": "I had done this as a comment to not render in the spec, since we're tracking it already as an issue on the GitHub. We could also just remove?",
              "createdAt": "2020-10-16T20:47:11Z",
              "updatedAt": "2020-10-16T21:09:42Z"
            },
            {
              "originalPosition": 325,
              "body": "Amazing insights! ;)",
              "createdAt": "2020-10-16T20:51:40Z",
              "updatedAt": "2020-10-16T21:09:42Z"
            },
            {
              "originalPosition": 295,
              "body": "Whoops, thanks!",
              "createdAt": "2020-10-16T20:52:03Z",
              "updatedAt": "2020-10-16T21:09:42Z"
            },
            {
              "originalPosition": 103,
              "body": "```suggestion\r\n<-> target QUIC connections: the Header Form bit and the Destination Connection ID field in the short header.\r\n```",
              "createdAt": "2020-10-16T20:57:04Z",
              "updatedAt": "2020-10-16T21:09:42Z"
            },
            {
              "originalPosition": 102,
              "body": "```suggestion\r\nQUIC proxies only need to understand two fields from packets in client\r\n```",
              "createdAt": "2020-10-16T20:57:21Z",
              "updatedAt": "2020-10-16T21:09:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzk2NzYz",
          "commit": {
            "abbreviatedOid": "c9d7d2a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:02:44Z",
          "updatedAt": "2020-10-16T21:02:44Z",
          "comments": [
            {
              "originalPosition": 815,
              "body": "Oh, I see. It was only commenting out the first line, I've tweaked it to make it a multi-line comment now",
              "createdAt": "2020-10-16T21:02:44Z",
              "updatedAt": "2020-10-16T21:09:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzk2OTE2",
          "commit": {
            "abbreviatedOid": "c9d7d2a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:03:01Z",
          "updatedAt": "2020-10-16T21:03:02Z",
          "comments": [
            {
              "originalPosition": 325,
              "body": "Yeah gotta love IETF specs :) ",
              "createdAt": "2020-10-16T21:03:01Z",
              "updatedAt": "2020-10-16T21:09:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzk3Mzg3",
          "commit": {
            "abbreviatedOid": "c9d7d2a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:03:59Z",
          "updatedAt": "2020-10-16T21:04:00Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "That's not quite right, it also needs to look at long headers in target-proxy packets",
              "createdAt": "2020-10-16T21:03:59Z",
              "updatedAt": "2020-10-16T21:09:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzk3NDkw",
          "commit": {
            "abbreviatedOid": "c9d7d2a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:04:12Z",
          "updatedAt": "2020-10-16T21:04:12Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "That's not quite right, it also needs to look at long headers in target-proxy packets",
              "createdAt": "2020-10-16T21:04:12Z",
              "updatedAt": "2020-10-16T21:09:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzk3Njcw",
          "commit": {
            "abbreviatedOid": "c9d7d2a"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T21:04:37Z",
          "updatedAt": "2020-10-16T21:04:38Z",
          "comments": [
            {
              "originalPosition": 296,
              "body": "```suggestion\r\nfor all elements on the left side of the mapping diagrams above.\r\n\r\nSince very short Connection IDs are more likely to lead to conflicts, particularly zero-length\r\nConnection IDs, a proxy MAY choose to reject all requests for very short Connection IDs as\r\nconflicts, in anticipation of future conflicts.\r\n```",
              "createdAt": "2020-10-16T21:04:37Z",
              "updatedAt": "2020-10-16T21:09:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 30,
      "id": "MDExOlB1bGxSZXF1ZXN0NTEyODMzNTI2",
      "title": "\u0415\u0449\u0435 \u043e\u0434\u0438\u043d pr",
      "url": "https://github.com/tfpauly/quic-proxy/pull/30",
      "state": "CLOSED",
      "author": "Whoerr",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "closed",
      "createdAt": "2020-10-30T08:17:59Z",
      "updatedAt": "2021-02-25T18:30:53Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "tfp/lucas-comments",
      "baseRefOid": "1e218f5c523a70098594d2307918c731b3b7ae4b",
      "headRepository": "tfpauly/quic-proxy",
      "headRefName": "one_more_pr",
      "headRefOid": "248e57ad5f58ce3e8756e24bca8a3064acfe3244",
      "closedAt": "2021-02-25T18:30:53Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 31,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE4MTA4NTkw",
      "title": "Add hacky interop parser.",
      "url": "https://github.com/tfpauly/quic-proxy/pull/31",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This spits out:\r\n\r\n```\r\n\u251c\u2500\u2500 interop\r\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 tests\r\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 connect-udp.mjs\r\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 draft-pauly-masque-quic-proxy.mjs\r\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 index.mjs\r\n```\r\n\r\nWith contents:\r\n\r\n```\r\nexport default\r\n{\r\n    \"description\": \"TBD\", \r\n    \"tests\": [\r\n        {\r\n            \"kind\": \"must\", \r\n            \"name\": \"Client sends `Client-Connection-Id` in first `CONNECT-UDP` request\", \r\n            \"id\": \"connect-udp-quic-client-cid\"\r\n        }\r\n    ], \r\n    \"name\": \"QUIC-Aware Proxying Using CONNECT-UDP\", \r\n    \"id\": \"draft-pauly-masque-quic-proxy.mjs\"\r\n}\r\n```",
      "createdAt": "2020-11-09T23:33:20Z",
      "updatedAt": "2020-11-10T04:06:08Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "f36b33ba34999f07cb4c0d64d874fcad6b48aeeb",
      "headRepository": "tfpauly/quic-proxy",
      "headRefName": "caw/interop-automate",
      "headRefOid": "6d454ee1cdd516eec611b580ffda332787a2bdfa",
      "closedAt": "2020-11-10T04:06:08Z",
      "mergedAt": "2020-11-10T04:06:08Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "6a41e82adf3284abfa217eff603332a4bb70ad5e"
      },
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "This all seems fine, but why is it in the repository for this individual draft? Shouldn't we have an official MASQUE WG repo that can hold things like this for CONNECT-UDP interop results?",
          "createdAt": "2020-11-10T01:02:39Z",
          "updatedAt": "2020-11-10T01:02:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> This all seems fine, but why is it in the repository for this individual draft? Shouldn't we have an official MASQUE WG repo that can hold things like this for CONNECT-UDP interop results?\r\n\r\nMaybe, though it seems simpler to manage interop requirements and results right alongside the document source. This change extracts requirements from the document source and turns them into test targets. Implementations then submit PRs indicating their conformance against those targets.\r\n\r\nI expect the actual mechanics here to change as we get experience and feedback on how good, bad, ugly this is. ",
          "createdAt": "2020-11-10T01:09:22Z",
          "updatedAt": "2020-11-10T01:09:22Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2ODM3Mzkx",
          "commit": {
            "abbreviatedOid": "6d454ee"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Looks good! Added a provisional description.",
          "createdAt": "2020-11-10T04:06:02Z",
          "updatedAt": "2020-11-10T04:06:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 32,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE4MTk5NDE3",
      "title": "Fill out interop requirements",
      "url": "https://github.com/tfpauly/quic-proxy/pull/32",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-11-10T04:26:00Z",
      "updatedAt": "2020-11-10T13:48:16Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "6a41e82adf3284abfa217eff603332a4bb70ad5e",
      "headRepository": "tfpauly/quic-proxy",
      "headRefName": "tfp/interop-requirements",
      "headRefOid": "f147e2f463303a50b8a448634bf70ae6949e8040",
      "closedAt": "2020-11-10T13:48:16Z",
      "mergedAt": "2020-11-10T13:48:16Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9ebf5d4a2a50f090116e2516f2ccc4816dc6bf1d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 44,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE0NjcyNDIz",
      "title": "Describe conflicts with no connection IDs",
      "url": "https://github.com/tfpauly/quic-proxy/pull/44",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Closes #34",
      "createdAt": "2021-04-13T18:24:58Z",
      "updatedAt": "2021-04-13T18:52:19Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "90bcff196d632b929a414b219dc4adee96466b36",
      "headRepository": "tfpauly/quic-proxy",
      "headRefName": "tfpauly-patch-1",
      "headRefOid": "c388c428602fcff8f4a1eb6939f6674f67714631",
      "closedAt": "2021-04-13T18:52:19Z",
      "mergedAt": "2021-04-13T18:52:19Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "c2ca73020e216b49e10e5bd585e73dc7bc464d3e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM0OTE5OTkz",
          "commit": {
            "abbreviatedOid": "c388c42"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-13T18:47:55Z",
          "updatedAt": "2021-04-13T18:47:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 45,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE0Njc3MTIy",
      "title": "Add packet size considerations",
      "url": "https://github.com/tfpauly/quic-proxy/pull/45",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Closes #33",
      "createdAt": "2021-04-13T18:33:29Z",
      "updatedAt": "2021-04-13T19:10:50Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "90bcff196d632b929a414b219dc4adee96466b36",
      "headRepository": "tfpauly/quic-proxy",
      "headRefName": "tfpauly-patch-2",
      "headRefOid": "07764ba355c25d8c28d614cf8cab7fe652ac319d",
      "closedAt": "2021-04-13T18:54:48Z",
      "mergedAt": "2021-04-13T18:54:48Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "bad4057706e799843b53736d04dc6cace020f9df"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM0OTIwODM3",
          "commit": {
            "abbreviatedOid": "7f17f7c"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-13T18:48:55Z",
          "updatedAt": "2021-04-13T18:48:55Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "This doesn't parse?",
              "createdAt": "2021-04-13T18:48:55Z",
              "updatedAt": "2021-04-13T18:51:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM0OTIzMTMw",
          "commit": {
            "abbreviatedOid": "7f17f7c"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-13T18:51:41Z",
          "updatedAt": "2021-04-13T18:51:42Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nDATAGRAM frame. If the client does not begin with a larger packet size than 1200 bytes, it\r\n```",
              "createdAt": "2021-04-13T18:51:41Z",
              "updatedAt": "2021-04-13T18:51:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM0OTI0NTQy",
          "commit": {
            "abbreviatedOid": "07764ba"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-13T18:53:31Z",
          "updatedAt": "2021-04-13T18:53:51Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "you'll probably want to reflow this to match the line length limit",
              "createdAt": "2021-04-13T18:53:31Z",
              "updatedAt": "2021-04-13T18:53:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM0OTM4MjIw",
          "commit": {
            "abbreviatedOid": "07764ba"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-13T19:10:50Z",
          "updatedAt": "2021-04-13T19:10:50Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "(I can't suggest)\r\n\r\nnit: s/connections/connection",
              "createdAt": "2021-04-13T19:10:50Z",
              "updatedAt": "2021-04-13T19:10:50Z"
            }
          ]
        }
      ]
    },
    {
      "number": 46,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE0Njc5NDUy",
      "title": "Restrictions on use of server-facing socket",
      "url": "https://github.com/tfpauly/quic-proxy/pull/46",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Closes #40",
      "createdAt": "2021-04-13T18:37:46Z",
      "updatedAt": "2021-04-13T18:52:35Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "90bcff196d632b929a414b219dc4adee96466b36",
      "headRepository": "tfpauly/quic-proxy",
      "headRefName": "tfpauly-patch-3",
      "headRefOid": "13fe7ad80dc010dcad90089bd6dbf19c40c3ee2a",
      "closedAt": "2021-04-13T18:52:35Z",
      "mergedAt": "2021-04-13T18:52:35Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "179444508583fe5a3b4efcf537f02641dafbe4b9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM0OTIxNDYy",
          "commit": {
            "abbreviatedOid": "13fe7ad"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-13T18:49:40Z",
          "updatedAt": "2021-04-13T18:49:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 47,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE0NjgzNDcw",
      "title": "Mention connection migration",
      "url": "https://github.com/tfpauly/quic-proxy/pull/47",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Closes #41",
      "createdAt": "2021-04-13T18:45:13Z",
      "updatedAt": "2021-04-13T18:52:09Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "90bcff196d632b929a414b219dc4adee96466b36",
      "headRepository": "tfpauly/quic-proxy",
      "headRefName": "tfpauly-patch-4",
      "headRefOid": "6b4a1f49505def12156a8b46a6da4db1dfb0350b",
      "closedAt": "2021-04-13T18:52:09Z",
      "mergedAt": "2021-04-13T18:52:09Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "97566f816bd12e16031eeb5e6bc2ad387bf0603e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM0OTIyMDI0",
          "commit": {
            "abbreviatedOid": "6b4a1f4"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-13T18:50:19Z",
          "updatedAt": "2021-04-13T18:50:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 51,
      "id": "PR_kwDOEHrEP84s3q1n",
      "title": "Adopt capsules for QUIC-aware proxying",
      "url": "https://github.com/tfpauly/quic-proxy/pull/51",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "OWNER",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Taking a pass a rewriting QUIC-aware proxying using the H3 capsule format",
      "createdAt": "2021-10-07T03:31:44Z",
      "updatedAt": "2021-10-08T17:12:14Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "e9412b137249c29ae282fb4fd61631c204406f99",
      "headRepository": "tfpauly/quic-proxy",
      "headRefName": "tfp/capsules",
      "headRefOid": "6e68e29c5d83497c45693a46f2f2f765121a617f",
      "closedAt": "2021-10-08T17:12:14Z",
      "mergedAt": "2021-10-08T17:12:14Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "fdb6bf9ce1041e5dd68cccdc1f9d801255cadfec"
      },
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "@DavidSchinazi thanks for the review! I've updated accordingly, and think this is good now. Please re-review when you can.",
          "createdAt": "2021-10-07T23:32:24Z",
          "updatedAt": "2021-10-07T23:32:24Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "The use of capsules is a lot neater than the old multiple requests things.I haven't got my head around all of the implications yet.\r\n\r\nI don't understand the point of QUIC-proxy header but it seems harmless. Maybe some more text would help to explain why it is useful.",
          "createdAt": "2021-10-08T00:17:32Z",
          "updatedAt": "2021-10-08T00:17:32Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Thanks for all the comments @DavidSchinazi and @LPardue!\r\n\r\n@LPardue, regarding the header, I added that based on David's review. It's a way to negotiate that the new capsule types are supported, so the client knows that it won't ever get capsule responses if it doesn't hear back. We could just ignore that annoyance, and say that clients that don't hear an ACK back just deal with it. Thoughts? I'm OK to remove if we agree on that.",
          "createdAt": "2021-10-08T02:45:06Z",
          "updatedAt": "2021-10-08T02:45:06Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "Right I can sort see that making sense but it's a bit finicky. Would we really see that being enabled on a per request basis? If its a property of the connection endpoints could state it in a setting.\r\n\r\nAlternatively if this sort of thing is useful deemed useful, you could twizzle it a bit. Define a common Capsule-Extensions header that lists entries that are supported. E.g. the client would send \"Capsule-Extensions: quic-aware, foo, bar\"",
          "createdAt": "2021-10-08T03:11:39Z",
          "updatedAt": "2021-10-08T03:11:39Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "@LPardue I guess the issue with a setting is that we don't have a way to get that in H1. The nice thing about connect-udp is that it has a protocol step via Upgrade or the extended CONNECT to negotiate support.\r\n\r\nIf we do want a way to say \"I support these capsules\", that might be nice as a generic thing rather than needing headers in each extension.\r\n\r\n@DavidSchinazi , thoughts?",
          "createdAt": "2021-10-08T03:15:43Z",
          "updatedAt": "2021-10-08T03:15:43Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "body": "I can live with whatever is chosen here, it's easily modifiable ",
          "createdAt": "2021-10-08T03:17:15Z",
          "updatedAt": "2021-10-08T03:17:15Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Actually, I think we can use the header to also indicate if forwarding is supported/desired. I'm going to keep this as-is in this PR, and then do a follow-up.",
          "createdAt": "2021-10-08T17:10:14Z",
          "updatedAt": "2021-10-08T17:10:14Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP84uKLsr",
          "commit": {
            "abbreviatedOid": "17218e2"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Overall this looks great. Many small comments inline",
          "createdAt": "2021-10-07T21:39:59Z",
          "updatedAt": "2021-10-07T22:12:14Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "CONNECT-UDP isn't an \"extended CONNECT protocol\", that's just how it's conveyed over h2 and h3.\r\n```suggestion\r\nThis document defines an extension to UDP Proxying over HTTP\r\n```",
              "createdAt": "2021-10-07T21:39:59Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 24,
              "body": "```suggestion\r\nUDP Proxying over HTTP {{!CONNECT-UDP=I-D.ietf-masque-connect-udp}}\r\n```",
              "createdAt": "2021-10-07T21:40:52Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 63,
              "body": "```suggestion\r\n{{!HTTP3=I-D.ietf-quic-http}} and not any earlier versions of HTTP.\r\n```",
              "createdAt": "2021-10-07T21:41:19Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 77,
              "body": "```suggestion\r\n- Proxy: the endpoint that responds to the UDP proxying request.\r\n```",
              "createdAt": "2021-10-07T21:41:47Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 82,
              "body": "Do we still need to define this term here? Quarter stream ID is an encoding detail of HTTP datagrams over h3, I think this spec should just refer to the stream or the request?",
              "createdAt": "2021-10-07T21:42:53Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 91,
              "body": "I'd just call this the Stream Mapping. Conceptually in our implementation we'll map from the stream object, the fact that streams have IDs is a wire format detail",
              "createdAt": "2021-10-07T21:43:51Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 83,
              "body": "We've renamed HTTP/3 Datagrams to HTTP Datagrams\r\n```suggestion\r\n{{!HTTP-DGRAM=I-D.schinazi-quic-h3-datagram}} specific to a single client <-> proxy\r\n```",
              "createdAt": "2021-10-07T21:44:35Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 195,
              "body": "The max of 20 comes from QUICv1, but this spec mentions that it supports the invariants. So I'd remove this maximum. Saying that zero is invalid makes sense, but I don't think that needs to be enforced here since it'll be enforced by the conflict-checking code.",
              "createdAt": "2021-10-07T21:47:22Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 188,
              "body": "```suggestion\r\n  Connection ID (8..2040),\r\n```",
              "createdAt": "2021-10-07T21:47:38Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 187,
              "body": "We don't need the length since the capsule is self-terminating. Just use the capsule length.",
              "createdAt": "2021-10-07T21:48:13Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 237,
              "body": "I think you accidentally pasted a \u00b6 character here\r\n```suggestion\r\nstring encoded in UTF-8.\r\n```",
              "createdAt": "2021-10-07T21:49:15Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 269,
              "body": "```suggestion\r\nA client initiates UDP proxying via a CONNECT request as defined\r\n```",
              "createdAt": "2021-10-07T21:50:46Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 271,
              "body": "Should we have normative text saying that the client MUST first register a CID with the proxy and wait for the ACK_CLIENT_CID before it sends a NEW_CONNECTION_ID frame to the target server? If we don't things won't work right?",
              "createdAt": "2021-10-07T21:51:55Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 294,
              "body": "Should there be a header on both request/response so that the client can learn whether the proxy supports QUIC aware proxying? If not, the proxy is going to silently drop the REGISTER_CLIENT_CID capsule and the client will be stuck waiting",
              "createdAt": "2021-10-07T21:53:55Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 298,
              "body": "We should say that the proxy MUST reply to all REGISTER with ACK or CLOSE",
              "createdAt": "2021-10-07T21:54:19Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 213,
              "body": "We might want some normative text around which endpoint is allowed to send which capsule",
              "createdAt": "2021-10-07T21:54:49Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 426,
              "body": "```suggestion\r\nthe proxy validates the registration, tries to establish the appropriate\r\n```",
              "createdAt": "2021-10-07T21:57:51Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 428,
              "body": "I would have expected only new requests to establish server-facing sockets, not registration capsules",
              "createdAt": "2021-10-07T21:58:31Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 441,
              "body": "The demultiplexing here is by HTTP request, not on contexts\r\n\r\n```suggestion\r\nsockets across multiple UDP proxying requests, or have a unique server-facing socket\r\nfor every UDP proxying request.\r\n```",
              "createdAt": "2021-10-07T21:59:28Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 492,
              "body": "What's the point of supporting this extension if you don't support forwarding at all?",
              "createdAt": "2021-10-07T22:00:46Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 230,
              "body": "Calling these close codes conflicts with HTTP-DGRAM and is going to be confusing. How about CID Close Code? Especially renaming the prose in the rest of the doc would help.",
              "createdAt": "2021-10-07T22:02:05Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 516,
              "body": "QUIC stream states are unidirectional. Should we say that either side of the stream is closed here?",
              "createdAt": "2021-10-07T22:03:02Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 532,
              "body": "```suggestion\r\nA proxy can close its server-facing socket once all UDP proxying requests mapped to\r\n```",
              "createdAt": "2021-10-07T22:03:33Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 558,
              "body": "This qualification isn't correct for HTTP 1 and 2\r\n\r\n```suggestion\r\nan HTTP datagram.\r\n```",
              "createdAt": "2021-10-07T22:04:29Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 608,
              "body": "This is making me realize a failure mode:\r\n- client sets up UDP proxying to proxy\r\n- client sends INITIAL with SCID 0x11111111 and DCID 0x33333333\r\n- proxy decapsulates INITIAL and sends it to target server\r\n- server replies but swaps its own CID so it sends INITIAL with DCID 0x11111111 and SCID 0x77777777\r\n- proxy already has a mapping for 0x77777777 on another connection when it receives the server's packet",
              "createdAt": "2021-10-07T22:07:17Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 668,
              "body": "Replace DATAGRAM frames with HTTP Datagrams everywhere",
              "createdAt": "2021-10-07T22:08:43Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 714,
              "body": "```suggestion\r\n## CID Close Codes {#iana-close-codes}\r\n```",
              "createdAt": "2021-10-07T22:09:07Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            },
            {
              "originalPosition": 749,
              "body": "Now that I've read through the whole thing, I don't think there's value in having CID Close Codes at all. The purpose of Context Close Codes is to allow the client to take different action based on the code. I'm not seeing that here. If we want to indicate \"forwarding mode not allowed\" I'd suggest using a header instead.",
              "createdAt": "2021-10-07T22:11:50Z",
              "updatedAt": "2021-10-07T22:12:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKXq8",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:07:22Z",
          "updatedAt": "2021-10-07T23:07:23Z",
          "comments": [
            {
              "originalPosition": 749,
              "body": "Agreed, I've removed this!",
              "createdAt": "2021-10-07T23:07:22Z",
              "updatedAt": "2021-10-07T23:07:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKXs3",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:07:37Z",
          "updatedAt": "2021-10-07T23:07:37Z",
          "comments": [
            {
              "originalPosition": 668,
              "body": "Replaced!",
              "createdAt": "2021-10-07T23:07:37Z",
              "updatedAt": "2021-10-07T23:07:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKXtr",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:07:44Z",
          "updatedAt": "2021-10-07T23:07:44Z",
          "comments": [
            {
              "originalPosition": 516,
              "body": "Fixed ",
              "createdAt": "2021-10-07T23:07:44Z",
              "updatedAt": "2021-10-07T23:07:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKXug",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:07:53Z",
          "updatedAt": "2021-10-07T23:07:53Z",
          "comments": [
            {
              "originalPosition": 230,
              "body": "Removed the close codes",
              "createdAt": "2021-10-07T23:07:53Z",
              "updatedAt": "2021-10-07T23:07:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKXwL",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:08:05Z",
          "updatedAt": "2021-10-07T23:08:05Z",
          "comments": [
            {
              "originalPosition": 428,
              "body": "Indeed, this is leftover text.",
              "createdAt": "2021-10-07T23:08:05Z",
              "updatedAt": "2021-10-07T23:08:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKXxt",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:08:18Z",
          "updatedAt": "2021-10-07T23:08:18Z",
          "comments": [
            {
              "originalPosition": 213,
              "body": "Added normative text",
              "createdAt": "2021-10-07T23:08:18Z",
              "updatedAt": "2021-10-07T23:08:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKXy0",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:08:27Z",
          "updatedAt": "2021-10-07T23:08:28Z",
          "comments": [
            {
              "originalPosition": 298,
              "body": "Added in the proxy behavior section.",
              "createdAt": "2021-10-07T23:08:28Z",
              "updatedAt": "2021-10-07T23:08:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKX0s",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:08:39Z",
          "updatedAt": "2021-10-07T23:08:40Z",
          "comments": [
            {
              "originalPosition": 187,
              "body": "Sounds good, removed",
              "createdAt": "2021-10-07T23:08:40Z",
              "updatedAt": "2021-10-07T23:08:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKX3P",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:08:58Z",
          "updatedAt": "2021-10-07T23:08:58Z",
          "comments": [
            {
              "originalPosition": 195,
              "body": "Sounds good. I think we should still allow 0-2040.",
              "createdAt": "2021-10-07T23:08:58Z",
              "updatedAt": "2021-10-07T23:08:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKX4K",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:09:06Z",
          "updatedAt": "2021-10-07T23:09:07Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "Fixed",
              "createdAt": "2021-10-07T23:09:06Z",
              "updatedAt": "2021-10-07T23:09:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKX5B",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:09:12Z",
          "updatedAt": "2021-10-07T23:09:13Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Fixed",
              "createdAt": "2021-10-07T23:09:13Z",
              "updatedAt": "2021-10-07T23:09:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKX5j",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:09:18Z",
          "updatedAt": "2021-10-07T23:09:18Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "Removed",
              "createdAt": "2021-10-07T23:09:18Z",
              "updatedAt": "2021-10-07T23:09:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKX9m",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:09:54Z",
          "updatedAt": "2021-10-07T23:09:54Z",
          "comments": [
            {
              "originalPosition": 492,
              "body": "The other case we describe is using a shared socket from the proxy to the server.",
              "createdAt": "2021-10-07T23:09:54Z",
              "updatedAt": "2021-10-07T23:09:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKYRN",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:12:44Z",
          "updatedAt": "2021-10-07T23:12:44Z",
          "comments": [
            {
              "originalPosition": 608,
              "body": "I think that's fine\u2014the proxy wouldn't be able to allow forwarding for the new client's connection to a server, where the server CID is 0x77777777, but it's OK for the new server to send to the client, since it's the client's CID (the DCID in the packet here) that matters, which is 0x11111111.",
              "createdAt": "2021-10-07T23:12:44Z",
              "updatedAt": "2021-10-07T23:12:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKYU4",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:13:16Z",
          "updatedAt": "2021-10-07T23:13:16Z",
          "comments": [
            {
              "originalPosition": 271,
              "body": "We do have that already:\r\n\r\n```\r\nPrior to informing the target of a new chosen client connection ID, the client\r\nMUST send a REGISTER_CLIENT_CID capsule request containing the new Client\r\nConnection ID.\r\n```",
              "createdAt": "2021-10-07T23:13:16Z",
              "updatedAt": "2021-10-07T23:13:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKaPi",
          "commit": {
            "abbreviatedOid": "80cb71a"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:32:00Z",
          "updatedAt": "2021-10-07T23:32:00Z",
          "comments": [
            {
              "originalPosition": 294,
              "body": "Added a header and explained its usage!",
              "createdAt": "2021-10-07T23:32:00Z",
              "updatedAt": "2021-10-07T23:32:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKadD",
          "commit": {
            "abbreviatedOid": "86610de"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:34:15Z",
          "updatedAt": "2021-10-07T23:34:16Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "This title is OK. But, based on the renaming of the dependent specs and how you treat that in your body text, perhaps you could call it\r\n\r\n`QUIC Proxying Optimization using HTTP/3`\r\n\r\nShortened to QPOH and pronounce like \"kapow!\"",
              "createdAt": "2021-10-07T23:34:15Z",
              "updatedAt": "2021-10-07T23:34:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKash",
          "commit": {
            "abbreviatedOid": "80cb71a"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:36:44Z",
          "updatedAt": "2021-10-07T23:36:44Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "It's not until mid-way through the intro does it become clear this only works for HTTP/3 connections. That _might_ be useful to know earlier.",
              "createdAt": "2021-10-07T23:36:44Z",
              "updatedAt": "2021-10-07T23:37:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKa7K",
          "commit": {
            "abbreviatedOid": "1f3e6ff"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:39:14Z",
          "updatedAt": "2021-10-07T23:39:14Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "@LPardue the quic-awareness works for all versions of HTTP, it's just forwarding mode that is HTTP/3 only.",
              "createdAt": "2021-10-07T23:39:14Z",
              "updatedAt": "2021-10-07T23:39:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKa-J",
          "commit": {
            "abbreviatedOid": "80cb71a"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:39:45Z",
          "updatedAt": "2021-10-07T23:39:46Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "it's adopted now :)\r\n\r\n```suggestion\r\nHTTP Datagram frames {{!HTTP-DGRAM=I-D.masque-h3-datagram}}, or be forwarded\r\n```",
              "createdAt": "2021-10-07T23:39:46Z",
              "updatedAt": "2021-10-07T23:39:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKbDK",
          "commit": {
            "abbreviatedOid": "48f01d8"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:40:35Z",
          "updatedAt": "2021-10-07T23:40:35Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Clarified this in the abstract",
              "createdAt": "2021-10-07T23:40:35Z",
              "updatedAt": "2021-10-07T23:40:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKbKR",
          "commit": {
            "abbreviatedOid": "e85d0f9"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:41:47Z",
          "updatedAt": "2021-10-07T23:41:47Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "Indeed, fixed!",
              "createdAt": "2021-10-07T23:41:47Z",
              "updatedAt": "2021-10-07T23:41:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKbhE",
          "commit": {
            "abbreviatedOid": "e85d0f9"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:45:39Z",
          "updatedAt": "2021-10-07T23:45:40Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "ah fair point. if you change the final word to `HTTP` the acronym still works ;)",
              "createdAt": "2021-10-07T23:45:39Z",
              "updatedAt": "2021-10-07T23:45:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKbmU",
          "commit": {
            "abbreviatedOid": "e85d0f9"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:46:32Z",
          "updatedAt": "2021-10-07T23:46:32Z",
          "comments": [
            {
              "originalPosition": 608,
              "body": "I wasn't concerned about forwarding, more about sharing a socket on the proxy. Because when the proxy picks the socket the CIDs don't conflict but then it finds out they conflict. Or am I misunderstanding how socket sharing works?",
              "createdAt": "2021-10-07T23:46:32Z",
              "updatedAt": "2021-10-07T23:46:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKbs8",
          "commit": {
            "abbreviatedOid": "e85d0f9"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T23:47:38Z",
          "updatedAt": "2021-10-08T00:13:13Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "```suggestion\r\nProxy awareness of QUIC Connection IDs relies on using capsules ({{HTTP-DGRAM}})\r\n```",
              "createdAt": "2021-10-07T23:47:38Z",
              "updatedAt": "2021-10-08T00:13:13Z"
            },
            {
              "originalPosition": 360,
              "body": "```suggestion\r\nThe client should only inform the target of the new Client Connection ID once an\r\n```",
              "createdAt": "2021-10-07T23:58:33Z",
              "updatedAt": "2021-10-08T00:13:13Z"
            },
            {
              "originalPosition": 372,
              "body": "```suggestion\r\nThe client MUST wait for an ACK_SERVER_CID capsule that contains the echoed\r\n```",
              "createdAt": "2021-10-07T23:58:50Z",
              "updatedAt": "2021-10-08T00:13:13Z"
            },
            {
              "originalPosition": 430,
              "body": "no need to state it's the same if you provide the value to send\r\n\r\n```suggestion\r\nby including a \"Proxy-QUIC\" header with a value of \"?1\" in a\r\nsuccessful response.\r\n```",
              "createdAt": "2021-10-08T00:01:03Z",
              "updatedAt": "2021-10-08T00:13:13Z"
            },
            {
              "originalPosition": 456,
              "body": "It's not the request authority now, it's the path",
              "createdAt": "2021-10-08T00:03:20Z",
              "updatedAt": "2021-10-08T00:13:13Z"
            },
            {
              "originalPosition": 488,
              "body": "is the use of context here correct? The example uses REGISTER_NO_CONTEXT",
              "createdAt": "2021-10-08T00:05:31Z",
              "updatedAt": "2021-10-08T00:13:13Z"
            },
            {
              "originalPosition": 496,
              "body": "\"first request for a given HTTP request\" reads a bit wonky even if it is accurate",
              "createdAt": "2021-10-08T00:06:38Z",
              "updatedAt": "2021-10-08T00:13:13Z"
            },
            {
              "originalPosition": 576,
              "body": "```suggestion\r\nof the new QUIC Client Connection ID, the client also sends a\r\n```",
              "createdAt": "2021-10-08T00:07:56Z",
              "updatedAt": "2021-10-08T00:13:13Z"
            },
            {
              "originalPosition": 664,
              "body": "```suggestion\r\nUpon receiving an ACK_SERVER_CID capsule, the client starts sending Short Header\r\n```",
              "createdAt": "2021-10-08T00:09:39Z",
              "updatedAt": "2021-10-08T00:13:13Z"
            },
            {
              "originalPosition": 753,
              "body": "```suggestion\r\nThis document registers six new values in the \"HTTP Capsule Types\"\r\n```",
              "createdAt": "2021-10-08T00:12:18Z",
              "updatedAt": "2021-10-08T00:13:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKfTJ",
          "commit": {
            "abbreviatedOid": "e85d0f9"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-08T00:28:33Z",
          "updatedAt": "2021-10-08T00:35:32Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Should we also note that this doesn't work in the presence of intermediaries between the client and proxy?",
              "createdAt": "2021-10-08T00:28:33Z",
              "updatedAt": "2021-10-08T00:35:32Z"
            },
            {
              "originalPosition": 488,
              "body": "I'd just skip mention of datagram contexts altogether in this sentence. \"Use the correct thing\" isn't particularly useful",
              "createdAt": "2021-10-08T00:35:08Z",
              "updatedAt": "2021-10-08T00:35:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKpg8",
          "commit": {
            "abbreviatedOid": "e85d0f9"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-08T02:32:10Z",
          "updatedAt": "2021-10-08T02:32:10Z",
          "comments": [
            {
              "originalPosition": 608,
              "body": "There is only one mapping that involves the Server CID, which is this:\r\n\r\n~~~\r\n(Client-facing socket + Server Connection ID)\r\n    => Server-facing socket\r\n~~~\r\n\r\nIt only matters to have a conflict about the Server CID within a given client-facing socket (or to the proxy itself).",
              "createdAt": "2021-10-08T02:32:10Z",
              "updatedAt": "2021-10-08T02:32:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKpn3",
          "commit": {
            "abbreviatedOid": "e85d0f9"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-08T02:33:37Z",
          "updatedAt": "2021-10-08T02:33:37Z",
          "comments": [
            {
              "originalPosition": 456,
              "body": "```suggestion\r\nthe target hostname in the CONNECT request, or finding an existing server-facing\r\n```",
              "createdAt": "2021-10-08T02:33:37Z",
              "updatedAt": "2021-10-08T02:33:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKqVG",
          "commit": {
            "abbreviatedOid": "6e68e29"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-08T02:41:52Z",
          "updatedAt": "2021-10-08T02:41:53Z",
          "comments": [
            {
              "originalPosition": 488,
              "body": "Good call! Fixed up this sentence",
              "createdAt": "2021-10-08T02:41:52Z",
              "updatedAt": "2021-10-08T02:41:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKqXo",
          "commit": {
            "abbreviatedOid": "6e68e29"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-08T02:42:18Z",
          "updatedAt": "2021-10-08T02:42:19Z",
          "comments": [
            {
              "originalPosition": 496,
              "body": "I think this sentence wasn't needed, removed",
              "createdAt": "2021-10-08T02:42:18Z",
              "updatedAt": "2021-10-08T02:42:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uKqbE",
          "commit": {
            "abbreviatedOid": "6e68e29"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-08T02:42:55Z",
          "updatedAt": "2021-10-08T02:42:55Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Added text for that",
              "createdAt": "2021-10-08T02:42:55Z",
              "updatedAt": "2021-10-08T02:42:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 52,
      "id": "PR_kwDOEHrEP84s9Y4x",
      "title": "Use header to negotiate forwarding, allow forwarding immediately for \u2026",
      "url": "https://github.com/tfpauly/quic-proxy/pull/52",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "OWNER",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Use header to negotiate forwarding, allow forwarding immediately for short headers.\r\n\r\nThis makes the header more useful, and allows clients to start receiving forwarded packets without waiting. This has been an issue for our deployment, where the MTU changes for short header packets from target to client shortly after switching to SH packets, but not always immediately.",
      "createdAt": "2021-10-08T19:36:02Z",
      "updatedAt": "2021-10-11T18:01:19Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "fdb6bf9ce1041e5dd68cccdc1f9d801255cadfec",
      "headRepository": "tfpauly/quic-proxy",
      "headRefName": "tfp/header-negotiation",
      "headRefOid": "c2c5c5f8993d9aa43175502bc0f28ffc61e32a71",
      "closedAt": "2021-10-11T18:01:19Z",
      "mergedAt": "2021-10-11T18:01:19Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "ad94640114f279624009dc17873953d7fde42f42"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP84uN0ew",
          "commit": {
            "abbreviatedOid": "a6a2137"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-08T20:11:55Z",
          "updatedAt": "2021-10-08T20:11:55Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "reads weird.\r\n\r\n\"if the proxy supports, it will send Proxy-QUIC-Forwarding, the value says if it supports\"\r\n\r\nAre you trying to distinguish between implementations that support the forwarding feature outright, and implementations that choose to enable or disable forwarding on each request?",
              "createdAt": "2021-10-08T20:11:55Z",
              "updatedAt": "2021-10-08T20:11:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uN0l2",
          "commit": {
            "abbreviatedOid": "a6a2137"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-08T20:12:35Z",
          "updatedAt": "2021-10-08T20:12:36Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "'til death us do part\r\n\r\n```suggestion\r\nnot understand how to parse Connection ID capsules, and SHOULD NOT send any\r\n```",
              "createdAt": "2021-10-08T20:12:35Z",
              "updatedAt": "2021-10-08T20:12:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uN1Ix",
          "commit": {
            "abbreviatedOid": "5eea1ab"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm modulo nits",
          "createdAt": "2021-10-08T20:16:07Z",
          "updatedAt": "2021-10-08T20:16:07Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEHrEP84uN8Ms",
          "commit": {
            "abbreviatedOid": "b36f848"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-08T21:02:38Z",
          "updatedAt": "2021-10-08T21:02:38Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Fixed!",
              "createdAt": "2021-10-08T21:02:38Z",
              "updatedAt": "2021-10-08T21:02:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uSNBN",
          "commit": {
            "abbreviatedOid": "b36f848"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Overall looks great, minor comments inline",
          "createdAt": "2021-10-11T17:30:22Z",
          "updatedAt": "2021-10-11T17:43:09Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "I'd say MUST NOT here (though we need a carveout to say it's OK to send them before receiving the response, but I think that's already written somewhere)",
              "createdAt": "2021-10-11T17:30:22Z",
              "updatedAt": "2021-10-11T17:43:09Z"
            },
            {
              "originalPosition": 77,
              "body": "Perhaps it would help if we define the term \"proxy-facing socket\" in the Terminology section and use it here?",
              "createdAt": "2021-10-11T17:38:11Z",
              "updatedAt": "2021-10-11T17:43:09Z"
            },
            {
              "originalPosition": 79,
              "body": "```suggestion\r\nREGISTER_CLIENT_CID capsule. The client uses the Destination Connection ID field of the received packet to\r\n```",
              "createdAt": "2021-10-11T17:39:07Z",
              "updatedAt": "2021-10-11T17:43:09Z"
            },
            {
              "originalPosition": 43,
              "body": "I feel like this paragraph would fit better in the \"Proxy Response Behavior\" section. Perhaps we move it there and here just say \"Support for forwarding mode is determined by the \"Proxy-QUIC-Forwarding\" header, see {{response}}.\"",
              "createdAt": "2021-10-11T17:40:51Z",
              "updatedAt": "2021-10-11T17:43:09Z"
            },
            {
              "originalPosition": 107,
              "body": "This bit about zero-length CIDs feels out of place. What does it have to do with the rest of the paragraph which doesn't mention zero-length CIDs at all?",
              "createdAt": "2021-10-11T17:42:48Z",
              "updatedAt": "2021-10-11T17:43:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uSSFB",
          "commit": {
            "abbreviatedOid": "c2c5c5f"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T18:00:27Z",
          "updatedAt": "2021-10-11T18:00:27Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Good call, changed",
              "createdAt": "2021-10-11T18:00:27Z",
              "updatedAt": "2021-10-11T18:00:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uSSKU",
          "commit": {
            "abbreviatedOid": "c2c5c5f"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T18:00:53Z",
          "updatedAt": "2021-10-11T18:00:53Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "It's technically the same one as the \"client-facing socket\"... I'll leave this off for now",
              "createdAt": "2021-10-11T18:00:53Z",
              "updatedAt": "2021-10-11T18:00:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uSSLE",
          "commit": {
            "abbreviatedOid": "c2c5c5f"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T18:00:56Z",
          "updatedAt": "2021-10-11T18:00:56Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "Fixed",
              "createdAt": "2021-10-11T18:00:56Z",
              "updatedAt": "2021-10-11T18:00:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uSSMd",
          "commit": {
            "abbreviatedOid": "c2c5c5f"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T18:01:03Z",
          "updatedAt": "2021-10-11T18:01:03Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Good idea! Done.",
              "createdAt": "2021-10-11T18:01:03Z",
              "updatedAt": "2021-10-11T18:01:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP84uSSPE",
          "commit": {
            "abbreviatedOid": "c2c5c5f"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T18:01:16Z",
          "updatedAt": "2021-10-11T18:01:16Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "Yeah, I changed it to just be about a conflict instead",
              "createdAt": "2021-10-11T18:01:16Z",
              "updatedAt": "2021-10-11T18:01:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 55,
      "id": "PR_kwDOEHrEP84tCBBE",
      "title": "Server -> Target",
      "url": "https://github.com/tfpauly/quic-proxy/pull/55",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Use \"target\" name more than \"server\" to avoid confusion\r\n\r\nCloses #53 ",
      "createdAt": "2021-10-11T17:44:11Z",
      "updatedAt": "2021-10-11T17:55:09Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "tfp/header-negotiation",
      "baseRefOid": "b36f84899a4ca5ecdad96d282a5a55ec2bb428ab",
      "headRepository": "tfpauly/quic-proxy",
      "headRefName": "tfp/target",
      "headRefOid": "ef560f0dd700ebacc85291950458037631e68bff",
      "closedAt": "2021-10-11T17:55:09Z",
      "mergedAt": "2021-10-11T17:55:09Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "ad261ff58b58d4133ec8cb24f56d2ca9155da7c3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP84uSQ5r",
          "commit": {
            "abbreviatedOid": "ef560f0"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-11T17:53:32Z",
          "updatedAt": "2021-10-11T17:53:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 57,
      "id": "PR_kwDOEHrEP84z-1TE",
      "title": "Update to draft-ietf-masque-connect-udp-07",
      "url": "https://github.com/tfpauly/quic-proxy/pull/57",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-03-05T00:49:03Z",
      "updatedAt": "2022-03-05T00:51:15Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "1b046aaaea141cbed076980a2c92f58711417356",
      "headRepository": "tfpauly/quic-proxy",
      "headRefName": "design_team",
      "headRefOid": "f2409d6c932b13c903180446376f1e27f7676204",
      "closedAt": "2022-03-05T00:51:15Z",
      "mergedAt": "2022-03-05T00:51:15Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "875fd82750e12f47d67e477ee78f000fde935d56"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP841saxM",
          "commit": {
            "abbreviatedOid": "f2409d6"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-05T00:51:11Z",
          "updatedAt": "2022-03-05T00:51:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 58,
      "id": "PR_kwDOEHrEP845fA-d",
      "title": "Clarify mapping language",
      "url": "https://github.com/tfpauly/quic-proxy/pull/58",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "OWNER",
      "assignees": [
        "tfpauly"
      ],
      "labels": [],
      "body": "Suggestions from Eric Rosenberg",
      "createdAt": "2022-06-10T18:35:00Z",
      "updatedAt": "2022-06-14T16:08:44Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "875fd82750e12f47d67e477ee78f000fde935d56",
      "headRepository": "tfpauly/quic-proxy",
      "headRefName": "tfpauly-patch-5",
      "headRefOid": "9be72504bbe5647e1724d5897a64c9fca1c78076",
      "closedAt": "2022-06-14T16:08:44Z",
      "mergedAt": "2022-06-14T16:08:44Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "f9e2b546e44b9ef46920250f7ac6bdfcb9740c65"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP8479zmj",
          "commit": {
            "abbreviatedOid": "bf846dc"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is a great clarification. LGTM modulo two small nits",
          "createdAt": "2022-06-14T15:12:11Z",
          "updatedAt": "2022-06-14T15:12:54Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "We'll probably want to refactor this spec to explain what works with general HTTP and what works only with HTTP/3, but for now I'd suggest keeping this HTTP.\r\n\r\n```suggestion\r\n- Client <-> Proxy HTTP stream: a single HTTP stream established from\r\n```",
              "createdAt": "2022-06-14T15:12:11Z",
              "updatedAt": "2022-06-14T15:12:54Z"
            },
            {
              "originalPosition": 57,
              "body": "```suggestion\r\nHTTP stream or client-facing socket.\r\n```",
              "createdAt": "2022-06-14T15:12:31Z",
              "updatedAt": "2022-06-14T15:12:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 60,
      "id": "PR_kwDOEHrEP84-K2k5",
      "title": "Virtual Target Connection ID",
      "url": "https://github.com/tfpauly/quic-proxy/pull/60",
      "state": "MERGED",
      "author": "ehaydenr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-08-31T23:52:30Z",
      "updatedAt": "2022-09-02T22:45:36Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "f9e2b546e44b9ef46920250f7ac6bdfcb9740c65",
      "headRepository": "ehaydenr/quic-proxy",
      "headRefName": "virtual",
      "headRefOid": "c2f93997ee56a5c52633f963599b561107ad7659",
      "closedAt": "2022-09-02T22:45:36Z",
      "mergedAt": "2022-09-02T22:45:36Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "050afbdca7d33c327b67a56d6a9ffe5a0353b988"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85BIFGt",
          "commit": {
            "abbreviatedOid": "6561bda"
          },
          "author": "LPardue",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-01T00:18:22Z",
          "updatedAt": "2022-09-01T00:37:09Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I might say here something that sounds less strict\r\n\r\n\"QUIC endpoints issue Connection IDs to their peers, which are used in the Destination Connection ID field of packets sent by the peer. An endpoint on might rely on a load balancer to route QUIC packets to it, based on encoding information into the Connection IDs it issues; such as described in {{?QUIC-LB=I-D.ietf-quic-load-balancers}}. Such deployments are typically private and deployment specific and, crucially, rely on the peer using the Connection IDs that were issued. When operating in forwarding mode...\"",
              "createdAt": "2022-09-01T00:18:22Z",
              "updatedAt": "2022-09-01T00:39:11Z"
            },
            {
              "originalPosition": 26,
              "body": "How about something like\r\n\r\n\"clients send QUIC packets destined for the Target, directly to the Proxy. These packets\r\nuse Connection IDs issued by the Target, which may fail to meet the exceptions of a\r\nload balancer in front of the Proxy, introducing a potential for packet delivery failure.\"",
              "createdAt": "2022-09-01T00:22:28Z",
              "updatedAt": "2022-09-01T00:39:28Z"
            },
            {
              "originalPosition": 32,
              "body": "In keeping with prior suggestion, something like this maybe? \r\n\r\n\"The Virtual Target Connection ID can be used to address problems with load balancer routing. A Proxy can issue a Virtual Target Connection ID to a client. When the Proxy receives a QUIC packet with a Virtual Target Connection ID value, it substitutes the value with the actual Target Connection ID prior to forwarding. Routing problems are typically only a problem for packets travelling from Client to Target, so Virtual Target Connection IDs are only used in this direction.\"\r\n",
              "createdAt": "2022-09-01T00:33:19Z",
              "updatedAt": "2022-09-01T00:39:44Z"
            },
            {
              "originalPosition": 36,
              "body": "Can probably simplify this, when forwarding mode isn't in use, we're just back to normal UDP proxying (I think). So maybe\r\n\r\n\"When forwarding mode is not used to proxy QUIC, the concerns related to packet routing do not apply.\"",
              "createdAt": "2022-09-01T00:37:06Z",
              "updatedAt": "2022-09-01T00:37:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85BRCUn",
          "commit": {
            "abbreviatedOid": "6561bda"
          },
          "author": "ehaydenr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-02T14:42:44Z",
          "updatedAt": "2022-09-02T14:42:45Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Adjusted this text to be a little more similar to [another place in the document](https://github.com/tfpauly/quic-proxy/blob/main/draft-pauly-masque-quic-proxy.md#adding-new-client-connection-ids)\r\n> Since QUIC connection IDs are chosen by the receiver",
              "createdAt": "2022-09-02T14:42:44Z",
              "updatedAt": "2022-09-02T14:42:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85BRJZe",
          "commit": {
            "abbreviatedOid": "87b295d"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-02T15:04:25Z",
          "updatedAt": "2022-09-02T15:04:26Z",
          "comments": [
            {
              "originalPosition": 171,
              "body": "```suggestion\r\n: The Proxy-chosen connection ID that the client MUST use when sending packets\r\n```",
              "createdAt": "2022-09-02T15:04:25Z",
              "updatedAt": "2022-09-02T15:04:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85BRJpE",
          "commit": {
            "abbreviatedOid": "87b295d"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-02T15:05:07Z",
          "updatedAt": "2022-09-02T15:05:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 62,
      "id": "PR_kwDOEHrEP84_Oxh8",
      "title": "bidirectional virtual connection ids",
      "url": "https://github.com/tfpauly/quic-proxy/pull/62",
      "state": "MERGED",
      "author": "ehaydenr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "addresses #61 ",
      "createdAt": "2022-09-19T21:43:31Z",
      "updatedAt": "2022-10-18T21:36:19Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "050afbdca7d33c327b67a56d6a9ffe5a0353b988",
      "headRepository": "ehaydenr/quic-proxy",
      "headRefName": "bidirectional-virtual",
      "headRefOid": "67a68aba9a02a55a21b5abcb2f25f3849d6cd1dd",
      "closedAt": "2022-10-18T21:36:10Z",
      "mergedAt": "2022-10-18T21:36:10Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "4bb7edf24c105d7f82fd3dda19cf201991f62d21"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85CVe58",
          "commit": {
            "abbreviatedOid": "16140f1"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for doing this! A few minor comments",
          "createdAt": "2022-09-19T22:00:07Z",
          "updatedAt": "2022-09-19T22:13:15Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "Why the discrepancy here? Is there a reason to force the lengths to be equal?",
              "createdAt": "2022-09-19T22:00:07Z",
              "updatedAt": "2022-09-19T22:13:15Z"
            },
            {
              "originalPosition": 139,
              "body": "```suggestion\r\n: The receiver-chosen connection ID that the sender MUST use when sending\r\n```",
              "createdAt": "2022-09-19T22:00:32Z",
              "updatedAt": "2022-09-19T22:13:15Z"
            },
            {
              "originalPosition": 138,
              "body": "Mentions of sender and receiver in this paragraph are unclear: I was expecting them to be the sender/receiver of the capsule being discussed, but that doesn't appear to be the case",
              "createdAt": "2022-09-19T22:01:37Z",
              "updatedAt": "2022-09-19T22:13:15Z"
            },
            {
              "originalPosition": 149,
              "body": "This isn't specific to this PR, but it would be nice to add a paragraph explaining why proxies care about stateless reset tokens and in which scenarios this feature would be useful",
              "createdAt": "2022-09-19T22:06:50Z",
              "updatedAt": "2022-09-19T22:13:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CViCO",
          "commit": {
            "abbreviatedOid": "eb87156"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-19T22:16:51Z",
          "updatedAt": "2022-09-19T22:16:52Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "To match the order of the CIDs above, let's put Virtual CCID before Virtual TCID",
              "createdAt": "2022-09-19T22:16:51Z",
              "updatedAt": "2022-09-19T22:16:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CVily",
          "commit": {
            "abbreviatedOid": "eb87156"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-19T22:20:07Z",
          "updatedAt": "2022-09-19T22:23:34Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nreceives. Servers receiving QUIC packets may employ load balancing\r\n```",
              "createdAt": "2022-09-19T22:20:07Z",
              "updatedAt": "2022-09-19T22:23:34Z"
            },
            {
              "originalPosition": 26,
              "body": "```suggestion\r\nQUIC allows each endpoint of a connection to choose the destination connection IDs it\r\n```",
              "createdAt": "2022-09-19T22:20:32Z",
              "updatedAt": "2022-09-19T22:23:34Z"
            },
            {
              "originalPosition": 39,
              "body": "I think this is true for all clients, can we just say that \"QUIC requires that connections IDs aren't reused over multiple network paths to...\"?",
              "createdAt": "2022-09-19T22:21:26Z",
              "updatedAt": "2022-09-19T22:23:34Z"
            },
            {
              "originalPosition": 44,
              "body": "To \"a\" proxy network path? To \"the\" proxy network path?",
              "createdAt": "2022-09-19T22:22:04Z",
              "updatedAt": "2022-09-19T22:23:34Z"
            },
            {
              "originalPosition": 45,
              "body": "```suggestion\r\npackets destined for the client would have the same connection ID.\r\n```",
              "createdAt": "2022-09-19T22:22:15Z",
              "updatedAt": "2022-09-19T22:23:34Z"
            },
            {
              "originalPosition": 203,
              "body": "Same socket? Same 5-tuple?",
              "createdAt": "2022-09-19T22:22:52Z",
              "updatedAt": "2022-09-19T22:23:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CVp6U",
          "commit": {
            "abbreviatedOid": "eb87156"
          },
          "author": "ehaydenr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-19T23:11:11Z",
          "updatedAt": "2022-09-19T23:11:11Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "I was thinking about differences between passive and active migration. In the passive case, the CID may not have changed despite having been reused over a new network path. I'm wondering if it is necessary to mention this here or if the language you propose is sufficient.",
              "createdAt": "2022-09-19T23:11:11Z",
              "updatedAt": "2022-09-19T23:11:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CVrCL",
          "commit": {
            "abbreviatedOid": "eb87156"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-19T23:20:00Z",
          "updatedAt": "2022-09-19T23:20:01Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "QUIC has text about that already, I'd be tempted to say that we just refer to that since it was very carefully worded \ud83e\udd37 ",
              "createdAt": "2022-09-19T23:20:00Z",
              "updatedAt": "2022-09-19T23:20:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CVz85",
          "commit": {
            "abbreviatedOid": "eb87156"
          },
          "author": "ehaydenr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T00:35:31Z",
          "updatedAt": "2022-09-20T00:35:31Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "The discrepancy is motivated by implementation considerations. If implementing forwarding in a way that requires fixing IP and/or UDP checksums, only length changes by a multiple of 4 can be done incrementally. If the length difference is not a multiple of 4, the entire checksum would have to be recomputed. One example of this constraint is documented in [Linux's BPF helpers](https://man7.org/linux/man-pages/man7/bpf-helpers.7.html) (bpf_csum_diff):\r\n\r\n> Compute a checksum difference, from the raw buffer\r\n                     pointed by from, of length from_size (that must be\r\n                     a multiple of 4), towards the raw buffer pointed by\r\n                     to, of size to_size (same remark).\r\n\r\nIn the Virtual Target Connection ID case, the requirement to support Virtual Connection IDs of a different length is quite clear. Load balancing strategies such as those described QUIC-LB may require a minimum CID length to encode information (e.g. 17 bytes in the [single-pass encryption](https://datatracker.ietf.org/doc/html/draft-ietf-quic-load-balancers#section-4.3.1) case). If the proxy intended on using an incremental checksum algorithm, it could make sure that the Virtual Target CID is a multiple of 4 larger than the Target CID. For example, if the Target CID is 15 bytes, it could provide a Virtual Target CID of 19 bytes (17 \"real\" bytes encoding/encrypting information followed by 2 randomly chosen bytes). The replace operation of a 19 bytes buffer to a 15 byte buffer would be compatible with incremental checksum algorithms since 4 bytes are removed.\r\n\r\nRequiring the Target Connection ID be at least the length of the Virtual Target Connection ID would necessitate cooperation with the target and as such is a non-starter. The draft currently allows any type of length difference between the Target Connection ID and Virtual Target Connection ID. We could instead tighten this up by requiring that the Virtual Target Connection ID be at least as long as the Target Connection ID, but I'm not sure how useful this is.\r\n\r\nBy requiring that the Client CID and Virtual Client CID lengths be equal, we're guaranteeing that incremental checksum is possible. We could instead require that the difference in length between Client CID and Virtual Client CID be a multiple of 4, but that seems like too specific of a requirement - particularly if it is of no real consequence to simply require they be equal.\r\n\r\nBy taking the above Virtual Target Connection ID length difference case as a requirement, we're precluding the client from using incremental checksum algorithms in the first place because it must be able to translate between arbitrary lengths when sending. Given that the client already needs to handle arbitrary length differences and that Client and Virtual Client CIDs are BOTH generated by the client, I would think that it has sufficient flexibility in crafting a Virtual Client CID of equivalent length that meet its needs. If we chose not to require this, the inclusion of Virtual Client CID (this PR) would introduce the requirement to do a full checksum recalculation for the reasons described above. \r\n",
              "createdAt": "2022-09-20T00:35:31Z",
              "updatedAt": "2022-09-20T00:35:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CV0bs",
          "commit": {
            "abbreviatedOid": "eb87156"
          },
          "author": "ehaydenr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T00:40:08Z",
          "updatedAt": "2022-09-20T00:40:08Z",
          "comments": [
            {
              "originalPosition": 203,
              "body": "I'm reusing the language as above: https://github.com/tfpauly/quic-proxy/blob/050afbdca7d33c327b67a56d6a9ffe5a0353b988/draft-pauly-masque-quic-proxy.md?plain=1#L453 `git blame` shows @DavidSchinazi so I'll defer to him\r\n",
              "createdAt": "2022-09-20T00:40:08Z",
              "updatedAt": "2022-09-20T00:40:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CV1OJ",
          "commit": {
            "abbreviatedOid": "eb87156"
          },
          "author": "ehaydenr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T00:47:41Z",
          "updatedAt": "2022-09-20T00:47:41Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "> ... choose the destination connection IDs it receives\r\n\r\nTo me, that reads a little ambiguously. An endpoints of a QUIC connection \"receives\" connection IDs from its peer via NEW_CONNECTION_ID frames, but that's obviously not what you meant. That being said, I don't love the language as-is either, but it's a carry over from the previous PR. May or may not make sense to address it now. ",
              "createdAt": "2022-09-20T00:47:41Z",
              "updatedAt": "2022-09-20T00:47:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CV1eb",
          "commit": {
            "abbreviatedOid": "eb87156"
          },
          "author": "ehaydenr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T00:50:07Z",
          "updatedAt": "2022-09-20T00:50:08Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "thanks, 148fd98781f95cca92ee3f0fe052469658f17957",
              "createdAt": "2022-09-20T00:50:07Z",
              "updatedAt": "2022-09-20T00:50:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CV1wQ",
          "commit": {
            "abbreviatedOid": "eb87156"
          },
          "author": "ehaydenr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T00:52:48Z",
          "updatedAt": "2022-09-20T00:52:49Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "good catch: 5c419f6be0ae9b855be73a397dc114a6085bb829",
              "createdAt": "2022-09-20T00:52:49Z",
              "updatedAt": "2022-09-20T00:52:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CV2no",
          "commit": {
            "abbreviatedOid": "eb87156"
          },
          "author": "ehaydenr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T01:00:54Z",
          "updatedAt": "2022-09-20T01:00:54Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "thanks, updated the language and made a few other changes here: 65db5de9489c96463f48ab2d9d8edafdfc8f1d8f",
              "createdAt": "2022-09-20T01:00:54Z",
              "updatedAt": "2022-09-20T01:00:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CV2tz",
          "commit": {
            "abbreviatedOid": "16140f1"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T01:01:46Z",
          "updatedAt": "2022-09-20T01:01:46Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "Thanks for the detailed explanation. I would suggest making this a SHOULD instead of a MUST: if the absolute worst case scenario is recomputing the checksum on each packet, then that doesn't warrant a MUST. There might be use-cases where a client or proxy isn't in control of its CID length, and in such scenarios they'd rather pay the checksum cost instead of failing.",
              "createdAt": "2022-09-20T01:01:46Z",
              "updatedAt": "2022-09-20T01:01:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CV3Hv",
          "commit": {
            "abbreviatedOid": "eb87156"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T01:05:30Z",
          "updatedAt": "2022-09-20T01:05:30Z",
          "comments": [
            {
              "originalPosition": 203,
              "body": "Sockets are explicitly defined as UDP 4-tuples in Section 1.2, so using the word \"socket\" here is fine by me",
              "createdAt": "2022-09-20T01:05:30Z",
              "updatedAt": "2022-09-20T01:06:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CV6gt",
          "commit": {
            "abbreviatedOid": "16140f1"
          },
          "author": "ehaydenr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T01:35:27Z",
          "updatedAt": "2022-09-20T01:35:27Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "Something I forgot to include that is also worth considering is that the Virtual Client CID must be at least as long as the Client CID to avoid linkability. Consider the case of connection migration. If the Virtual Client CID is 0xaabb and the Client CID is 0x11223344, and the Virtual Client CID was changed due to migration to 0xccdd, the packet would go from flags byte followed by 0xaabb3344 to 0xccdd3344. The \"3344\" would increase linkability.\r\n\r\nThe Virtual Target Connection ID has the same issue - the client<->proxy network path change would expose any extra client<->target CID bytes. I think in both cases the Virtual Connection ID must be at least as long as its counterpart.",
              "createdAt": "2022-09-20T01:35:27Z",
              "updatedAt": "2022-09-20T01:35:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CZoGk",
          "commit": {
            "abbreviatedOid": "16140f1"
          },
          "author": "ehaydenr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T15:08:59Z",
          "updatedAt": "2022-09-20T15:08:59Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "Addressed here: 6cad095ceea2b5d54233a5111253a2351a894149",
              "createdAt": "2022-09-20T15:08:59Z",
              "updatedAt": "2022-09-20T15:08:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CZpyz",
          "commit": {
            "abbreviatedOid": "16140f1"
          },
          "author": "ehaydenr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T15:13:01Z",
          "updatedAt": "2022-09-20T15:13:01Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "Agreed, how about something like this?\r\n\r\n> The peer-chosen connection ID that the sender of forwarded mode packets MUST\r\n> use when sending. The endpoint rewrites forwarding mode packets to contain the\r\n> correct Connection ID prior to sending them.",
              "createdAt": "2022-09-20T15:13:01Z",
              "updatedAt": "2022-09-20T15:13:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CZxdk",
          "commit": {
            "abbreviatedOid": "16140f1"
          },
          "author": "ehaydenr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T15:30:36Z",
          "updatedAt": "2022-09-20T15:30:36Z",
          "comments": [
            {
              "originalPosition": 149,
              "body": "Great point, I added some language here: f6ab95a1c0313babf5eb4c29e8fad8485fb0cab6",
              "createdAt": "2022-09-20T15:30:36Z",
              "updatedAt": "2022-09-20T15:30:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CZ399",
          "commit": {
            "abbreviatedOid": "16140f1"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T15:46:33Z",
          "updatedAt": "2022-09-20T15:46:33Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "Oh this doesn't match my understanding of how replacement works, which makes me wonder if the replacement is sufficiently well documented. I was assuming that in this scenario you would replace `0x11223344` with `0xaabb` (not `0xaabb3344`) so you might see these two packets in sequence:\r\n* before replacement `0x11223344abcdef...` `0x11223344fedcba...`\r\n* after replacement `0xaabbabcdef...` `0xaabbfedcba...`\r\n\r\nAm I misunderstanding how replacement works?",
              "createdAt": "2022-09-20T15:46:33Z",
              "updatedAt": "2022-09-20T15:46:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CZ8_B",
          "commit": {
            "abbreviatedOid": "f6ab95a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T15:58:59Z",
          "updatedAt": "2022-09-20T15:59:00Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "This new text is great, can we also augment it with an example where one device reboots and loses state, and what happens in that scenario to properly close the connection?",
              "createdAt": "2022-09-20T15:59:00Z",
              "updatedAt": "2022-09-20T15:59:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CaJP_",
          "commit": {
            "abbreviatedOid": "16140f1"
          },
          "author": "ehaydenr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T16:33:20Z",
          "updatedAt": "2022-09-20T16:33:20Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "In a previous commit, the replacement where the virtual cid is smaller than the cid is described [here](https://github.com/tfpauly/quic-proxy/pull/62/commits/6cad095ceea2b5d54233a5111253a2351a894149#diff-4dd090ab6ff7820385219d3ec1e86133930ab3a3b71aee2fe6e1a61a459f8da4L472)\r\n\r\n> If the Virtual Target Connection ID is smaller than the Target Connection ID,\r\n the client MUST only write the Virtual Target Connection ID bytes over the start\r\n of the Target Connection ID, leaving the remainder of the Target Connection ID\r\n unmodified.\r\n\r\nThat was removed in 6cad095ceea2b5d54233a5111253a2351a894149 when changing the requirement to be that the virtual cid be at least as long as the cid.\r\n\r\nI can update to document each case (virtual smaller, equal, and larger) to try to make this clearer once we get some alignment on what (if any) requirements should exist and what replacement should look like.\r\n\r\nI hadn't considered shrinking the packet when the virtual cid is smaller than the cid, but it would satisfy the exposure issue during migration and should work equally well. Assuming we go with this approach, the replacement is always a \"full\" replacement. @tfpauly not sure if you have any opinions here.",
              "createdAt": "2022-09-20T16:33:20Z",
              "updatedAt": "2022-09-20T16:33:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CaQ0C",
          "commit": {
            "abbreviatedOid": "f6ab95a"
          },
          "author": "ehaydenr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T16:56:54Z",
          "updatedAt": "2022-09-20T16:56:54Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "Thanks, I added an example in e191d7d958c2f127038f8df6426917c6958a763f. I went with a slightly different example, but I think it communicates the same thing.",
              "createdAt": "2022-09-20T16:56:54Z",
              "updatedAt": "2022-09-20T16:56:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85CaR-4",
          "commit": {
            "abbreviatedOid": "f6ab95a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-20T17:00:01Z",
          "updatedAt": "2022-09-20T17:00:01Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "Great, thanks!",
              "createdAt": "2022-09-20T17:00:01Z",
              "updatedAt": "2022-09-20T17:00:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85Cya_O",
          "commit": {
            "abbreviatedOid": "16140f1"
          },
          "author": "ehaydenr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-26T16:00:26Z",
          "updatedAt": "2022-09-26T16:00:26Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "@DavidSchinazi removed length restrictions in 02f2fd47be22fcfba66c5d085d9406bf3e752f4c",
              "createdAt": "2022-09-26T16:00:26Z",
              "updatedAt": "2022-09-26T16:00:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85Cyhs8",
          "commit": {
            "abbreviatedOid": "16140f1"
          },
          "author": "ehaydenr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-26T16:15:11Z",
          "updatedAt": "2022-09-26T16:15:12Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "updated with the above language in 7a2ec8dfe7b644a8f93e903a2ef500d6d49972c5",
              "createdAt": "2022-09-26T16:15:11Z",
              "updatedAt": "2022-09-26T16:15:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85EVqiE",
          "commit": {
            "abbreviatedOid": "7a2ec8d"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-18T21:15:27Z",
          "updatedAt": "2022-10-18T21:15:27Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Yeah, let's not address for now.",
              "createdAt": "2022-10-18T21:15:27Z",
              "updatedAt": "2022-10-18T21:15:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85EVrPl",
          "commit": {
            "abbreviatedOid": "7a2ec8d"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-18T21:18:19Z",
          "updatedAt": "2022-10-18T21:27:59Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nusing the Target Connection ID, load balancers would not be able to route packets\r\nto the correct Proxy if the packets were sent with the Target Connection ID.\r\nThe Virtual Target Connection ID is a connection ID chosen\r\n```",
              "createdAt": "2022-10-18T21:18:19Z",
              "updatedAt": "2022-10-18T21:27:59Z"
            },
            {
              "originalPosition": 28,
              "body": "```suggestion\r\nreceives with. Servers receiving QUIC packets can employ load balancing\r\n```",
              "createdAt": "2022-10-18T21:18:36Z",
              "updatedAt": "2022-10-18T21:27:59Z"
            },
            {
              "originalPosition": 30,
              "body": "```suggestion\r\nthat encode routing information in\r\n```",
              "createdAt": "2022-10-18T21:19:54Z",
              "updatedAt": "2022-10-18T21:27:59Z"
            },
            {
              "originalPosition": 275,
              "body": "```suggestion\r\nConnection ID with the real Client Connection ID before processing the packet further.\r\n```",
              "createdAt": "2022-10-18T21:24:37Z",
              "updatedAt": "2022-10-18T21:27:59Z"
            },
            {
              "originalPosition": 122,
              "body": "```suggestion\r\nThe REGISTER_CLIENT_CID and ACK_TARGET_CID capsule types include a Virtual\r\n```",
              "createdAt": "2022-10-18T21:25:51Z",
              "updatedAt": "2022-10-18T21:27:59Z"
            },
            {
              "originalPosition": 84,
              "body": "```suggestion\r\ncan be provided.\r\n```",
              "createdAt": "2022-10-18T21:26:10Z",
              "updatedAt": "2022-10-18T21:27:59Z"
            },
            {
              "originalPosition": 87,
              "body": "```suggestion\r\nIf the client is temporarily unresponsive or unreachable, the proxy might have\r\n```",
              "createdAt": "2022-10-18T21:26:22Z",
              "updatedAt": "2022-10-18T21:27:59Z"
            },
            {
              "originalPosition": 89,
              "body": "```suggestion\r\nthe stream mappings used for forwarding). If the client never learned about the closure, it\r\n```",
              "createdAt": "2022-10-18T21:26:54Z",
              "updatedAt": "2022-10-18T21:27:59Z"
            },
            {
              "originalPosition": 92,
              "body": "```suggestion\r\nand client<->proxy connection are still intact. The proxy will receive these\r\nforwarding mode packets, but won't have any state corresponding to the\r\n```",
              "createdAt": "2022-10-18T21:27:52Z",
              "updatedAt": "2022-10-18T21:27:59Z"
            }
          ]
        }
      ]
    },
    {
      "number": 64,
      "id": "PR_kwDOEHrEP85BDQJm",
      "title": "Unify around \"forwarded mode\"",
      "url": "https://github.com/tfpauly/quic-proxy/pull/64",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Closes #63 ",
      "createdAt": "2022-10-18T21:41:08Z",
      "updatedAt": "2022-10-19T03:23:02Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "4bb7edf24c105d7f82fd3dda19cf201991f62d21",
      "headRepository": "tfpauly/quic-proxy",
      "headRefName": "tfp/forwarded",
      "headRefOid": "b1419e860d7bd42818864825c303df54d9edfa11",
      "closedAt": "2022-10-19T03:23:02Z",
      "mergedAt": "2022-10-19T03:23:02Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "bb23e928b080acd6ac5e334651ec85f10368f7c1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85EWK_f",
          "commit": {
            "abbreviatedOid": "b1419e8"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-19T00:23:11Z",
          "updatedAt": "2022-10-19T00:23:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 66,
      "id": "PR_kwDOEHrEP85B171J",
      "title": "client communication of target-provided stateless reset token",
      "url": "https://github.com/tfpauly/quic-proxy/pull/66",
      "state": "MERGED",
      "author": "ehaydenr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #48, however, instead of converting stateless reset packets to a stream error, they are simply tunneled or forwarded to the client.\r\n\r\nA couple questions come to mind:\r\n\r\n**Should receipt of a stateless reset packet result in a stream error?**\r\n\r\n- Offers reliably delivered signal to the client that the connection is broken.\r\n- Allows the proxy to terminate the stream immediately and avoid having to consider handling of many stateless reset packets\r\n- What H3 error code? `H3_CONNECT_ERROR`?\r\n\r\n**If not a stream error, is tunneled _OR_ forwarded OK?**\r\n\r\n- If we require they be tunneled, does that make things easier for the client at no cost to the proxy?\r\n- Is there any reason why we wouldn't want the stateless reset packet sent \"in the clear\" (forwarded)?",
      "createdAt": "2022-10-30T23:19:01Z",
      "updatedAt": "2022-11-04T13:57:28Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "bb23e928b080acd6ac5e334651ec85f10368f7c1",
      "headRepository": "ehaydenr/quic-proxy",
      "headRefName": "stateless_reset",
      "headRefOid": "6da5331993d9dfb1bbe1c4bc51887f07d5919122",
      "closedAt": "2022-11-03T18:00:03Z",
      "mergedAt": "2022-11-03T18:00:03Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "1f05096db20a65f2139180f8a4a40e046e2483c2"
      },
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "I lean towards forwarding the stateless reset, rather than making this a stream error. That\u2019s effectively what the PR does, right?",
          "createdAt": "2022-10-31T03:46:26Z",
          "updatedAt": "2022-10-31T03:46:26Z"
        },
        {
          "author": "ehaydenr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> That\u2019s effectively what the PR does, right?\r\n\r\nYes, that was the intention. It also allows for _either_ tunneled or forwarded. That seemed like the least prescriptive, but I can also see an argument for restricting it only being sent via the tunnel instead of being forwarded. ",
          "createdAt": "2022-10-31T14:48:30Z",
          "updatedAt": "2022-10-31T14:48:30Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "body": "Yeah I could see that it might interfere with forwarding. Saying that it only tunnels would be a bit simpler. Only short header packets get forwarded, and this arguably doesn't meet that bar.",
          "createdAt": "2022-10-31T15:54:53Z",
          "updatedAt": "2022-10-31T15:54:53Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85FRnSD",
          "commit": {
            "abbreviatedOid": "d52813b"
          },
          "author": "ehaydenr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-31T17:11:42Z",
          "updatedAt": "2022-10-31T17:11:43Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "@tfpauly, is the wording here strict enough to prohibit forwarding (as opposed to tunneling) of stateless reset packets? If not, any suggested language?",
              "createdAt": "2022-10-31T17:11:42Z",
              "updatedAt": "2022-10-31T17:11:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85FR6wt",
          "commit": {
            "abbreviatedOid": "d52813b"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-31T18:08:39Z",
          "updatedAt": "2022-10-31T18:08:39Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nit can send the packet to the client as a tunnelled datagram. Although Stateless Reset packets\r\nlook like short header packets, they are not technically short header packets and do not contain\r\nnegotiated connection IDs, and thus are not eligible for forwarded mode.\r\n```",
              "createdAt": "2022-10-31T18:08:39Z",
              "updatedAt": "2022-10-31T18:08:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85FR6z7",
          "commit": {
            "abbreviatedOid": "d52813b"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-31T18:08:47Z",
          "updatedAt": "2022-10-31T18:08:48Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "@ehaydenr how about this?",
              "createdAt": "2022-10-31T18:08:47Z",
              "updatedAt": "2022-10-31T18:08:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEHrEP85FlbTL",
          "commit": {
            "abbreviatedOid": "6da5331"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-11-03T17:59:58Z",
          "updatedAt": "2022-11-03T17:59:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 72,
      "id": "PR_kwDOEHrEP85CN15Z",
      "title": "update forwarded mode migration guidance",
      "url": "https://github.com/tfpauly/quic-proxy/pull/72",
      "state": "OPEN",
      "author": "ehaydenr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "addresses #68 by clarifying active vs. passive migration guidance and describing how to change virtual CIDs without changing real CIDs",
      "createdAt": "2022-11-04T14:42:29Z",
      "updatedAt": "2022-11-04T19:50:00Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "1f05096db20a65f2139180f8a4a40e046e2483c2",
      "headRepository": "ehaydenr/quic-proxy",
      "headRefName": "network_paths",
      "headRefOid": "3cfbd96bb2914ec3d1abfbe366c0027b770938bf",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ehaydenr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think one of the challenges with doing CLOSE_ first is if you do CLOSE_CLIENT_CID then the proxy thinks it needs to remove state for port reuse too",
          "createdAt": "2022-11-04T19:49:59Z",
          "updatedAt": "2022-11-04T19:49:59Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85FrG96",
          "commit": {
            "abbreviatedOid": "fb2bf49"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "I like re-sending the REGISTER_CLIENT_CID with a new VCID, but it seems a bit odd to send a REGISTER_TARGET_CID that's duplicated as a signal to get a new VCID from the proxy.\r\n\r\nI see a few options:\r\n- Keep this proposal as-is\r\n- Before re-registering, have the client send explicit CLOSE_ messages for the old ones. This gets you to a \"restarted\" state\r\n- Client sends a new REGISTER_CLIENT, but not a REGISTER_TARGET, and the proxy sending a new ACK_TARGET with a new VCID uninitiated.\r\n\r\nNot sure which I prefer...",
          "createdAt": "2022-11-04T17:20:00Z",
          "updatedAt": "2022-11-04T17:24:42Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nit has received a new Target Connection ID for the target. In order to change\r\nthe connection ID bytes on the wire, a client can update a previously advertised Virtual Client\r\nConnection ID by sending a new REGISTER_CLIENT_CID with the same Connection ID,\r\nbut a different Virtual Connection ID. Similarly, the client may solicit a new\r\nVirtual Target Connection ID by sending a REGISTER_TARGET_CID capsule with\r\na previously registered Target Connection ID. Clients are responsible for\r\nchanging Virtual Connection IDs when the HTTP stream's network path changes to\r\navoid linkability across network paths. Note that initial\r\nREGISTER_CLIENT_CID capsules MAY be sent prior to receiving an HTTP response\r\nfrom the proxy.\r\n```",
              "createdAt": "2022-11-04T17:20:00Z",
              "updatedAt": "2022-11-04T17:24:42Z"
            },
            {
              "originalPosition": 49,
              "body": "```suggestion\r\nWhen operating in forwarded mode, the proxy reconfigures or removes forwarding\r\nrules as the network path between the client and proxy changes. In the event of\r\npassive migration, the proxy automatically reconfigures forwarding rules to use\r\nthe latest active and validated network path for the HTTP stream. In the event of\r\nactive migration, the proxy removes forwarding rules in order to not send\r\npackets with the same connection ID bytes over multiple network paths. After\r\ninitiating active migration, clients are no longer able to send forwarded mode\r\npackets since the proxy will have removed forwarding rules. Clients can proceed with\r\ntunnelled mode or can request new forwarding rules via REGISTER_CLIENT_CID and\r\nREGISTER_TARGET_CID capsules. Each of these capsules will contain new virtual\r\nconnection IDs to prevent packets with the same connection ID bytes being used\r\nover multiple network paths. Note that the Client Connection ID and Target\r\nConnection ID can stay the same while the Virtual Target Connection ID and\r\nVirtual Client Connection ID change.\r\n```",
              "createdAt": "2022-11-04T17:22:05Z",
              "updatedAt": "2022-11-04T17:24:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 73,
      "id": "PR_kwDOEHrEP85CN3sX",
      "title": "allow clients to send capsules before HTTP response",
      "url": "https://github.com/tfpauly/quic-proxy/pull/73",
      "state": "MERGED",
      "author": "ehaydenr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "addresses #71 ",
      "createdAt": "2022-11-04T14:47:42Z",
      "updatedAt": "2022-11-04T15:26:53Z",
      "baseRepository": "tfpauly/quic-proxy",
      "baseRefName": "main",
      "baseRefOid": "1f05096db20a65f2139180f8a4a40e046e2483c2",
      "headRepository": "ehaydenr/quic-proxy",
      "headRefName": "contradict",
      "headRefOid": "718fbf63b15c091d9db561451dd7cd09b9ec007f",
      "closedAt": "2022-11-04T15:25:48Z",
      "mergedAt": "2022-11-04T15:25:48Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "5ce4e8681e46015af42c3e136888ebfe1fa5c214"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEHrEP85Fqcjm",
          "commit": {
            "abbreviatedOid": "718fbf6"
          },
          "author": "tfpauly",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-11-04T15:25:43Z",
          "updatedAt": "2022-11-04T15:25:43Z",
          "comments": []
        }
      ]
    }
  ]
}